<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: open source | Brandon Hilkert]]></title>
  <link href="http://brandonhilkert.com/blog/categories/open-source/atom.xml" rel="self"/>
  <link href="http://brandonhilkert.com/"/>
  <updated>2014-05-16T07:43:27-04:00</updated>
  <id>http://brandonhilkert.com/</id>
  <author>
    <name><![CDATA[Brandon Hilkert]]></name>
    <email><![CDATA[brandonhilkert@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails Reloader: A Lesser Known Railtie Hook]]></title>
    <link href="http://brandonhilkert.com/blog/rails-reloader-a-lesser-known-railtie-hook/"/>
    <updated>2014-04-21T19:48:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/rails-reloader-a-lesser-known-railtie-hook</id>
    <content type="html"><![CDATA[<p>I recently wrote <a href="http://brandonhilkert.com/books/build-a-ruby-gem/?utm_source=bh-come&amp;utm_medium=web&amp;utm_campaign=reloader">a book about integrating with Rails from a Ruby gem</a>, which specifically touched on using a <a href="http://api.rubyonrails.org/classes/Rails/Railtie.html">Railtie</a> to extend <code>ActiveRecord</code>, <code>ActionController</code> and <code>ActionView</code> . While these are the 3 more popular Rails libraries, there’s plenty others <a href="http://guides.rubyonrails.org/configuring.html">that are configurable</a>.</p>

<p>A <a href="https://github.com/brandonhilkert/sucker_punch/issues/49">recent issue</a> in <a href="https://github.com/brandonhilkert/sucker_punch">Sucker Punch</a> caused me to go digging through the Rails source code. Ultimately, the <code>to_prepare</code> method on <code>ActionDispatch::Reloader</code> resolved the issue, but I surprised was to find very little documentation about it.</p>

<!--more-->


<h2>The Problem</h2>

<p><a href="https://github.com/brandonhilkert/sucker_punch">Sucker Punch</a> lazily creates the <a href="http://celluloid.io/">Celluloid</a> pools used for background job queues. For the purpose of keeping track of the queues already initialized, Sucker Punch makes use of the <a href="https://github.com/celluloid/celluloid/wiki/Registry">Celluloid Registry</a>. Think of it as a class-level hash.</p>

<p>This works swimmingly in production, but not so much in development. Rails makes our lives easier by reloading code in between requests while in development, due to this setting in <code>config/environments/development.rb</code>:</p>

<p><code>
  config.cache_classes = false
</code></p>

<p>Without it, we’d be forced to restart the server after almost every request. If that sounds like a giant PITA to you, I whole heartedly agree!</p>

<p>So now you make your awesome job class, do some background work (send an email for example) and reload the page and boom:</p>

<p><code>``
Celluloid::PoolManager: async call</code>perform` aborted!
ArgumentError: A copy of SendInvitationJob has been removed from the module tree but is still active!</p>

<pre><code>    gems/activesupport-4.0.3/lib/active_support/dependencies.rb:446:in `load_missing_constant'
    gems/activesupport-4.0.3/lib/active_support/dependencies.rb:184:in `const_missing'
    my-app/app/jobs/send_invitation_job.rb:6:in `block in perform'
</code></pre>

<p>```</p>

<p>The Celluloid registry still has reference to a the original <code>SendInvitationJob</code> class when it was initialized, however, reloading the code has caused the original reference to disappear and all hell breaks loose when the queue key is fetched to send another job to the class.</p>

<p>In my head, it made sense for the queues to be cleared out upon every request in development. In general, because Sucker Punch doesn’t have persistent queues, the best use case is for quick one-off jobs that aren’t extremely important — email and logging come to mind. Since both of these examples are typically pretty speedy, it’s unlikely there will be a huge job backup upon subsequent requests.</p>

<p>I knew what I wanted, but didn’t know how to accomplish it.</p>

<h2>The Solution</h2>

<p>Knowing the issue was related to the setting <code>config.cache_classes = false</code> in the development environment, I broke open the Rails source code and searched for <code>cache_classes</code>. The first result was the <a href="https://github.com/rails/rails/blob/master/actionpack/lib/action_dispatch/middleware/reloader.rb"><code>ActionDispatch</code> reloader middleware</a>. Fortunately, there’s a very descriptive comment at the top of the class:</p>

<p><code>
  # By default, ActionDispatch::Reloader is included in the middleware stack
  # only in the development environment; specifically, when +config.cache_classes+
  # is false. Callbacks may be registered even when it is not included in the
  # middleware stack, but are executed only when &lt;tt&gt;ActionDispatch::Reloader.prepare!&lt;/tt&gt;
  # or &lt;tt&gt;ActionDispatch::Reloader.cleanup!&lt;/tt&gt; are called manually.
</code></p>

<p>This functionality is exactly what I needed!. From here, I just needed to know what callbacks were valid. A few lines in to the class are the following methods:</p>

<p>```</p>

<pre><code># Add a prepare callback. Prepare callbacks are run before each request, prior
# to ActionDispatch::Callback's before callbacks.
def self.to_prepare(*args, &amp;block)
  unless block_given?
    warn "to_prepare without a block is deprecated. Please use a block"
  end
  set_callback(:prepare, *args, &amp;block)
end

# Add a cleanup callback. Cleanup callbacks are run after each request is
# complete (after #close is called on the response body).
def self.to_cleanup(*args, &amp;block)
  unless block_given?
    warn "to_cleanup without a block is deprecated. Please use a block"
  end
  set_callback(:cleanup, *args, &amp;block)
end
</code></pre>

<p>```</p>

<p><code>to_prepare</code> and <code>to_cleanup</code>…and like the comments say, they do exactly what you’d expect. Given that I wanted to clear our the Celluloid registry BEFORE each request, <code>on_prepare</code> is the golden ticket. Now I just needed to figure out how to clear the registry.</p>

<p>A quick glade over the <a href="http://rubydoc.info/gems/celluloid/Celluloid/Registry"><code>Celluloid::Registry</code> class documentation</a> shows some methods that might be of value. It turns out that these are instance methods for an instance of the <code>Celluloid::Registry</code> class. Unfortunately, when Celluloid boots, it instantiates a registry to use internally, so we need a way to get at that particular instance and clear it out. Sure enough, <a href="http://rubydoc.info/gems/celluloid/Celluloid/Actor#clear_registry-class_method">a class method to do just that in <code>Celluloid::Actor</code></a> is available.</p>

<p>Now that we all the pieces of the puzzle, it was time to put together a Railtie to trigger the behavior. Prior to needing this functionality, the Railtie in Sucker Punch was pretty simple:</p>

<p>```
module SuckerPunch
  class Railtie &lt; ::Rails::Railtie</p>

<pre><code>initializer "sucker_punch.logger" do
  SuckerPunch.logger = Rails.logger
end
</code></pre>

<p>  end
end
```</p>

<p>All it did was connect the logger to the existing Rails logger. Adding the callback to <code>ActionDispatch</code> looks like:</p>

<p>```
module SuckerPunch
  class Railtie &lt; ::Rails::Railtie</p>

<pre><code>initializer "sucker_punch.logger" do
  SuckerPunch.logger = Rails.logger
end

config.to_prepare do
  Celluloid::Actor.clear_registry
end
</code></pre>

<p>  end
end
```</p>

<p>Now when the Railtie is loaded, the <code>Celluloid::Actor.clear_registry</code> method is triggered before the reloading of code in the development environment, clearing out the Celluloid registry and allowing Sucker Punch to instantiate new job queues for each request.</p>

<h2>Summary</h2>

<p>I was unaware of any of these methods when the issue was submitted. Rather than throw my hands up and close the issue because it didn’t affect me, I thought through an approach that could work, and only then started to write code. And in fact, didn’t know what code to write!</p>

<p>Comments and well written code serve as great documentation. I probably wouldn’t have stumbled on <code>ActionDispatch::Reloader</code> without the detailed comments at the top of the class. Sure, I would’ve found the <code>cache_classes</code> line, but might not have given it more thought.</p>

<p>Next time you have a question about the syntax of a method or the order of its arguments, clone the repo (if it’s open source, of course) and do a search. I think you’ll be surprised at how quickly you can find what you’re looking for. My guess is you’ll also be pleasantly surprised at the other things you stumble upon in the process.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build a Ruby Gem eBook is Live!]]></title>
    <link href="http://brandonhilkert.com/blog/build-a-ruby-gem-is-live/"/>
    <updated>2014-03-26T23:49:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/build-a-ruby-gem-is-live</id>
    <content type="html"><![CDATA[<p>After several weeks of <strong>really</strong> early mornings, <a href="http://brandonhilkert.com/books/build-a-ruby-gem?utm_source=bh-com&amp;utm_medium=web&amp;utm_campaign=launch"><em>Build a Ruby Gem</em></a> is finally live:</p>

<p><a href="http://brandonhilkert.com/books/build-a-ruby-gem?utm_source=bh-com&amp;utm_medium=web&amp;utm_campaign=launch">http://brandonhilkert.com/books/build-a-ruby-gem/</a></p>

<p>Thanks again for all the support and encouragement. I had a great time working
on it and really look forward to hearing your feedback.</p>

<!--more-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Build a Rails Engine]]></title>
    <link href="http://brandonhilkert.com/blog/how-to-build-a-rails-engine/"/>
    <updated>2014-03-24T17:26:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/how-to-build-a-rails-engine</id>
    <content type="html"><![CDATA[<p>_This is one of the final post leading up the the launch of the
[__Build a Ruby Gem Ebook__](/books/build-a-ruby-gem/?utm_source=bh-com&utm_medium=web&utm_campaign=launch),
which is now available for sale in [3 packages](/books/build-a-ruby-gem/?utm_source=bh-com&utm_medium=web&utm_campaign=launch),
including __14 chapters of code__ and over 2 hours of screencasts_.


</p>

<p>Rails engines range from simple plugins to powerful micro-applications. The discussions we’ve had so far about Railties are closely related to the function of a Rails engine. One interesting side note is that a Rails application is a Rails engine itself — so it’s easy to see how we can encapsulate just about any normal Rails functionality in an engine, to ultimately embed in a host application.</p>

<p>The <a href="http://guides.rubyonrails.org/engines.html?utm_source=bh-com&amp;utm_medium=web&amp;utm_campaign=rails-engines">Rails engine documentation</a> is well written and touches on the many ways to include functionality. I won’t cover every detail of Rails engines in this chapter, just enough to get you started making use of them. It’s possible to make full applications (routes, controllers, models, migrations, etc.) using Rails engines. However, we’re going to focus on some of the simpler the elements of a Rails engine that allow us to integrate functionality where a Railtie won’t suffice. Just know, there is far more you can do with Rails engines than what we’ll cover here. The documentation link above provides examples of many of those use cases.</p>

<!--more-->


<h2>Use Case</h2>

<p>I wrote a <a href="http://brandonhilkert.com/blog/relative-timestamps-in-rails/?utm_source=bh-com&amp;utm_medium=web&amp;utm_campaign=rails-engines">blog post about rendering relatives timestamps in Rails</a> on the client. Using a client-side solution like <a href="http://timeago.yarp.com/?utm_source=bh-com&amp;utm_medium=web&amp;utm_campaign=rails-engines">timeago.js</a> allows timestamps to update in real-time, so when we see “15 minutes ago”, we know the record <em>really</em> is 15 minutes old.</p>

<p>The other benefit to using a client-side library like <code>timeago.js</code> is timezone offsets are handled automatically. All we have to do is render the UTC time in the view and javascript will handle converting it to the relative timezone of the browser, along with keeping it updated as the page becomes stale.</p>

<p>For this example, we’ll make a gem that integrates <code>timeago.js</code> in to a Rails application and provides a simple way to render relative timestamps in a view.</p>

<h2>The Implementation</h2>

<p>The implementation of our gem will require:</p>

<ol>
<li>Adding the <code>timeago.js</code> javascript asset to the asset pipeline</li>
<li>Adding a javascript asset to invoke the <code>timeago()</code> plugin</li>
<li>Adding a view helper to render html in a format the javascript plugin expects</li>
</ol>


<p>The third requirement was covered in a previous chapter on view helpers, so we’ll cruise through that one quickly. However, including assets hasn’t been covered and it’s the perfect segue in to the benefits of using a Rails engine, rather than just a Railtie.</p>

<p>Rails engines allow us create the same directory structure of a Rails application, since a Rails application is just a Rails engine. By indicating our gem is an engine (we’ll see how to do this soon…), Rails will pick up the related files in the Rails-specific directories in our gem. So if we add a file in the <code>app/helpers/</code> directory of our gem, that same file will be available in the host Rails application. The same approach applies for controllers, models, migrations, assets and anything else we would add to a typical Rails application.</p>

<p>To start, let’s create our new gem:</p>

<p>```bash
$ bundle gem time_ago</p>

<pre><code>  create  time_ago/Gemfile
  create  time_ago/Rakefile
  create  time_ago/LICENSE.txt
  create  time_ago/README.md
  create  time_ago/.gitignore
  create  time_ago/time_ago.gemspec
  create  time_ago/lib/time_ago.rb
  create  time_ago/lib/time_ago/version.rb
</code></pre>

<p>Initializing git repo in /Users/bhilkert/Dropbox/code/time_ago
```</p>

<p>When we include javascript libraries from external sources, the <code>vender/</code> directory is the most appropriate place for them. Let’s create the directory <code>vendor/javascripts/</code> and place the source for the <code>timeago.js</code> plugin there:</p>

<p>```bash
├── Gemfile
├── LICENSE.txt
├── Rakefile
├── lib
│   ├── time_ago
│   │   └── version.rb
│   └── time_ago.rb
├── time_ago.gemspec
└── vendor</p>

<pre><code>└── assets
    └── jquery.timeago.js
</code></pre>

<p>```</p>

<p>To create our view helper, we’ll add the <code>/app/helpers/</code> directory:</p>

<p>```bash
├── Gemfile
├── LICENSE.txt
├── Rakefile
├── app
│   └── helpers
│       └── time_ago_helper.rb
├── lib
│   ├── time_ago
│   │   └── version.rb
│   └── time_ago.rb
├── time_ago.gemspec
└── vendor</p>

<pre><code>└── assets
    └── jquery.timeago.js
</code></pre>

<p>```</p>

<p>The code for the view helper is shown below:</p>

<p>```ruby
module TimeAgoHelper
  def timeago(time, options = {})</p>

<pre><code>options[:class] ||= "timeago"
content_tag(
 :time,
 time.to_s,
 options.merge(datetime: time.getutc.iso8601)
) if time
</code></pre>

<p>  end
end
```</p>

<p>Lastly, we want to include a javascript asset to invoke the <code>timeago.js</code> plugin on page change (this includes the initial page load). This is almost identical to the first step of including the vendored <code>timeago.js</code> asset, except we’re going to put it in the <code>app/assets/javascripts/</code> directory since it’s not an external library, but rather a javascript include that will invoke the javascript plugin.</p>

<p>Let’s create the directory <code>app/assets/javascripts/</code> and place the following file there:</p>

<p>```javascript
// app/assets/javascripts/timeago.js
//
// jQuery Timeago setup for timeago helper
//
//= require jquery.timeago</p>

<p>$(document).on(&lsquo;page:change&rsquo;, function() {
  $(&ldquo;time.timeago&rdquo;).timeago();
});
```</p>

<p>This file serves as both a manifest file for the <code>jquery.timeago.js</code> asset and a function to invoke the plugin whenever the page loads or changes.</p>

<p>Lastly, we need to designate our gem as an engine. The default entry file that was created when we used bundler to bootstrap our gem looked like this:</p>

<p>```ruby
require &ldquo;time_ago/version&rdquo;</p>

<p>module TimeAgo
end
```</p>

<p>All we need to do is add the <code>Engine</code> class and inherit from <code>Rails::Engine</code>, giving us:</p>

<p>```ruby
require &ldquo;time_ago/version&rdquo;</p>

<p>module TimeAgo
  class Engine &lt; ::Rails::Engine
  end
end
```</p>

<p>At this point, because our gem is so closely tied to Rails, we should add Rails as a dependency in our gemspec:</p>

<p>```ruby</p>

<h1>coding: utf-8</h1>

<p>lib = File.expand_path(&lsquo;../lib&rsquo;, <strong>FILE</strong>)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
require &lsquo;time_ago/version&rsquo;</p>

<p>Gem::Specification.new do |spec|
  spec.name          = &ldquo;time_ago&rdquo;
  spec.version       = TimeAgo::VERSION
  spec.authors       = [&ldquo;Brandon Hilkert&rdquo;]
  spec.email         = [&ldquo;<a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x62;&#114;&#x61;&#110;&#100;&#111;&#110;&#104;&#x69;&#x6c;&#x6b;&#x65;&#114;&#116;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#109;">&#98;&#114;&#x61;&#x6e;&#x64;&#x6f;&#x6e;&#104;&#x69;&#x6c;&#107;&#x65;&#x72;&#x74;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d;</a>&rdquo;]
  spec.summary       = %q{A gem to integrate the timeago.js}
  spec.description   = %q{A gem to integrate the timeago.js}
  spec.homepage      = &ldquo;&rdquo;
  spec.license       = &ldquo;MIT&rdquo;</p>

<p>  spec.files         = <code>git ls-files -z</code>.split(&ldquo;\x0&rdquo;)
  spec.executables   = spec.files.grep(%r{^bin/}) { |f| File.basename(f) }
  spec.test_files    = spec.files.grep(%r{^(test|spec|features)/})
  spec.require_paths = [&ldquo;lib&rdquo;]</p>

<p>  spec.add_dependency &ldquo;rails&rdquo;, &ldquo;>= 3.1&rdquo;</p>

<p>  spec.add_development_dependency &ldquo;bundler&rdquo;, &ldquo;~> 1.5&rdquo;
  spec.add_development_dependency &ldquo;rake&rdquo;
end
```</p>

<p><em>Note: In addition to adding Rails as a dependency, we’ve also specified that it’s only compatible with Rails version <code>3.1</code> or later because of the need for the asset pipeline.</em></p>

<p>Moving to a sample Rails application, we can include the gem in our host application by adding it to the <code>Gemfile</code> using the path option:</p>

<p><code>ruby
gem "time_ago", path: "../time_ago"
</code></p>

<p>Since we included an asset that needs to be included in the Rails asset pipeline, we have to take one more step and instruct the user to add the following to their <code>app/assets/javascripts/application.js</code> manifest file:</p>

<p><code>javascript
//= require timeago
</code></p>

<p>This directive actually refers to the <code>app/assets/javascripts/timeago.js</code> file we included in our gem to invoke the timeago.js plugin on page change.</p>

<p>Now when we load our Rails application, tags using the <code>timeago</code> view helper get rendered to UI as:</p>

<p>```html
<time class="timeago" datetime="2014-01-08T14:55:58Z"></p>

<pre><code>2014-01-08 14:55:58 UTC
</code></pre>

<p></time>
```</p>

<p>and are updated by the javascript plugin to:</p>

<p>```html
<time class="timeago" datetime="2014-01-08T15:04:10Z"
   title="2014-01-08 15:04:10 UTC"></p>

<pre><code> 18 days ago
</code></pre>

<p></time>
```</p>

<h2>Implementations in the Wild</h2>

<p>One of the greatest examples of making the most of a Rails engine is <a href="https://github.com/plataformatec/devise?utm_source=bh-com&amp;utm_medium=web&amp;utm_campaign=rails-engines">Devise</a>. Devise is one of the more popular options for adding authentication to a Rails application. Just looking at the <a href="https://github.com/plataformatec/devise/tree/master/app?utm_source=bh-com&amp;utm_medium=web&amp;utm_campaign=rails-engines">app directory of the gem</a>, we can see Devise adds functionality through controllers, helpers, mailers and views. The structure of Devise is fairly complicated because it is doing so much, but <a href="https://github.com/plataformatec/devise/blob/master/lib/devise/rails.rb?utm_source=bh-com&amp;utm_medium=web&amp;utm_campaign=rails-engines#L5">here is where the Rails engine is defined</a> allowing the elements in the <code>/app</code> directory (among other things) to be integrated in to a Rails application.</p>

<p>The <a href="https://github.com/basecamp/local_time?utm_source=bh-com&amp;utm_medium=web&amp;utm_campaign=rails-engines">local_time gem</a> from Basecamp is a simple example of using the asset includes of a Rails engine to render relative timestamps. It’s similar to the one we created above, but uses the <a href="http://momentjs.com/?utm_source=bh-com&amp;utm_medium=web&amp;utm_campaign=rails-engines">moment.js</a> javascript library instead. Because it’s well tested and likely to be supported long-term, I’d suggest using it instead of the gem we created above.</p>

<h2>Summary</h2>

<p>The introduction of Rails engines created a new way to organize micro-applications and integrate them into a host application. Doing so keeps features and otherwise separate logic truly separate.</p>

<p>I’ve only scratched the surface on what a gem can provide through engines. It’s certainly more detailed than just asset and view helper integration, as shown above. If you’re interested in learning more about the other features Rails engine provide, <a href="http://guides.rubyonrails.org/engines.html?utm_source=bh-com&amp;utm_medium=web&amp;utm_campaign=rails-engines">the Rails guides</a> are a great place to start.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build a Ruby Gem Ebook Available on Thursday]]></title>
    <link href="http://brandonhilkert.com/blog/build-a-ruby-gem-ebook-available-on-thursday/"/>
    <updated>2014-03-24T06:03:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/build-a-ruby-gem-ebook-available-on-thursday</id>
    <content type="html"><![CDATA[<p>_This is one of the final post leading up the the launch of the
[__Build a Ruby Gem Ebook__](/books/build-a-ruby-gem/?utm_source=bh-com&utm_medium=web&utm_campaign=launch),
which is now available for sale in [3 packages](/books/build-a-ruby-gem/?utm_source=bh-com&utm_medium=web&utm_campaign=launch),
including __14 chapters of code__ and over 2 hours of screencasts_.


</p>

<p>I spent the last couple of weeks with my head down focusing on producing the best content possible for the upcoming release of my <em><a href="http://brandonhilkert.com/books/build-a-ruby-gem/?utm_source=bh-com&amp;utm_medium=email&amp;utm_campaign=packages">Build a Ruby Gem</a></em> ebook. I’m excited to finally show you what I’ve been working on.</p>

<p>The book will be available starting at <strong>Midnight (EDT) on Thursday, March 27th</strong> and can be purchased from <strong><a href="http://brandonhilkert.com/books/build-a-ruby-gem/?utm_source=bh-com&amp;utm_medium=email&amp;utm_campaign=packages">my website</a></strong>.</p>

<!--more-->


<p>3 packages will be available:</p>

<ol>
<li><p><strong>Ebook</strong> only — $39</p>

<p> The book is 19 chapters, totaling 136 pages. The book content ranges from how to get started with open source projects to the nitty gritty of <a href="http://brandonhilkert.com/blog/ruby-gem-configuration-patterns/?utm_source=bh-com&amp;utm_medium=email&amp;utm_campaign=packages">configuration patterns in a Ruby gem</a>. The <a href="http://brandonhilkert.com/books/build-a-ruby-gem/?utm_source=bh-com&amp;utm_medium=email&amp;utm_campaign=packages">chapter list</a> offers a detailed list of the topics included.</p></li>
<li><p><strong>Ebook</strong> + <strong>Code</strong> (14 chapters of code)  — $79</p>

<p> In addition to the ebook above, I have packaged the <strong>code from all 14 technical chapters</strong> — several of which include Rails applications with the sample gem code mounted. This is the perfect package if you want down to the code level and really get your hands dirty.</p></li>
<li><p><strong>Ebook</strong> + <strong>Code</strong> (14 chapters of code) + <strong>Screencasts</strong> (2 hrs. of video) — $129</p>

<p> In addition to the ebook and code above, I have created <strong>14 screencasts totaling over 2 hours of detailed workflow</strong>. I go through the process of writing the code for each technical chapter and discuss the benefits and downsides to the various approaches.</p></li>
</ol>


<p>I can’t tell you how excited I am to finally share this content with you. It’s been a little over 3 months since I announced that I was writing a book on building Ruby gems. To see so much interest has been really gratifying. I really can’t wait to see what you build as a result.</p>

<p>As promised, I will be sending out a <strong>discount code on Tuesday night</strong> for those on the book mailing list, good for <strong>20% off the listed price of any package</strong>. The discount will only be <strong>available for the first 24 hours</strong>. After that, the packages will return to the prices listed above.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Gem Configuration Patterns]]></title>
    <link href="http://brandonhilkert.com/blog/ruby-gem-configuration-patterns/"/>
    <updated>2014-03-17T20:26:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/ruby-gem-configuration-patterns</id>
    <content type="html"><![CDATA[<p>_This is one of the final post leading up the the launch of the
[__Build a Ruby Gem Ebook__](/books/build-a-ruby-gem/?utm_source=bh-com&utm_medium=web&utm_campaign=launch),
which is now available for sale in [3 packages](/books/build-a-ruby-gem/?utm_source=bh-com&utm_medium=web&utm_campaign=launch),
including __14 chapters of code__ and over 2 hours of screencasts_.


</p>

<p>The world isn’t black and white (as much as we’d like to believe it is). Just because our gem’s functionality may work for us, doesn’t mean it’ll work for everyone.</p>

<p>Fortunately, we can give users the ability to add custom configuration data, allowing them to adapt our code to their own use. In this post, we&rsquo;ll adapt the <a href="https://github.com/brandonhilkert/mega_lotto"><code>mega_lotto</code> gem</a> to take a configuration block that modifies the number of integers returned from the <code>#draw</code> method output.</p>

<!--more-->


<h2>Use Case</h2>

<p>Our <code>mega_lotto</code> gem provides the functionality to randomly draw 6 numbers. However, let’s assume that someone else has taken interest in the code for our gem, but needs the code to generate 10 random numbers within the same range.</p>

<p>One option would be for them to fork the code and modify the gem to fit their needs. However, now there’s a randomly forked gem with the same name and it’s unclear why one should be used over the other, especially if no changes to the <code>README</code> were made.</p>

<p>Rather than go down that path, we can make our existing <code>mega_lotto</code> gem more flexible by returning 6 integers by default, while also providing an interface to customize this value for those with the need.</p>

<p>Our goal is to adapt our gem to take a configuration block like this:</p>

<p><code>ruby
MegaLotto.configure do |config|
  config.drawing_count = 10
end
</code></p>

<h2>Implementation</h2>

<p>Let’s first write some specs for the desired functionality. Because the <code>.configure</code> method above is off the main <code>MegaLotto</code> namespace, we’ll create the spec file <code>spec/mega_lotto_spec.rb</code>. With this spec, we’ll assert that after running the configuration block above, the <code>#drawing</code> method returns an array (like before), but this time with 10 integers instead:</p>

<p>```ruby
require &ldquo;spec_helper&rdquo;</p>

<p>describe MegaLotto do
  describe &ldquo;#configure&rdquo; do</p>

<pre><code>before do
  MegaLotto.configure do |config|
    config.drawing_count = 10
  end
end

it "returns an array with 10 elements" do
  draw = MegaLotto::Drawing.new.draw

  expect(draw).to be_a(Array)
  expect(draw.size).to eq(10)
end
</code></pre>

<p>  end
end
```</p>

<p>This spec serves as higher level integration spec because it’s accessing the public API of our gem. Because of this, we can be sure that once this spec passes, our implementation is complete. As expected, when we run this spec, it fails:</p>

<p>```bash
MegaLotto
  #configure</p>

<pre><code>returns an array with 10 elements (FAILED - 1)
</code></pre>

<p>Failures:</p>

<p>  1) MegaLotto#config returns an array with 10 elements</p>

<pre><code> Failure/Error: MegaLotto.configure do |config|
 NoMethodError:
   undefined method `configure` for MegaLotto:Module
 # ./spec/mega_lotto_spec.rb:6
</code></pre>

<p>Finished in 0.00131 seconds
1 example, 1 failure
```</p>

<p>Now that we have a spec to work against, let’s continue our implementation.</p>

<p>The failure above complained that there was no <code>MegaLotto.configure</code> method, so let’s add it:</p>

<p><code>ruby
module MegaLotto
  def self.configure
  end
end
</code></p>

<p>Re-running our specs gives us a different failure message this time:</p>

<p>```bash
MegaLotto
  #configure</p>

<pre><code>returns an array with 10 elements (FAILED - 1)
</code></pre>

<p>Failures:</p>

<p>  1) MegaLotto#configure returns an array with 10 elements</p>

<pre><code> Failure/Error: expect(draw.size).to eq(10)

   expected: 10
        got: 6

   (compared using ==)
 # ./spec/mega_lotto_spec.rb:15
</code></pre>

<p>Finished in 0.00246 seconds
1 example, 1 failure
```</p>

<p>The output now shows that the code still returned 6 integers, which we expected because our <code>.configure</code> method hasn’t done anything yet.</p>

<p>Because we’re using a object-oriented language like Ruby, we can create a <code>Configuration</code> class whose responsibility will be…(drumroll)….configuration!</p>

<p>Let’s start with some specs:</p>

<p>```ruby</p>

<h1>spec/mega_lotto/configuration_spec.rb</h1>

<p>require &ldquo;spec_helper&rdquo;</p>

<p>module MegaLotto
  describe Configuration do</p>

<pre><code>describe "#drawing_count" do
  it "default value is 6" do
    Configuration.new.drawing_count = 6
  end
end

describe "#drawing_count=" do
  it "can set value" do
    config = Configuration.new
    config.drawing_count = 7
    expect(config.drawing_count).to eq(7)
  end
end
</code></pre>

<p>  end
end
```</p>

<p>Running the configuration specs produces:</p>

<p><code>bash
/Users/bhilkert/Dropbox/code/mega_lotto/spec/
mega_lotto/configuration_spec.rb:4:in `&lt;module:MegaLotto&gt;`:
uninitialized constant MegaLotto::Configuration (NameError)
</code></p>

<p>Let’s add the <code>Configuration</code> class:</p>

<p>```ruby</p>

<h1>lib/mega_lotto/configuration.rb</h1>

<p>module MegaLotto
  class Configuration
  end
end
```</p>

<p>Let’s try again:</p>

<p><code>bash
/Users/bhilkert/Dropbox/code/mega_lotto/spec/
mega_lotto/configuration_spec.rb:4:in `&lt;module:MegaLotto&gt;`:
uninitialized constant MegaLotto::Configuration (NameError)
</code></p>

<p>What??? Same message…Even though we added the <code>Configuration</code> class above, our gem doesn’t load it. So we can dive in to the entry file <code>lib/mega_lotto.rb</code> and add the appropriate require statement:</p>

<p>```ruby
require &ldquo;mega_lotto/version&rdquo;
require &ldquo;mega_lotto/configuration&rdquo;
require &ldquo;mega_lotto/drawing&rdquo;</p>

<p>begin
  require &ldquo;pry&rdquo;
rescue LoadError
end</p>

<p>module MegaLotto
  def self.configure
  end
end
```</p>

<p>Now with the <code>Configuration</code> class properly loaded, let’s run our specs again:</p>

<p>```bash
MegaLotto::Configuration
  #drawing_count</p>

<pre><code>default value is 6 (FAILED - 1)
</code></pre>

<p>  #drawing_count=</p>

<pre><code>can set value (FAILED - 2)
</code></pre>

<p>Failures:</p>

<p>  1) MegaLotto::Configuration#drawing_count default value is 6</p>

<pre><code> Failure/Error: expect(config.drawing_count).to eq(6)
 NoMethodError:
   undefined method `drawing_count` for #&lt;MegaLotto::Configuration&gt;
 # ./spec/mega_lotto/configuration_spec.rb:8
</code></pre>

<p>  2) MegaLotto::Configuration#drawing_count= can set value</p>

<pre><code> Failure/Error: config.drawing_count = 7
 NoMethodError:
   undefined method `drawing_count=` for #&lt;MegaLotto::Configuration&gt;
 # ./spec/mega_lotto/configuration_spec.rb:15
</code></pre>

<p>Finished in 0.00175 seconds
2 examples, 2 failures
```</p>

<p>Even though we still have failures, we’re making progress. The failures above relate to the lack of a <code>#drawing_count=</code> method, so let’s add an accessor for it:</p>

<p>```ruby
module MegaLotto
  class Configuration</p>

<pre><code>attr_accessor :drawing_count
</code></pre>

<p>  end
end
```</p>

<p><em>Note: We could’ve just added an <code>attr_writer</code> to satisfy the spec. However, I know I’m going to need a getter down the road, so I chose to do it at the same time.</em></p>

<p>With our accessor in place, let’s check the specs again:</p>

<p>```bash
MegaLotto::Configuration
  #drawing_count=</p>

<pre><code>can set value
</code></pre>

<p>  #drawing_count</p>

<pre><code>default value is 6 (FAILED - 1)
</code></pre>

<p>Failures:</p>

<p>  1) MegaLotto::Configuration#drawing_count default value is 6</p>

<pre><code> Failure/Error: expect(config.drawing_count).to eq(6)

   expected: 6
        got: nil

   (compared using ==)
 # ./spec/mega_lotto/configuration_spec.rb:8
</code></pre>

<p>Finished in 0.00239 seconds
2 examples, 1 failure
```</p>

<p>Still a failure, but we’re slowly making more progress. The default value isn’t getting set so we’ll change that in the implementation:</p>

<p>```ruby
module MegaLotto
  class Configuration</p>

<pre><code>attr_accessor :drawing_count

def initialize
  @drawing_count = 6
end
</code></pre>

<p>  end
end
```</p>

<p>Running the specs one more time for the <code>Configuration</code> class shows that we’re good:</p>

<p>```bash
MegaLotto::Configuration
  #drawing_count</p>

<pre><code>default value is 6
</code></pre>

<p>  #drawing_count=</p>

<pre><code>can set value
</code></pre>

<p>Finished in 0.00172 seconds
2 examples, 0 failures
```</p>

<p>Running the specs for the main <code>spec/mega_lotto.rb</code> class again:</p>

<p>```bash
MegaLotto
  #configure</p>

<pre><code>returns an array with 10 elements (FAILED - 1)
</code></pre>

<p>Failures:</p>

<p>  1) MegaLotto#configure returns an array with 10 elements</p>

<pre><code> Failure/Error: expect(draw.size).to eq(10)

   expected: 10
        got: 6

   (compared using ==)
 # ./spec/mega_lotto_spec.rb:15:in `block (3 levels) in &lt;top (required)&gt;'
</code></pre>

<p>Finished in 0.00168 seconds
1 example, 1 failure
```</p>

<p>We still have the same failures from before, but it’s because we didn’t change the <code>MegaLotto::Drawing</code> to actually <em>use</em> the new configuration class. Since we have this awesome new class, let’s make use of it in <code>MegaLotto::Drawing</code>:</p>

<p>```ruby
module MegaLotto
  class Drawing</p>

<pre><code>def draw
  MegaLotto.configuration.drawing_count.times.map { single_draw }
end

private

def single_draw
  rand(0...60)
end
</code></pre>

<p>  end
end
```</p>

<p>Running the specs for the drawing class gives us the following output:</p>

<p>```bash
MegaLotto::Drawing
  #draw</p>

<pre><code>each element is less than 60 (FAILED - 1)
each element is an integer (FAILED - 2)
returns an array (FAILED - 3)
using the default drawing count
  returns an array with 6 elements (FAILED - 4)
</code></pre>

<p>Failures:</p>

<p>  1) MegaLotto::Drawing#draw each element is less than 60</p>

<pre><code> Failure/Error: let(:draw) { MegaLotto::Drawing.new.draw }
 NoMethodError:
   undefined method `configuration` for MegaLotto:Module
 # ./lib/mega_lotto/drawing.rb:4:in `draw'
 # ./spec/mega_lotto/drawing_spec.rb:6
 # ./spec/mega_lotto/drawing_spec.rb:19
</code></pre>

<p>  2) MegaLotto::Drawing#draw each element is an integer</p>

<pre><code> Failure/Error: let(:draw) { MegaLotto::Drawing.new.draw }
 NoMethodError:
   undefined method `configuration` for MegaLotto:Module
 # ./lib/mega_lotto/drawing.rb:4:in `draw'
 # ./spec/mega_lotto/drawing_spec.rb:6
 # ./spec/mega_lotto/drawing_spec.rb:13
</code></pre>

<p>  3) MegaLotto::Drawing#draw returns an array</p>

<pre><code> Failure/Error: let(:draw) { MegaLotto::Drawing.new.draw }
 NoMethodError:
   undefined method `configuration` for MegaLotto:Module
 # ./lib/mega_lotto/drawing.rb:4:in `draw'
 # ./spec/mega_lotto/drawing_spec.rb:6
 # ./spec/mega_lotto/drawing_spec.rb:9
</code></pre>

<p>  4) MegaLotto::Drawing#draw using the default</p>

<pre><code>  drawing count returns an array with 6 elements
 Failure/Error: let(:draw) { MegaLotto::Drawing.new.draw }
 NoMethodError:
   undefined method `configuration` for MegaLotto:Module
 # ./lib/mega_lotto/drawing.rb:4:in `draw'
 # ./spec/mega_lotto/drawing_spec.rb:6
 # ./spec/mega_lotto/drawing_spec.rb:26
</code></pre>

<p>Finished in 0.00219 seconds
4 examples, 4 failures
```</p>

<p>Well…I guess it’s clear that it doesn’t have a <code>configuration</code> accessor, huh? Let’s add it to <code>lib/mega_lotto.rb</code>:</p>

<p>```ruby
module MegaLotto
  class &lt;&lt; self</p>

<pre><code>attr_accessor :configuration
</code></pre>

<p>  end</p>

<p>  def self.configure
  end
end</p>

<p>```</p>

<p>and our specs:</p>

<p>```bash
MegaLotto::Drawing
  #draw</p>

<pre><code>each element is less than 60 (FAILED - 1)
each element is an integer (FAILED - 2)
returns an array (FAILED - 3)
using the default drawing count
  returns an array with 6 elements (FAILED - 4)
</code></pre>

<p>Failures:</p>

<p>  1) MegaLotto::Drawing#draw each element is less than 60</p>

<pre><code> Failure/Error: let(:draw) { MegaLotto::Drawing.new.draw }
 NoMethodError:
   undefined method `drawing_count` for nil:NilClass
 # ./lib/mega_lotto/drawing.rb:4:in `draw'
 # ./spec/mega_lotto/drawing_spec.rb:6
 # ./spec/mega_lotto/drawing_spec.rb:19
</code></pre>

<p>  2) MegaLotto::Drawing#draw each element is an integer</p>

<pre><code> Failure/Error: let(:draw) { MegaLotto::Drawing.new.draw }
 NoMethodError:
   undefined method `drawing_count` for nil:NilClass
 # ./lib/mega_lotto/drawing.rb:4:in `draw'
 # ./spec/mega_lotto/drawing_spec.rb:6
 # ./spec/mega_lotto/drawing_spec.rb:13
</code></pre>

<p>  3) MegaLotto::Drawing#draw returns an array</p>

<pre><code> Failure/Error: let(:draw) { MegaLotto::Drawing.new.draw }
 NoMethodError:
   undefined method `drawing_count` for nil:NilClass
 # ./lib/mega_lotto/drawing.rb:4:in `draw'
 # ./spec/mega_lotto/drawing_spec.rb:6
 # ./spec/mega_lotto/drawing_spec.rb:9
</code></pre>

<p>  4) MegaLotto::Drawing#draw using the default</p>

<pre><code>  drawing count returns an array with 6 elements
 Failure/Error: let(:draw) { MegaLotto::Drawing.new.draw }
 NoMethodError:
   undefined method `drawing_count` for nil:NilClass
 # ./lib/mega_lotto/drawing.rb:4:in `draw'
 # ./spec/mega_lotto/drawing_spec.rb:6
 # ./spec/mega_lotto/drawing_spec.rb:26
</code></pre>

<p>Finished in 0.00146 seconds
4 examples, 4 failures</p>

<p>```</p>

<p>A different message this time, related to the fact that the configuration accessor has no <code>#drawing_count</code> method. This makes sense because we don’t actually return anything from <code>#configuration</code>. Let’s instantiate a new <code>Configuration</code> object and see where that gets us:</p>

<p>```ruby
module MegaLotto
  class &lt;&lt; self</p>

<pre><code>attr_writer :configuration
</code></pre>

<p>  end</p>

<p>  def self.configuration</p>

<pre><code>Configuration.new
</code></pre>

<p>  end</p>

<p>  def self.configure
  end
end
```</p>

<p>Now, the <code>Drawing</code> class specs are passing:</p>

<p>```bash
MegaLotto::Drawing
  #draw</p>

<pre><code>each element is an integer
each element is less than 60
returns an array
using the default drawing count
  returns an array with 6 elements
</code></pre>

<p>Finished in 0.01007 seconds
4 examples, 0 failures
```</p>

<p>Let’s flip back to the spec file <code>spec/mega_lotto_spec.rb</code> and see where we are:</p>

<p>```bash
MegaLotto
  #configure</p>

<pre><code>returns an array with 10 elements (FAILED - 1)
</code></pre>

<p>Failures:</p>

<p>  1) MegaLotto#configure returns an array with 10 elements</p>

<pre><code> Failure/Error: expect(draw.size).to eq(10)

   expected: 10
        got: 6

   (compared using ==)
 # ./spec/mega_lotto_spec.rb:15
</code></pre>

<p>Finished in 0.00167 seconds
1 example, 1 failure
```</p>

<p>Still failing, but at least we have what seems like the pieces setup to implement the global configuration. The <code>.configure</code> methods needs to yield the configuration block to a new instance of the <code>Configuration</code> class. However, we’ll need to memoize the configuration instance, so when the <code>Drawing</code> class accesses <code>#drawing_count</code>, it returns the initial  configuration value:</p>

<p>```ruby
module MegaLotto
  class &lt;&lt; self</p>

<pre><code>attr_writer :configuration
</code></pre>

<p>  end</p>

<p>  def self.configuration</p>

<pre><code>@configuration ||= Configuration.new
</code></pre>

<p>  end</p>

<p>  def self.configure</p>

<pre><code>yield(configuration)
</code></pre>

<p>  end
end
```</p>

<p><em>Note: it’s important to return the class instance variable from <code>.configuration</code> and check if that is set rather than the reader method, otherwise it’d get stuck in a loop and never return.</em></p>

<p>Running our specs again, we see that we’re green:</p>

<p>```bash
MegaLotto
  #configure</p>

<pre><code>returns an array with 10 elements
</code></pre>

<p>Finished in 0.00168 seconds
1 example, 0 failures
```</p>

<p>For the sake of sanity, let’s run the whole suite to make sure everything is covered:</p>

<p>```bash
$ rake
&hellip;&hellip;.</p>

<p>Finished in 0.00688 seconds
7 examples, 0 failures
```</p>

<p>…and we’re good! Except, if we run our entire suite a few times in a row, we’ll eventually see a failure:</p>

<p>```bash
Failures:</p>

<p>  1) MegaLotto::Drawing#draw returns an Array with 6 elements</p>

<pre><code> Failure/Error: expect(drawing.size).to eq(6)

   expected: 6
        got: 10

   (compared using ==)
 # ./spec/mega_lotto/drawing_spec.rb:13
</code></pre>

<p>Finished in 0.00893 seconds
7 examples, 1 failure
```</p>

<p>What’s going on???</p>

<p>In the setup of the spec for <code>MegaLotto.configure</code>, we added the following before block:</p>

<p>```ruby</p>

<pre><code>before :each do
  MegaLotto.configure do |config|
    config.drawing_count = 10
  end
end
</code></pre>

<p>```</p>

<p>Because this configuration is global, if this spec is run before the others in our suite, the remaining specs will use it. So when the specs for <code>MegaLotto::Drawing</code> run, 10 elements are return instead of the 6, the default, and we see the failure.</p>

<p>For global values like this, it’s best to clean up after each spec to ensure the system is back to a default state. In our case, we can implement a <code>.reset</code> method on <code>MegaLotto</code> and set the configuration back to a new instance of the <code>Configuration</code> class. Let’s start with a spec for this in <code>spec/mega_lotto_spec.rb</code>:</p>

<p>```ruby
  describe &ldquo;.reset&rdquo; do</p>

<pre><code>before :each do
  MegaLotto.configure do |config|
    config.drawing_count = 10
  end
end

it "resets the configuration" do
  MegaLotto.reset

  config = MegaLotto.configuration

  expect(config.drawing_count).to eq(6)
end
</code></pre>

<p>  end
```</p>

<p>As expected, we see failure because we have yet to implement the <code>.reset</code> method:</p>

<p>```bash
Failures:</p>

<p>  1) MegaLotto.reset resets the configuration</p>

<pre><code> Failure/Error: MegaLotto.reset
 NoMethodError:
   undefined method `reset` for MegaLotto:Module
 # ./spec/mega_lotto_spec.rb:28
</code></pre>

<p>Finished in 0.00762 seconds
8 examples, 1 failure
```</p>

<p>Let’s do that now:</p>

<p>```ruby
module MegaLotto
  class &lt;&lt; self</p>

<pre><code>attr_writer :configuration
</code></pre>

<p>  end</p>

<p>  def self.configuration</p>

<pre><code>@configuration ||= Configuration.new
</code></pre>

<p>  end</p>

<p>  def self.reset</p>

<pre><code>@configuration = Configuration.new
</code></pre>

<p>  end</p>

<p>  def self.configure</p>

<pre><code>yield(configuration)
</code></pre>

<p>  end
end
```</p>

<p>Our specs for the <code>.reset</code> method pass, so now we need to make use of it to clean up after our <code>.configure</code> spec:</p>

<p>```ruby
describe &ldquo;#configure&rdquo; do</p>

<p>  before :each do</p>

<pre><code>MegaLotto.configure do |config|
  config.drawing_count = 10
end
</code></pre>

<p>  end</p>

<p>  it &ldquo;returns an array with 10 elements&rdquo; do</p>

<pre><code>draw = MegaLotto::Drawing.new.draw

expect(draw).to be_a(Array)
expect(draw.size).to eq(10)
</code></pre>

<p>  end</p>

<p>  after :each do</p>

<pre><code>MegaLotto.reset
</code></pre>

<p>  end
end
```</p>

<p>Now we can be sure that our specs pass no matter the order of execution.</p>

<h2>Local Configuration</h2>

<p>The configuration approach above implements a global configuration object. The downside is that we can’t have multiple instances of our code running with different configurations. To avoid this, we could isolate the configuration class and only pass it to those objects that need it. By doing this, we’d avoid needing the <code>MegaLotto.configure</code> method entirely.</p>

<p>With this in mind, <code>Drawing</code> might look like:</p>

<p>```ruby
module MegaLotto
  class Drawing</p>

<pre><code>attr_accessor :config

def initialize(config = Configuration.new)
  @config = config
end

def draw
  config.drawing_count.times.map { single_draw }
end

private

def single_draw
  rand(0...60)
end
</code></pre>

<p>  end
end
```</p>

<p>We can supply our own configuration object during instantiation if the defaults aren’t appropriate. In this case, as long as the object responds to <code>drawing_count</code>, everything will work.</p>

<p>```ruby
require &lsquo;ostruct&rsquo;
config = OpenStruct.new(drawing_count: 10)</p>

<p>MegaLotto::Drawing.new(config).draw #=> [23, 4, 21, 33, 48, 12, 43, 13, 2, 5]
```</p>

<p>Both approaches are certainly valid, so I’ll leave it to you to decide which approach is best for your gem.</p>

<h2>Implementations in the Wild</h2>

<p>The <a href="https://github.com/carrierwaveuploader/carrierwave#configuring-carrierwave">CarrierWave gem</a> is a popular choice to support avatar uploading. The author(s) realized that not everyone would want to store upload assets on the local system, so they offered the functionality to support Amazon S3 and other similar block storage services. In order to set this value, you’d use a <a href="https://github.com/carrierwaveuploader/carrierwave#configuring-carrierwave">configure block almost identical to the one we wrote above</a>.</p>

<p>Thoughtbot wrote a <a href="http://robots.thoughtbot.com/mygem-configure-block">great article about the configuration implementation</a> in their <a href="https://github.com/thoughtbot/clearance">Clearance gem</a>. It’s worth reading even if you don’t plan to use Clearance.</p>

<h2>Summary</h2>

<p>Keeping gems configurable means balancing your use case with the use cases of others. The more flexibility you offer to users of your gem, the more users will find value in your work. However, there’s a point when offering too much configuration can make the internals of a gem unnecessarily complicated. As you probably know, Ruby is a language full of conventions and it’s best to provide reasonable defaults and only adapt if the need arises.</p>

<p>One approach to balance complexity is to create a system where users can write their own middleware to modify the behavior of the default system. Mike Perham created a <a href="https://github.com/mperham/sidekiq/wiki/Middleware">middleware system for Sidekiq</a> allowing users to add functionality as they wish. Doing so doesn’t require the gem to change at all when unique use cases arise. The implementation of such system is beyond the scope of this book. However, if you want to learn more, <a href="https://github.com/mperham/sidekiq/blob/master/lib/sidekiq/middleware/chain.rb">Sidekiq’s implementation</a> is a great place to start.</p>
]]></content>
  </entry>
  
</feed>
