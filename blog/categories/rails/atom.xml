<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Brandon Hilkert]]></title>
  <link href="http://brandonhilkert.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://brandonhilkert.com/"/>
  <updated>2015-04-27T16:58:53-04:00</updated>
  <id>http://brandonhilkert.com/</id>
  <author>
    <name><![CDATA[Brandon Hilkert]]></name>
    <email><![CDATA[brandonhilkert@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Adding Functionality to Ruby Classes with Decorators]]></title>
    <link href="http://brandonhilkert.com/blog/adding-functionality-to-ruby-classes-with-decorators/"/>
    <updated>2015-03-09T15:37:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/adding-functionality-to-ruby-classes-with-decorators</id>
    <content type="html"><![CDATA[<p>In my <a href="http://brandonhilkert.com/blog/using-the-sucker-punch-ruby-gem-to-cache-stripe-data-in-rails/">last article</a>, I presented some code that wrapped up accessing a customer&rsquo;s Stripe data and added a caching layer on top. I wanted to take some time to dig in to that code and see how we can make it better.</p>

<p>Decorators give us a tool to add additional functionality to a class while still keeping the public API consistent. From the perspective of the client, this is a win-win! Not only do they get the added behavior, but they don&rsquo;t need to call different methods to do so.</p>

<!--more-->


<h2>The Problem</h2>

<p>Our original class accessed data from Stripe <strong>AND</strong> cached the response for some time period. I accentuated &ldquo;AND&rdquo; because it&rsquo;s generally the word to be on alert for when considering whether functionality can be teased apart in to separate responsibilities.</p>

<p>The question becomes, can we make one class that accesses Stripe data, and another that&rsquo;s only responsible for caching it?</p>

<p>Of course we can!</p>

<h2>The Solution</h2>

<p>Let&rsquo;s start with the most basic form of accessing our Stripe customer data with the <a href="https://github.com/stripe/stripe-ruby">Stripe gem</a>:</p>

<p>```
class AccountsController &lt; ApplicationController
  before_action :require_authentication</p>

<p>  def show</p>

<pre><code>@customer = Stripe::Customer.retrieve(current_user.stripe_id)
@invoices = @customer.invoices
@upcoming_invoice = @customer.upcoming_invoice
</code></pre>

<p>  end
end
```</p>

<h2>Extract an Adapter</h2>

<p>Because we&rsquo;re interfacing with a third-party system (Stripe), it makes sense for to create a local adapter to access the Stripe methods. It&rsquo;s probably not likely we&rsquo;re going to switch out the official Stripe gem for another one that access the same data, but a better argument might be that we could switch billing systems entirely in the future. And if we make a more generic adapter to our third-party billing system, we would only need to update our adapter when that time comes.</p>

<p>While the adapter optimization may seem like overkill here, we&rsquo;ll see how that generic adapter helps us implement our caching layer shortly.</p>

<p>Let&rsquo;s start by removing the notion that it&rsquo;s Stripe and all and call it <code>Billing</code>. Here we can expose the methods needed from the  <code>AccountsController</code> above:</p>

<p>```
class Billing
  attr_reader :billing_id</p>

<p>  def initialize(billing_id)</p>

<pre><code>@billing_id = billing_id
</code></pre>

<p>  end</p>

<p>  def customer</p>

<pre><code>Stripe::Customer.retrieve(billing_id)
</code></pre>

<p>  end</p>

<p>  def invoices</p>

<pre><code>customer.invoices
</code></pre>

<p>  end</p>

<p>  def upcoming_invoice</p>

<pre><code>customer.upcoming_invoice
</code></pre>

<p>  end
end
```</p>

<p>There we have it. A simple <code>Billing</code> class that wraps the methods that we used in the first place &mdash; no change in functionality. But certainly more organized and isolated.</p>

<p>Let&rsquo;s now use this new class in the accounts controller from earlier:</p>

<p>```
class AccountsController &lt; ApplicationController
  before_action :require_authentication</p>

<p>  def show</p>

<pre><code>billing = Billing.new(current_user.stripe_id)

@customer = billing.customer
@invoices = billing.invoices
@upcoming_invoice = billing.upcoming_invoice
</code></pre>

<p>  end
end
```</p>

<p>Not too bad! At this point we&rsquo;ve provide the exact same functionality we had before, but we have a class that sits in the middle between the controller and Stripe gem &ndash; an adapter if you will.</p>

<h2>Create a Decorator</h2>

<p>Now that we have our adapter set up, let&rsquo;s look at how we can add caching behavior to improve the performance of our accounts page.</p>

<p>The most of basic form of a decorator is to pass in the object we&rsquo;re decorating (<code>Billing</code>), and define the same methods of the billing, but add the additional functionality on top of them.</p>

<p>Let&rsquo;s create a base form of  <code>BillingWithCache</code> that <strong>does nothing more</strong> than call the host methods:</p>

<p>```
class BillingWithCache
  def initialize(billing_service)</p>

<pre><code>@billing_service = billing_service
</code></pre>

<p>  end</p>

<p>  def customer</p>

<pre><code>billing_service.customer
</code></pre>

<p>  end</p>

<p>  def invoices</p>

<pre><code>customer.invoices
</code></pre>

<p>  end</p>

<p>  def upcoming_invoice</p>

<pre><code>customer.upcoming_invoice
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  attr_reader :billing_service
end
```</p>

<p>So while we haven&rsquo;t added any additional functionality, we have created the ability for this class to be used in place of our existing <code>Billing</code> class because it responds to the same API (<code>#customer</code>, <code>#invoices</code>, <code>#upcoming_invoice</code>).</p>

<p>Integrating this new class with <code>AccountsController</code> looks like:</p>

<p>```
class AccountsController &lt; ApplicationController
  before_action :require_authentication</p>

<p>  def show</p>

<pre><code>billing = BillingWithCache.new(Billing.new(current_user.stripe_id))

@customer = billing.customer
@invoices = billing.invoices
@upcoming_invoice = billing.upcoming_invoice
</code></pre>

<p>  end
end
```</p>

<p>As you can see, we only had to change one line &mdash; the line where we decorated the original billing class:</p>

<p><code>
BillingWithCache.new(Billing.new(current_user.stripe_id))
</code></p>

<p>I know what you&rsquo;re thinking, &ldquo;But it doesn&rsquo;t actually cache anything!&rdquo;. You&rsquo;re right! Let&rsquo;s dig in to the <code>BillingWithCache</code> class and add that.</p>

<h2>Adding Caching Functionality</h2>

<p>In order to cache data using <code>Rails.cache</code>, we&rsquo;re going to need a cache key of some kind. Fortunately, the original <code>Billing</code> class provides a reader for <code>billing_id</code> that will allow us to make this unique to that user.</p>

<p><code>
def cache_key(item)
  "user/#{billing_id}/billing/#{item}"
end
</code></p>

<p>In this case, <code>item</code> can refer to things like <code>"customer"</code>, <code>"invoices"</code>, or <code>"upcoming_invoice"</code>. This gives us a method we can use internally with <code>BillingWithCache</code> to provide a cache key unique to the both the user and the type of data we&rsquo;re caching.</p>

<p>Adding in the calls to actually cache the data:</p>

<p>```
class BillingWithCache
  def initialize(billing_service)</p>

<pre><code>@billing_service = billing_service
</code></pre>

<p>  end</p>

<p>  def customer</p>

<pre><code>key = cache_key("customer")

Rails.cache.fetch(key, expires: 15.minutes) do
  billing_service.customer
end
</code></pre>

<p>  end</p>

<p>  def invoices</p>

<pre><code>key = cache_key("invoices")

Rails.cache.fetch(key, expires: 15.minutes) do
  customer.invoices
end
</code></pre>

<p>  end</p>

<p>  def upcoming_invoice</p>

<pre><code>key = cache_key("upcoming_invoice")

Rails.cache.fetch(key, expires: 15.minutes) do
  customer.upcoming_invoice
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  attr_reader :billing_service</p>

<p>  def cache_key(item)</p>

<pre><code>"user/#{billing_service.billing_id}/billing/#{item}"
</code></pre>

<p>  end
end
```</p>

<p>The code above caches the call to each of these methods for 15 minutes. We could go further and move that to an argument with a default value, but I&rsquo;ll leave as an exercise for another time.</p>

<h2>Summary</h2>

<p>Separating your application and third-party services helps keeps your applications flexible &mdash; offering the freedom to switch to another service when one no longer fits the bill.</p>

<p>Another benefit of an adapter is you have the freedom to name the class and methods whatever you like. The base gem for a service might not have the best names, or it may be that the names don&rsquo;t make sense when dragged in to your application&rsquo;s domain. This is a small but important point as applications get larger and its code more complex. The more variable/method names you need to think about when you poke around the code, the harder it&rsquo;ll be to remember what was going on. Not to mention the pain new developers will have if they acquire the code. Whether it&rsquo;s you or the next developer, the time you invest in creating great names will be greatly appreciated.</p>

<p>Using decorators in this way makes it easier for clients of the code to avoid change, but keep your applications flexible. The <code>Billing</code> class above was relatively simple &mdash; intentionally so. If the class being decorated has more than a few methods, it might be worth incorporating <code>SimpleDelegator</code> to ensure the methods that don&rsquo;t need additional functionality still continue to respond appropriately.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using the Sucker Punch Ruby Gem to Cache Stripe Data in Rails]]></title>
    <link href="http://brandonhilkert.com/blog/using-the-sucker-punch-ruby-gem-to-cache-stripe-data-in-rails/"/>
    <updated>2015-02-26T20:46:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/using-the-sucker-punch-ruby-gem-to-cache-stripe-data-in-rails</id>
    <content type="html"><![CDATA[<p>With so many services available these days, it&rsquo;s almost impossible to find or build an application that doesn&rsquo;t rely on a third-party service. Most developers that have dealt with billing systems within the past few years have likely heard of <a href="https://stripe.com/">Stripe</a>. Stripe is, by far, the most developer-friendly billing service I&rsquo;ve implemented.</p>

<p>While Stripe does provide a number of features and plugins that make updating a credit card or signing up for a service simple, there are occasions when data needs to be fetched from Stripe in real-time. For these cases, it&rsquo;s great to be able to fetch and cache this data before-hand, and only expire if you know there&rsquo;s been a change.</p>

<!--more-->


<p>Combining <a href="https://github.com/brandonhilkert/sucker_punch">Sucker Punch</a> with Rails cache allows you to cache Stripe customer data so that billing pages are just as snappy as the rest of the application.</p>

<h2>The Pain</h2>

<p>Even though Stripe is generally pretty fast, retrieving customer data on the fly can be expensive. In order to optimize page load times, we can look to cache this data before it&rsquo;s actually used.</p>

<p>If you&rsquo;re familiary with the Stripe gem, you&rsquo;ve probably seen something like this:</p>

<p><code>
customer = Stripe::Customer.retrieve(user.stripe_id)
</code></p>

<p>With the response of <code>customer</code>, we can further query customer data with the following methods:</p>

<p><code>
invoices = customer.invoices
upcoming_invoices = customer.upcoming_invoices
</code></p>

<p>If we make all 3 of these method calls on page load, we&rsquo;d have 3 separate lookups from Stripe. This is pretty common for the typical billing page where you might want to show the customer&rsquo;s current credit card on file, their past invoices, and charges they can expect for the next invoice.</p>

<p>Three lookups like this could potentially add another second or so to page load, which is not ideal.</p>

<p>So how can we improve this?</p>

<h2>The Solution</h2>

<p>First, we can move the code to fetch the relevant stripe data in to a class of it&rsquo;s own, which wraps the notion of caching around the data retrieval.</p>

<p>```
class StripeCache
  def initialize(user)</p>

<pre><code>@user = user
</code></pre>

<p>  end</p>

<p>  def refresh</p>

<pre><code>purge_all
cache_all
self
</code></pre>

<p>  end</p>

<p>  def customer</p>

<pre><code>return @customer if @customer

@customer = Rails.cache.fetch(cache_key("customer"), expires: 15.minutes) do
  Stripe::Customer.retrieve(user.stripe_id)
end
</code></pre>

<p>  end</p>

<p>  def invoices</p>

<pre><code>Rails.cache.fetch(cache_key("invoices"), expires: 15.minutes) do
  customer.invoices
end
</code></pre>

<p>  end</p>

<p>  def upcoming_invoice</p>

<pre><code>Rails.cache.fetch(cache_key("upcoming_invoice"), expires: 15.minutes) do
  customer.upcoming_invoice
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  attr_reader :user</p>

<p>  def cache_all</p>

<pre><code>customer
invoices
upcoming_invoice
</code></pre>

<p>  end</p>

<p>  def purge_all</p>

<pre><code>Rails.cache.delete_matched("#{user.id}/stripe")
</code></pre>

<p>  end</p>

<p>  def cache_key(item)</p>

<pre><code>"user/#{user.id}/stripe/#{item}"
</code></pre>

<p>  end
end
```</p>

<p>To use this on a billing page, we could do:</p>

<p><code>
stripe = StripeCache.new(current_user).refresh
</code></p>

<p>And from the response of that class, we could access the <code>customer</code>, <code>invoices</code>, and <code>upcoming_invoice</code> respectively:</p>

<p><code>
@customer = stripe.customer
@invoices = stripe.invoices
@upcoming_invoice = stripe.invoices
</code></p>

<p>This is great! All future calls to this customer&rsquo;s Stripe data will be fast &mdash; for 15 minutes, of course.</p>

<p>However, the first time the page is load, the user is still burdened with the initial fetch of the data. So the method above works for every request to the billing page after the first.</p>

<p>But let&rsquo;s be honest, what users are going to the billing page multiple times during a session? Probably not many. So we still need to fix the initial load somehow.</p>

<p>This is where <a href="https://github.com/brandonhilkert/sucker_punch">Sucker Punch</a> comes in. Like other Ruby background processing libraries, Sucker Punch allows you to move the processing of code to the background. However, unlike the others, Sucker Punch doesn&rsquo;t require additional infrastructure like Redis, and doesn&rsquo;t require a separate worker process to monitor and execute enqueued jobs. Because of this, the time it takes to extract code to a Sucker Punch job and have it incorporated with your application code is much lower.</p>

<p>In this case, rather than send a transactional email or perform some database calculation, we can write a job thats only responsibility is to run the Stripe caching code.</p>

<p>```
class StripeCacheJob
  include SuckerPunch::Job</p>

<p>  def perform(user)</p>

<pre><code>StripeCache.new(user).refresh
</code></pre>

<p>  end
end
```</p>

<p>The next question is, when do you run this?</p>

<p>Well, I chose to run it on user login, but you could run it anywhere you think would give you a head start if the user were about to go to the billing page. In my case, on login meant that if they didn&rsquo;t go to the billing page at all, after 15 minutes the data would be exhausted from the cache anyway, so no hard done.</p>

<p>But if the user did navigate to the billing page during that session, they would have up the latest Stripe customer and invoice data to see &mdash; all without a request to stripe on page load.</p>

<p>One other thing to keep in mind is there may be times when we&rsquo;d want invalidate the Rails cache data. One example would be when the user&rsquo;s card information is updated. In that case, we can slip in another call to the Stripe cache job, which would invalidate the previous cache and re-request the customer&rsquo;s billing information:</p>

<p>```
module Accounts
  class CardsController &lt; ApplicationController</p>

<pre><code>before_action :require_authentication

def create
  cust = StripeCache.new(current_user).customer
  cust.save(card: params[:stripeToken])

  StripeCacheJob.new.async.perform(current_user)

  redirect_to account_path, notice: t("card.update.success")
end
</code></pre>

<p>  end
end
```</p>

<h2>Summary</h2>

<p>Using Sucker Punch in combination with Rails cache feels like a great way make optimizations to third-party data requests. This article focused on using it to fetch Stripe data, but it could be used with another service just as easily.</p>

<p>The beauty of Sucker Punch is that it doesn&rsquo;t require a separate worker process to be running in the background. On a platform like Heroku, this saves the cost of an additional dyno.</p>

<p>Sucker Punch excels at background jobs that are relatively fast and if missed,
wouldn&rsquo;t be critical to the operation. In this case, if a cache job is lost,
it&rsquo;s not the end of the world. At worst, the user&rsquo;s Stripe data would be requested on the fly and the page would be slower than usual. But the majority of the time, the request is fast because the data&rsquo;s been cached beforehand.</p>

<p>What other jobs have you used Sucker Punch for?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Rails Fixtures To Seed a Database]]></title>
    <link href="http://brandonhilkert.com/blog/using-rails-fixtures-to-seed-a-database/"/>
    <updated>2015-02-04T06:13:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/using-rails-fixtures-to-seed-a-database</id>
    <content type="html"><![CDATA[<p>It’s no mystery that <a href="/blog/7-reasons-why-im-sticking-with-minitest-and-fixtures-in-rails/">I’ve grown to love Rails fixtures</a>. And I tend to mostly use relational databases in my applications, <a href="/blog/rails-gemfile-teardown-2014/">specifically PostgreSQL</a>.</p>

<p>Most applications have ancillary data that’s required to support the main function of the application — think drop-downs with states for shipping or credit card type.</p>

<!--more-->


<p>This data is almost always never interesting, but completely necessary for the application to work as expected. So when it comes to time send your little baby to production, only to find your users can’t pay because they can’t pick their credit card type, your world comes crashing down.</p>

<p>If you have those credit card types in fixtures from the start, loading them in to your development of production database is just a <code>rake</code> task away.</p>

<h2>The Problem</h2>

<p>Let’s assume our application requires us have a list of supported credit card types, and the user is required to pick from the list to pay for the awesome stuff we sell. A sample fixture might look like:</p>

<p>```
visa:
  name: Visa</p>

<p>mastercard:
  name: Mastercard</p>

<p>amex:
  name: American Express
```</p>

<p>This is a somewhat trivial example because the <code>name</code> matches what one might expect in a potential transaction record if we had a <code>credit_card_type</code> field or something similar if we denormalized.</p>

<p>Perhaps we have a field <code>credit_card_type_id</code> in a <code>transactions</code> table that references the foreign key of the related <code>CreditCardType</code> record.</p>

<p>So how do we get these records in to our development and production databases?</p>

<h2>The Solution</h2>

<p>Fortunately, Rails has our backs. The following rake test is available from a default Rails application:</p>

<p><code>
$ bin/rake -T
...
rake db:fixtures:load # Load fixtures into the current environment's database
</code></p>

<p>The <code>db:fixtures:load</code> task is an interesting start, but quickly we realize it might be a little heavy-handed. If this application has users, we probably wouldn&rsquo;t want to copy them to production. They might, however, be a great starting pointing for development.</p>

<p>So how do we handle getting trivial model data in to production for only specific models?</p>

<p>It turns out that we can specify <strong>ONLY</strong> the models we want to load by using the <code>FIXTURES</code> environment variable:</p>

<p><code>
rake db:fixtures:load FIXTURES=credit_card_types
</code></p>

<p><em>Note: The name of the fixture file (usually the database table name) should be used as the value for <code>FIXTURES</code>, not the model name.</em></p>

<p>With that single command, any environment we specify will immediately get the data for our 3 credit card types.</p>

<p>A word of warning, if we run this command multiple times, it will seed the table multiple times. It&rsquo;s not idempotent.</p>

<p>Additionally, if we wanted to load more than just a single fixture, we can specify the names of the files separated by commas:</p>

<p><code>
rake db:fixtures:load FIXTURES=credit_card_types,states,cities
</code></p>

<p>Let&rsquo;s take a quick look at how Rails implements this functionality, specifically the determination of single models:</p>

<p>```
fixtures_dir = if ENV[&lsquo;FIXTURES_DIR&rsquo;]</p>

<pre><code>             File.join base_dir, ENV['FIXTURES_DIR']
           else
             base_dir
           end
</code></pre>

<p>fixture_files = if ENV[&lsquo;FIXTURES&rsquo;]</p>

<pre><code>              ENV['FIXTURES'].split(',')
            else
              # The use of String#[] here is to support namespaced fixtures
              Dir["#{fixtures_dir}/**/*.yml"].map {|f| f[(fixtures_dir.size + 1)..-5] }
            end
</code></pre>

<p>ActiveRecord::FixtureSet.create_fixtures(fixtures_dir, fixture_files)
```</p>

<p>If the <code>FIXTURES</code> variable is present, code teases appart the model names and looks in the fixtures directory and loads the YAML fixture file for that table name.</p>

<p>An interesting side note, it&rsquo;s possible to specify alternate directories for fixture using the <code>FIXTURES_DIR</code> variable. I personally haven taken advantage of this, but could be useful if you want to keep specific fixture files for production that might be different than those that reside in <code>test/fixtures/*</code>.</p>

<p>I wouldn&rsquo;t suggesting using this approach for anything that needs to reference other foreign keys. When you&rsquo;re transferring to a different database, foreign keys will not match and your application will likely not work as expected.</p>

<h2>Summary</h2>

<p>This approach has saved me quite a bit of time in my last few applications. Build it once, use it everywhere. As mentioned above, using this approach to seed database records  with a foreign key should be avoided.</p>

<p>Most applications have a number of tasks needed for a developer to get up and running. Combining fixture data with additional seed data placed in <code>db/seeds.rb</code> can give you the best of both worlds, while still ensuring you have robust data to test against.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Gemfile Teardown - 2014]]></title>
    <link href="http://brandonhilkert.com/blog/rails-gemfile-teardown-2014/"/>
    <updated>2014-12-03T13:14:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/rails-gemfile-teardown-2014</id>
    <content type="html"><![CDATA[<p>What’s the first thing you look at when you see the source code of a Rails project?</p>

<p>For me, it’s the <code>Gemfile</code>. Think about it&hellip;there&rsquo;s very few other files that contain so much information. It describes the building blocks of the application. And at times, you can even see specific features of the application.</p>

<!--more-->


<p>A <code>Gemfile</code> also includes hints about preference and style. And style is something most Ruby developers are very passionate about. It doesn’t take long to find the story of a Rubyist describing their “love at first sight” experience with the language. It’s hard to find another file in a Rails project that’s so telling.</p>

<p>A year ago, I wrote about the <a href="/blog/patterns-in-a-rails-gemfile/">Ruby gems I regularly use in my Rails applications</a>. Because technology and the tools we use change so fast, I thought it’d be interesting to take a look at one of my more recent Gemfiles to see what’s changed.</p>

<h2>Rails Templates</h2>

<p>As I mentioned in the last <a href="/blog/patterns-in-a-rails-gemfile/">Gemfile post</a>, I tend to write a bunch of small applications sprinkled around some larger ones. Despite the size of the project, I feel like I’ve honed in a set of Ruby gems that feel comfortable and productive for me and my workflow.</p>

<p>Knowing the act of bootstrapping a Rails project is sometimes tedious, I took some time to build a <a href="https://github.com/brandonhilkert/rails_templates">Rails template</a> around the gems and patterns I commonly use. I’ll definitely be writing about this experience in the future since there seems to be very little discussion about it.</p>

<p>In short, extracting my preferences to a template has been a HUGE time saver. It no longer feels like a burden to run <code>rails new</code>. I can jump right in and have a consistent set of tools that enable me to be productive within a few minutes.</p>

<h2>My 2014 Gemfile</h2>

<p>The <code>Gemfile</code> below is one of the larger projects I worked on this year. I thought it’d give a good sense of some of my more practical everyday preferences, along with some feature-specific choices for this particular application.</p>

<p>```
source &lsquo;<a href="https://rubygems.org">https://rubygems.org</a>&rsquo;</p>

<p>ruby &lsquo;2.1.4&rsquo;</p>

<p>gem &lsquo;rails&rsquo;, &lsquo;4.1.8&rsquo;
gem &lsquo;pg&rsquo;
gem &lsquo;sass-rails&rsquo;, &lsquo;~> 4.0.3&rsquo;
gem &lsquo;uglifier&rsquo;, &lsquo;>= 1.3.0&rsquo;
gem &lsquo;coffee-rails&rsquo;, &lsquo;~> 4.0.0&rsquo;
gem &lsquo;jquery-rails&rsquo;
gem &lsquo;turbolinks&rsquo;</p>

<p>gem &lsquo;bcrypt-ruby&rsquo;, &lsquo;~> 3.1.2&rsquo;</p>

<p>group :development, :test do
  gem &lsquo;pry&rsquo;
end</p>

<p>group :test do
  gem &lsquo;selenium-webdriver&rsquo;
  gem &lsquo;capybara&rsquo;
  gem &lsquo;timecop&rsquo;
  gem &lsquo;mocha&rsquo;
end</p>

<p>group :development do
  gem &lsquo;quiet_assets&rsquo;
  gem &lsquo;spring&rsquo;
  gem &lsquo;bullet&rsquo;
  gem &lsquo;stripe_tester&rsquo;, &lsquo;~> 0.1.0&rsquo;
end</p>

<p>group :production, :demo do
  gem &lsquo;rails_12factor&rsquo;
  gem &lsquo;heroku-deflater&rsquo;
end</p>

<p>gem &lsquo;font-awesome-rails&rsquo;
gem &lsquo;unicorn&rsquo;
gem &lsquo;bootstrap-sass&rsquo;
gem &lsquo;sidekiq&rsquo;, require: &lsquo;sidekiq/web&rsquo;
gem &lsquo;sinatra&rsquo;
gem &lsquo;local_time&rsquo;
gem &lsquo;gravatar_image_tag&rsquo;
gem &lsquo;so_meta&rsquo;
gem &lsquo;chronic&rsquo;
gem &lsquo;recurrence&rsquo;</p>

<p>gem &lsquo;premailer-rails&rsquo;</p>

<p>gem &lsquo;momentjs-rails&rsquo;
gem &lsquo;bootstrap3-datetimepicker-rails&rsquo;
gem &lsquo;bootstrap-switch-rails&rsquo;
gem &lsquo;bootstrap-wysihtml5-rails&rsquo;
gem &lsquo;bootstrap-select-rails&rsquo;
gem &lsquo;autosize-rails&rsquo;</p>

<p>gem &lsquo;aws-sdk&rsquo;</p>

<p>gem &lsquo;html-pipeline&rsquo;
gem &lsquo;rinku&rsquo;</p>

<p>gem &lsquo;newrelic_rpm&rsquo;
gem &lsquo;doc_raptor&rsquo;
gem &lsquo;stripe&rsquo;
gem &lsquo;jquery-ui-rails&rsquo;
gem &lsquo;active_model_serializers&rsquo;
gem &lsquo;rubyzip&rsquo;
gem &lsquo;render_anywhere&rsquo;, require: false
gem &lsquo;pusher&rsquo;
gem &lsquo;filepicker-rails&rsquo;
gem &lsquo;memcachier&rsquo;
gem &lsquo;dalli&rsquo;
gem &lsquo;intercom-rails&rsquo;
```</p>

<p>A few comments:</p>

<ul>
<li><p>I’ve standardized on <a href="http://www.postgresql.org/">Postgres</a> as the database for my apps, even in development. It’s reliable and allows me to be sure that the code I write will work the same way in production, since I tend to deploy most of my apps to <a href="https://www.heroku.com/">Heroku</a>.</p></li>
<li><p>I leave <code>turbolinks</code> on. Judging from recent posts and comments within the community, this will probably one of the more controversial decisions.</p>

<p>  If I’m being honest, my first experience with Turbolinks wasn’t great. And by “wasn’t great”, I mean — it broke <strong>EVERYTHING</strong>! But the good news was that it brought to light the fact that I sucked at javascript. At the time, I was capable of writing <em>just</em> enough to modify form behavior or fade in an DOM element.</p>

<p>  The time had come to level up on my javascript skills. I was able to improve my javascript and also do it in a way that can took full advantage of the benefits that Turbolinks offers. Since that time, I’ve left Turbolinks on and no longer had to worry that my client-side code will stop working after clicking through a few application links.</p></li>
<li><p>I’ve standardized on using <code>has_secure_password</code> for authentication. I previously used <a href="https://github.com/plataformatec/devise">devise</a>, but found the extra features are no longer worth the additional complexity. <code>has_secure_password</code> provides me reliable authentication patterns that are simple to understand and maintain. Hence the need for <code>bcrypt</code> in the <code>Gemfile</code> above.</p></li>
<li><p>As for my test environment, I’ve written about <a href="/blog/7-reasons-why-im-sticking-with-minitest-and-fixtures-in-rails/">my switch to Minitest and fixtures</a>. I’m still just as happy with that decision as the time I wrote about it. I’ve seen Rspec go through a variety of API changes since then, and thankful I no longer have to worry about updating my test suite every couple months. I continue to find value in <code>capybara</code> and include <code>mocha</code> for the times <code>Minitest</code>’s stubbing and mocking isn’t enough (I’ve been meaning to dig in to the places I use <code>mocha</code>. I’m guessing if the code was better, I probably wouldn’t need it at all).</p></li>
<li><p><code>bullet</code> is a killer gem for tracking down performances issues. It’s saved me countless hours of debugging.</p></li>
<li><p>The inclusion of <code>spring</code> in Rails 4.1 is great. I realize it’s a bandaid in some respects, but waiting for the environment to load on every test run is a drag. I’ve found that because my tests are so responsive when <code>spring</code> is working properly, it encourages me to run my tests more often. Once setup, it works well and only in rare cases has not reloaded when it should have.</p></li>
<li><p>I generally always include <code>bootstrap</code> and <code>font-awesome</code> in my projects. Being a non-designer, it helps me get something on the screen faster, even if it’s not the final design.</p></li>
<li><p>I continue to use <code>unicorn</code>. It’s been around for so long and continues to be competitive in benchmarks against other Ruby web servers. I tested Passenger in a few applications, but got scared off when it printed the entire environment to the screen in production on Heroku on an exception. I’m told there are ways around this with some non-trivial configuration, but I think it’s a bizarre default and isn’t conducive to my workflow.</p></li>
<li><p>For the apps that need background processing, <code>sidekiq</code> continues to be my goto when a separate worker is necessary. I generally mount Sidekiq’s web UI to provide insight to the state of the jobs, which is why <code>sinatra</code> is included.</p></li>
<li><p>I’ve written about putting together <a href="/blog/relative-timestamps-in-rails/">a gem to render relative timestamps</a> on the client side. While I’d love to sit here and tell you I use it, I don’t. Basecamp’s <a href="https://github.com/basecamp/local_time">local_time</a> gem is exceptional for that need and I’m pretty sure we can count on it being updated and maintained well going forward (one of the biggest changes in my mindset for including a new gem).</p></li>
<li><p>This particular app has some pretty hairy time calculations and scheduling. It’s not something I was very experienced with prior, but found value in the combination of <code>chronic</code> and <code>recurrence</code>. Both make the process of targeting a specific <code>datetime</code> and scheduling something in the future relatively simple.</p></li>
<li><p>I included a number of bootstrap related javascript gems (<code>bootstrap3-datetimepicker-rails</code>, <code>bootstrap-switch-rails</code>, <code>bootstrap-switch-rails</code>, <code>bootstrap-select-rails</code>). All are little more than a <a href="/blog/how-to-build-a-rails-engine/">Rails engine</a> that exposes the appropriate javascript and stylesheets to the asset pipeline. These are particularly dependent on the project. I’d normally not start by including anything like this. Side note &ndash; I could’ve copied the relevant assets to <code>vendor/assets</code> rather than requiring a gem that does the same. In a few cases, some added view helpers as well.</p></li>
<li><p>I’ve standardized on using New Relic to collect application metrics and exceptions.</p></li>
<li><p>It shouldn’t be a surprise that <code>stripe</code> is the payment processor I reach for when I’m in control. It’s super developer-friendly and, at this point, I’ve done enough that integration is not much more than a copy/paste from other apps. I recently started using <code>stripe_tester</code> in the test environment. It’s been great for stubbing out calls to Stripe so the test suite continues to be performant. It also allows me to setup some unique edge-case data coming from Stripe so I can protect users from ending up in a crappy state.</p></li>
<li><p>I generally reach for <code>active_model_serializers</code> anytime I need a <code>json</code> response that contains more than a simple hash (in which case I’d continue to render it in the controller response). I’ve used the view equivalent solutions a few times (<code>jbuilder</code>, etc.) and they worked ok too, but for whatever reason, <code>active_model_serializers</code> does it for me.</p></li>
</ul>


<p>The rest are very use case-specific. And in general, the defacto solution for each (<code>pusher</code> for real-time features, <code>dalli</code> for memcached, etc.).</p>

<h2>Summary</h2>

<p>I’m happy with my current toolkit. This doesn’t mean I’m not on the lookout for shiny new things, but I’m generally a little more cautious about replacing something reliable, even if it doesn’t do everything under the sun.</p>

<p>Even though Ruby makes it easy to include third party libraries, it doesn’t mean we always should. As developers, we inherit the stability of the dependencies we include. Even though a gem’s code might be locked away behind a separate git repository, it likely has the same holes and complexities that we’re worried about in our applications. And perhaps, even more…</p>

<p><a href="https://www.ruby-toolbox.com/">Ruby toolbox</a> is a great resource when searching for a gem. I generally consider the number of downloads, age of the project and development activity when deciding which one to go with.</p>

<p>What have your favorite gems been this year?</p>

<h2>Build a Ruby Gem</h2>

<p>Ruby gems are the building blocks of Ruby/Rails applications. If you haven’t built one yourself, there’s no better time to start. Github makes it extremely to contribute to existing gems and sometimes that’s <a href="/blog/3-ways-to-get-started-contributing-to-open-source/">the easiest way to get started contributing to open source</a>. My book, <em>Build a Ruby Gem</em>, includes <a href="/books/build-a-ruby-gem/">everything you to need to get started building a Ruby gem</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Active Record Validation Contexts with Inheritance]]></title>
    <link href="http://brandonhilkert.com/blog/creating-rails-active-record-validation-contexts-with-inheritance/"/>
    <updated>2014-11-18T17:20:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/creating-rails-active-record-validation-contexts-with-inheritance</id>
    <content type="html"><![CDATA[<p>If you’ve used <code>validates</code> in a Rails Active Record model, you know they work great -- at least until the first bit of complexity arises. At that point, they can quickly morph in to a ball of conditional spaghetti convoluting the initial reason the validation was added in the first place.</p>




<p>I recently had an experience using <code>has_secure_password</code> where I wanted control the length of the user-supplied password. Adding a length validation to the password accessor invalidated existing records, so I was in a bit of a bind. In the end, I sub-classed the Active Record model to create a unique model made specifically for that context. This allowed me to inherit the core functionality from the model and sprinkle on existing validations for specific use cases. This was a new tactic for me and I’m still not sure how I feel about it. I like the fact that it removed complexity from the <code>User</code> model. This, in hopes, will keep the minimize the likelihood of it becoming a God object.</p>




<!--more-->




<h2>The Problem</h2>




<p>Using <code>has_secure_password</code> is a relatively easy way to add authentication to a Rails app. In order to disguise the plain text passwords, an <a href="https://github.com/rails/rails/blob/3bdf7b80a11dcb67b18553ff1fe0da82b0cffc20/activemodel/lib/active_model/secure_password.rb#L106">accessor for the plain <code>password</code></a> is added that encrypts it before saving.</p>




<p>The only true Active Record validation <code>has_secure_password</code> adds is a <a href="https://github.com/rails/rails/blob/3bdf7b80a11dcb67b18553ff1fe0da82b0cffc20/activemodel/lib/active_model/secure_password.rb#L68">confirmation of the password</a> — and only when the password is present. This allows us to create a user object without supplying a password, or maybe saving straight to the <code>password_digest</code> field, which is used to store the encrypted password in the database.</p>




<p>I wanted to enforce a minimum password length, because what good is a 1 character password (or 0 for that matter) ?!?!</p>




<p>The first thing I did was add this to the <code>User</code> model:</p>




<pre><code>validates :password, length: { minimum: 8 }
</code></pre>




<p>This works for new users, but not for those with a <code>password_digest</code> already. Attempting to updated an existing user produces the following error:</p>




<pre><code>ActiveRecord::RecordInvalid: Validation failed: Password is too short (minimum is 8 characters)
</code></pre>




<p>The next step was to conditionalize only on create:</p>




<pre><code>validates :password, length: { minimum: 8 }, on: :create
</code></pre>




<p>Except, that wasn’t right either because I’d definitely want to allow users to update their password, in which case, the length validation wouldn’t be enforced.</p>




<p>I found another <a href="http://quickleft.com/blog/rails-tip-validating-users-with-has_secure_password">post suggesting to allow <code>nil</code></a> using:</p>




<pre><code>validates :password, length: { minimum: 8 }, allow_nil: true
</code></pre>




<p>But, again, that felt weird and doesn’t read particularly well when you’re looking through the source trying to understand what condition would generate a <code>nil</code> password.</p>




<p>Other solutions included <a href="http://stackoverflow.com/a/6486345/2261909">mixing conditionals and checking model dirty state</a> and <a href="http://urgetopunt.com/rails/2012/11/12/validate-password-presence-has-secure-password.html">some combination of all of the above</a>.</p>




<p>I’m guessing some combination of the above would’ve worked, but something didn’t feel quite right. A quick glance over any of those solutions left me wanting something cleaner and more approachable. Because it’s a complex and tremendously important part of the app, I wanted to feel comfortable with the solution.</p>




<h2>The Solution</h2>




<p>I recently read <a href="https://leanpub.com/growing-rails"><em>Growing Rails Application in Practice</em></a>. The most interesting takeaway for me was the idea of sub-classing an Active Record object to exactly the problem described above.</p>




<p>Consider this…we have our <code>User</code> model with <code>has_secure_password</code>:</p>




<pre><code>class User &lt; ActiveRecord::Base
  has_secure_password
end
</code></pre>




<p>As we saw above, the variety of validation contexts made the standard ActiveModel validation awkward. What if we sub-class <code>User</code> and add the validation contexts for a specific use case? In our case, minimum length:</p>




<pre><code>class User::AsSignUp &lt; User
  validates :password, length: { minimum: 8 }
end
</code></pre>




<p>In this case, we’re create a separate model, for the purpose of signing up, and perhaps other user-related attribute management (profile, password reset, etc.).</p>




<p>Now, instead of passing the <code>User</code> model to the view from the controller, we pass an instantiated version of the new context-specific model class:</p>




<pre><code>def create
  @user = User::AsSignUp.find(current_user.id)
  …
end
</code></pre>




<p>Lastly, because the sub-class name is inferred within the form, we have to do one more thing to make the params are accessible on the <code>create</code> action using <code>params[:user]</code>. We’ll change the form from:</p>




<pre><code>&lt;%= form_for @user, url: user_confirm_path(@user.invitation_token) do |f| %&gt;
</code></pre>




<p>to:</p>




<pre><code>&lt;%= form_for @user, as: :user, url: user_confirm_path(@user.invitation_token) do |f| %&gt;
</code></pre>




<p>Because the remainder of the app operates fine without any need for the password validation, the <code>User</code> can be used where necessary and without worry of it becoming invalid because the password accessor isn’t present.</p>




<h2>Summary</h2>




<p>While sub-classing models in Rails is generally frowned upon, this use case is one of the few that felt reasonable. It feels relatively low cost and stays in isolation. I’d love to hear how you might have solved this problem. I looked and explored a handful of solutions. While others worked, none seems as expressive as the one above.</p>


<p>A form object using
<a href="http://api.rubyonrails.org/classes/ActiveModel/Model.html">ActiveModel</a> or
similar could&rsquo;ve been an alternative option. I didn&rsquo;t explore it for this
particular use case, mostly because I wanted to give this one a shot. However,
I have no doubt it would&rsquo;ve at least worked equally as well.</p>

<p>I should also point out that I&rsquo;m familiar with the built-in <a href="https://github.com/rails/rails/blob/master/activemodel/lib/active_model/validations.rb#L73">validation
contexts in ActiveModel</a>.
And for whatever reason, I&rsquo;ve not used them before. I&rsquo;ll probably give it a
shot on another occasion for comparison.</p>

<p>What are your thoughts on this technique?</p>
]]></content>
  </entry>
  
</feed>
