<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Brandon Hilkert]]></title>
  <link href="http://brandonhilkert.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://brandonhilkert.com/"/>
  <updated>2015-06-30T21:15:17-04:00</updated>
  <id>http://brandonhilkert.com/</id>
  <author>
    <name><![CDATA[Brandon Hilkert]]></name>
    <email><![CDATA[brandonhilkert@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Organizing Javascript in Rails Application with Turbolinks]]></title>
    <link href="http://brandonhilkert.com/blog/organizing-javascript-in-rails-application-with-turbolinks/"/>
    <updated>2015-06-30T16:10:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/organizing-javascript-in-rails-application-with-turbolinks</id>
    <content type="html"><![CDATA[<p>It&rsquo;s impossible to escape Javascript in a Rails application. From a tiny script to a full-on Javascript framework, websites are becoming more and more reliant on Javascript, whether we like it or not.</p>

<p>Several articles back, I documented <a href="http://brandonhilkert.com/blog/page-specific-javascript-in-rails/">how I handle page-specific Javascript in a Rails application</a>. My solution included a third-party jQuery plugin that did some magic on the <code>$(document).ready</code> function in combination with CSS style scoping to limit the functionality.</p>

<!--more-->


<p>The plugin worked well for awhile, but with the advent of Turbolinks, the
solution felt less and less appropriate. I&rsquo;ve since settled on some techniques
to not only handle page-specific Javascript, but overall organization and structure of Javascript within a Rails application. I&rsquo;ve used it in a hand full of large applications over the past few months and it&rsquo;s held up incredibly well.</p>

<h2>The Problem</h2>

<p>Using &ldquo;sprinkles&rdquo; of Javascript throughout a Rails application can get unwieldly fast if we&rsquo;re not consistent. What we ideally want is some techniques and guidelines that can keep the Javascript organized in our projects. <strong>We also don&rsquo;t want to have to disable Turbolinks to make our application work as we expect</strong>.</p>

<h2>The Solution</h2>

<p>Generally, javascript behavior can be boiled down to the following categories:</p>

<ol>
<li>Behavior that&rsquo;s &ldquo;always on&rdquo;</li>
<li>Behavior that&rsquo;s triggered from a user action</li>
</ol>


<p>But first, a few things to will help us stay organized&hellip;</p>

<h2>Class Scoping</h2>

<p>I still like to scope the body element of the layout(s) with the controller and action name:</p>

<p><code>
&lt;body class="&lt;%= controller_name %&gt; &lt;%= action_name %&gt;"&gt;
  &lt;%= yield %&gt;
&lt;/body&gt;
</code></p>

<p>This not only let&rsquo;s us control access to the DOM through jQuery if we need to, but also provides some top-level styling classes to allow us to easily add page-specific CSS.</p>

<p>In the case we&rsquo;re working on the proverbial blog posts application, the body tag ends up looking like:</p>

<p><code>
&lt;body class="posts index"&gt;
  &lt;%= yield %&gt;
&lt;/body&gt;
</code></p>

<p>This gives us the opportunity to scope CSS and Javascripts to all <code>posts</code>-related pages in the controller with the <code>.posts</code> class, or down to the specific page using a combination of both the controller and action: <code>.posts.index</code>.</p>

<h2>Default Application Manifest</h2>

<p>Here&rsquo;s the default <code>app/assets/javascripts/application.js</code>:</p>

<p><code>
// This is a manifest file that'll be compiled into application.js, which will include all the files
// listed below.
//
// Any JavaScript/Coffee file within this directory, lib/assets/javascripts, vendor/assets/javascripts,
// or any plugin's vendor/assets/javascripts directory can be referenced here using a relative path.
//
// It's not advisable to add code directly here, but if you do, it'll appear at the bottom of the
// compiled file.
//
// Read Sprockets README (https://github.com/rails/sprockets#sprockets-directives) for details
// about supported directives.
//
//= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .
</code></p>

<p>I start by removing the line <code>//= require_tree .</code>. I do this because if you don&rsquo;t, the javascript files in the folder will be loaded in alphabetical order. As you&rsquo;ll see below, there&rsquo;s an initialization file that needs to be loaded before other Javascript. We&rsquo;ll also remove the comments from the top of the file to preserve space.</p>

<p>So we&rsquo;re left with:</p>

<p><code>
//= require jquery
//= require jquery_ujs
//= require turbolinks
</code></p>

<h2>Initialization</h2>

<p>Let&rsquo;s start by adding the file <code>app/assets/javascripts/init.coffee</code> with the following:</p>

<p>```
window.App ||= {}</p>

<p>App.init = &ndash;>
  $(&ldquo;a, span, i, div&rdquo;).tooltip()</p>

<p>$(document).on &ldquo;page:change&rdquo;, &ndash;>
  App.init()
```</p>

<p>Let&rsquo;s dig in to each pagef of this:</p>

<p><code>
window.App ||= {}
</code></p>

<p>We&rsquo;re creating the <code>App</code> object on window so the functionality added to the object is available throughout the application.</p>

<p>Next, we define an <code>init()</code> function on <code>App</code> to initialize common jQuery plugins and other Javascript libraries:</p>

<p><code>
App.init = -&gt;
  $("a, span, i, div").tooltip()
</code></p>

<p>The call to <code>$("a, span, i, div").tooltip()</code> initializes Bootstrap Tooltips. This is an example of the type of libraries that can/should be setup here. Obviously, if you&rsquo;re not using Bootstrap tooltips, you would haven&rsquo;t this here, but coupled with the next line, we&rsquo;ll see why this works.</p>

<p>Lastly, as many have found out the hard way, <strong>when Turbolinks is enabled</strong> in a project, jQuery <code>$(document).ready</code> functions <strong>don&rsquo;t get fired from page to page</strong>. In order to call the <code>init()</code> function on each page transition, we&rsquo;ll hook in to the <code>page:change</code> event:</p>

<p><code>
$(document).on "page:change", -&gt;
  App.init()
</code>
<em>Note: the <code>page:change</code> transition is also triggered on the well known document ready event, so there&rsquo;s no need to add any special handling for first page load.</em></p>

<h2>&ldquo;Always On&rdquo; Javascript Functionality</h2>

<p>Now with the defaults out of the way, let&rsquo;s take a look at adding some behavior.</p>

<p>Let&rsquo;s assume one of our pages will show a Javascript graph of data. We&rsquo;ll start by adding a file with a name related to that responsibility.</p>

<p>```</p>

<h1>app/assets/javascripts/app.chart.coffee</h1>

<p>class App.Chart
  constructor: (@el) &ndash;></p>

<pre><code># intialize some stuff
</code></pre>

<p>  render: &ndash;></p>

<pre><code># do some stuff
</code></pre>

<p>$(document).on &ldquo;page:change&rdquo;, &ndash;>
  chart = new App.Chart $(&ldquo;#chart&rdquo;)
  chart.render()</p>

<p>```</p>

<p>A few things to note here&hellip;</p>

<h3>Structure</h3>

<p>I created a class in the <code>App</code> namespace &mdash; the same we initialized in <code>app/assets/javascripts/init.coffee</code>. This gives us an isolated class that has a clear responsiblity. Like our Ruby, we want to do our best to keep its responsibilities to a minimium.</p>

<p>You might notice the file takes the form:</p>

<p>```
|
|
class definition
|
|</p>

<p>|
invocation
|
```</p>

<p>While this may seem obvious, it&rsquo;s an important point to keep in mind. I&rsquo;ve found it offers a predictable structure that allows me to open any coffeescript file that we&rsquo;ve written in the project and generally know where to look for what.</p>

<h3>Turbolinks-Proof</h3>

<p>We called this &ldquo;Always On&rdquo; functionality because, as you probably noticed, using the following event listener <code>$(document).on "page:change", -&gt;</code>, we know with Turbolinks, this gets triggered on every page transition.</p>

<h3>Add to Manifest</h3>

<p>Because we removed the <code>//= require_tree .</code> line in the default <code>application.js</code> manifest file, we&rsquo;ll have to add our chart file to be included in the asset pipeline (last line):</p>

<p><code>
//= require jquery
//= require jquery_ujs
//= require turbolinks
//= require app.chart
</code></p>

<h3>Page-Specific Javascript</h3>

<p>Uh oh, so maybe we don&rsquo;t want the graph to show up on every page! In this case, we&rsquo;re looking for &ldquo;Always On&rdquo; functionality for specific pages <strong>ONLY</strong>.</p>

<p>We can limit the page pages certain functionality is loaded on by using the classes we added to the body of the layout. In this case, a small conditional to the invocation can prevent this being triggered on pages it shouldn&rsquo;t be.</p>

<p><code>
$(document).on "page:change", -&gt;
  return unless $(".posts.index").length &gt; 0
  f = new App.Chart $("#chart")
  f.render()
</code></p>

<p>We added <code>return unless $(".posts.index").length &gt; 0</code> to make sure <code>App.Chart</code> never gets instantiated if we&rsquo;re on the <code>.posts.index</code> page. While this may seem verbose, I&rsquo;ve found that it&rsquo;s not very common to need page-specific functionality. There are probably plenty of libraries that do something similar, like <a href="http://brandonhilkert.com/blog/page-specific-javascript-in-rails/">the one I previously suggested</a>. <strong>However, to me, limiting javascript to a single page and very explicit when I read the code, it&rsquo;s almost never worth dragging in a separate plugin for this. YMMV.</strong></p>

<h2>User-Triggered Javascript</h2>

<p>This type of Javascript is exactly what you&rsquo;d think &mdash; Javascript invoked as a result of a user clicking or performing some type of action. You&rsquo;re probably thinking, &ldquo;I know how to do this, I&rsquo;ll just add a random file to the javascripts directory and throw in some jQuery&rdquo;. While this will functionally work just fine, I&rsquo;ve found that keeping the structure of these files similar will give you great piece of mind going forward.</p>

<h3>&ldquo;data-behavior&rdquo; Attribute</h3>

<p>Let&rsquo;s assume there&rsquo;s a link in the user&rsquo;s account that allows them to update their credit card. In this case, we have the following:</p>

<p><code>
&lt;%= link_to "Update Credit Card", "#", data: { behavior: "update-credit-card" } %&gt;
</code></p>

<p>You&rsquo;ll probably notice the <code>data-behavior</code> tag being added to the link. This is the key we&rsquo;ll use to attach the Javascript behavior.</p>

<p>We could have added a unique class to the link:</p>

<p><code>
&lt;%= link_to "Update Credit Card", "#", class: "update-credit-card" %&gt;
</code></p>

<p>or, perhaps, even assign an ID:</p>

<p><code>
&lt;%= link_to "Update Credit Card", "#", id: "update-credit-card" %&gt;
</code></p>

<p>Both of these techniques don&rsquo;t really indicate whether we added the <code>update-card-card</code> for the use of CSS styling, or to attach Javascript behavior. So in my applications, I leave classes for <strong>styling ONLY</strong>.</p>

<p>So now to the Javascript:</p>

<p>```
App.Billing =
  update: &ndash;></p>

<pre><code># do some stuff
</code></pre>

<p>$(document).on &ldquo;click&rdquo;, &ldquo;[data-behavior~=update-credit-card]&rdquo;, =>
  App.Billing.update()
```</p>

<p>We can use the selector <code>[data-behavior~=update-credit-card]</code> to latch on to the <code>data-behavior</code> tag we defined in the view. We use the <code>on</code> jQuery method to ensure that we&rsquo;re listening to this event whether the element&rsquo;s on the page or not. This is what allows us to load this Javascript when on other pages and have it still work when a user clicks through to the page with the actual link on it.</p>

<p>We could latch on to the <code>change</code> event, or whatever is appropriate to the element we&rsquo;re adding behavior.</p>

<h3>Add to Manifest</h3>

<p>Again, because Javascripts assets we add to <code>app/assets/javascripts</code> won&rsquo;t automatically be inserted in to the asset pipeline, we&rsquo;ll add <code>//= require app.billing</code> to the manifest file:</p>

<p><code>
//= require jquery
//= require jquery_ujs
//= require turbolinks
//= require app.chart
//= require app.billing
</code></p>

<h2>Summary</h2>

<p>Using the techniques above, we can keep the Javascript in our Rails applications organized and predictable. We can rest easy knowing the files will all generally look the same. There&rsquo;s not been any uses cases where this structure hasn&rsquo;t worked for me personally.</p>

<p>One thing that makes me feel good about this approach is there&rsquo;s no real magic or extra plugins. It&rsquo;s using all the tools we already have in a basic Rails application, which is one less thing to maintain and keep up to date. Less depedencies == less pain down the road.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Start with Ruby?]]></title>
    <link href="http://brandonhilkert.com/blog/how-to-start-with-ruby/"/>
    <updated>2015-05-06T06:03:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/how-to-start-with-ruby</id>
    <content type="html"><![CDATA[<p>In light of RailsConf last month, I spent some time thinking about my experience learning Ruby and Rails back in 2009. The conference included quite a few seasoned veterans, but like any popular technology, there was also plenty of people that either just started learning Rails, or are considering doing so in the near future.</p>

<p>Turning the clocks back to when you knew much less about something is hard. But putting yourself back in that position can offer valuable insight to the opportunities available and how they might be improved in the future.</p>

<!--more-->


<h2>How I Started</h2>

<p>Most come to the Rails community not knowing much about Ruby. Learning any new technology is hard. And learning a few at the same time is even harder.</p>

<p>This was me in 2009. A relatively new Rails 2.3 app was dropped in to my lap, and despite only having experience with PHP, my job was to aggressively ship new features. I read Agile Web Development with Rails cover to cover and dove in head first. Little did I know it would be one of the best career decisions of my life.</p>

<p>I spent the next few months pounding my head against my desk. The days and weeks of frustration seemed endless. And then&hellip;it just went away. The pain I&rsquo;d endured merged in to an intense desire to dig in harder.  There were more light bulbs moments in the months that followed than any other time I can remember.</p>

<p>During those intense months of frustration, I leaned heavily on the Rails and Philly.rb IRC rooms. In the former, I tried not to say anything too stupid. Fortunately, the latter felt more welcoming and approachable and I owe that group a lot of holding my hand through what might have otherwise been a deathwish for me and the Ruby language.</p>

<p>A few questions pop out in my head&hellip;I was confused about filtering an ActiveRecord query and was surprised to learn methods that were built in to the Ruby language would do exactly what I want. At the time, if it wasn&rsquo;t in ActiveRecord, it might as well have not existed to me.</p>

<p>From someone who <a href="http://brandonhilkert.com/blog/7-reasons-why-im-sticking-with-minitest-and-fixtures-in-rails/">advocates for using tools without fancy DSL&rsquo;s</a>, this is hysterical to me. Ruby, of all things, had the answer. At that point, I&rsquo;m almost certain I&rsquo;d never seen the Ruby standard library documentation.</p>

<h2>Rails Starts Where Ruby Stops</h2>

<p>Out of convenience, Rails does a lot to make our experience with the Ruby language easier than it is out of the box. Like <code>2.hours.ago</code>&hellip;.none of this is possible if Rails doesn&rsquo;t <a href="http://api.rubyonrails.org/classes/Integer.html">monkey patch the <code>Integer</code> class</a>. For someone who doesn&rsquo;t know any better (me in 2009!), being able to calls <code>#hours</code> on an integer just seems like something the language would do. Because Ruby was created for developer happiness, right?</p>

<p>So perhaps the approach of monkey patching doesn&rsquo;t offer a clear indication of where functionality is coming from. The flip side of that argument is convenience. If I had to instantiate a time-related class every time I wanted &ldquo;noon time yesterday&rdquo;, maybe I&rsquo;d be slightly less enthralled with my ability to get stuff done in Rails. Perhaps it would cater more to the true OO neckbeards, but also may have resulted in far less adoption. Who knows!</p>

<p>I don&rsquo;t have strong numbers to back this up, but I&rsquo;m guessing large majority of developers that get paid to write Ruby, due so within the context of a Rails application. And whether we want to admit it or not, a large reason new developers learn Ruby, is to learn Rails. So does it matter that newcomers don&rsquo;t know Ruby?</p>

<p>From the standpoint of creating a web application fast and being able to iterate quickly, maybe not. But certainly if the person is interested in understanding the interworkings of what&rsquo;s happening within the application, knowing where Ruby stops and Rails starts is ideal.</p>

<h2>How to Start?</h2>

<p>I&rsquo;ve talked to quite a few people that are new to Ruby and I always struggle to suggest a good start project when they ask.  Everyone learns differently and has different interests, but in general, I think there are core-level motivating factors that can keep someone focused and interested.</p>

<p>To me, it&rsquo;s the following:</p>

<ol>
<li>Does the project have real-world value?</li>
<li>Does the project offer immediate feedback?</li>
</ol>


<p>Why does it matter if the project has real-world value? For one, continuing on something that doesn&rsquo;t improve our lives is sometimes hard to keep up with. And learning Ruby/Rails is definitely something that&rsquo;ll take more than a few nights and weekends. If the project we&rsquo;re driving towards continues to seem desirable, we&rsquo;ll have a better chance not to lose focus.</p>

<p>Second, I don&rsquo;t want to get too philosophical, but there are plenty of resources that suggest if you want something badly enough and can visualize the end goal, there&rsquo;s a higher likelyhood that it&rsquo;ll come to be. Our desires will be stronger when we can see the end goal and know there is an increased real-world value for this application to be in existence.</p>

<p>The immediate feedback piece shortens the time we&rsquo;re able to see changes and progress. This brings a lower rate of abandonment and better chance we&rsquo;ll see the project through.</p>

<p>Rails answers both of these questions with a resounding, &ldquo;<strong>YES!</strong>&rdquo;. Think about it&hellip;</p>

<p><strong>Does a Rails application have real world value?</strong> Of course it does. It&rsquo;s a web application. There has been no better time to be focused on Rails, where it be for the web and the backend of a mobile app.</p>

<p><strong>Does the project offer immediate feedback?</strong> Sure does! A couple keystrokes and a refresh can give you instant gratifcation in the browser (or the occasional disappointment!).</p>

<p>Whether it&rsquo;s a command-line tool, game, or other utility, I struggle to find other oppotunities to get people started. Frankly, many newcomers to Rails have never used a terminal before. So why would we suggest a command-line application as a good place to start? This is especially true for someone with little programming experience.</p>

<p>For the experienced developer, it&rsquo;d be much easier to suggest writing something like a markdown processor, but only because they have the context of another language. At that point, they&rsquo;re really just comparing the Ruby language to what they already know and figuring out how to translate the things they <em>do</em> know to Ruby.</p>

<p>For a new developer altogether, they would get little value of writing a markdown processor, and in fact, probably seems more like a research project than a sure-fire way to learn a developer-friendly programming language.</p>

<p>So now we&rsquo;re back to suggesting Rails, but then you consider everything else a newcomer would need familiarity with to traverse the Rails eco-stytem: HTML, CSS, Javascript, Coffeescript, Sass, SQL&hellip;</p>

<p>The list goes on and on. Not so easy after all. No wonder people get intimidated and bail. I suppose there&rsquo;s starting with Sinatra, but the doesn&rsquo;t remove you from the HTML and CSS requirements. Perhaps those impossible to dodge, given the medium. And even with Sinatra, we often end up creating the functionality that&rsquo;s in Rails anyway.</p>

<p>I wish I had a better answer.</p>

<p><strong>How would you suggest someone start with Ruby?</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Adding Functionality to Ruby Classes with Decorators]]></title>
    <link href="http://brandonhilkert.com/blog/adding-functionality-to-ruby-classes-with-decorators/"/>
    <updated>2015-03-09T15:37:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/adding-functionality-to-ruby-classes-with-decorators</id>
    <content type="html"><![CDATA[<p>In my <a href="http://brandonhilkert.com/blog/using-the-sucker-punch-ruby-gem-to-cache-stripe-data-in-rails/">last article</a>, I presented some code that wrapped up accessing a customer&rsquo;s Stripe data and added a caching layer on top. I wanted to take some time to dig in to that code and see how we can make it better.</p>

<p>Decorators give us a tool to add additional functionality to a class while still keeping the public API consistent. From the perspective of the client, this is a win-win! Not only do they get the added behavior, but they don&rsquo;t need to call different methods to do so.</p>

<!--more-->


<h2>The Problem</h2>

<p>Our original class accessed data from Stripe <strong>AND</strong> cached the response for some time period. I accentuated &ldquo;AND&rdquo; because it&rsquo;s generally the word to be on alert for when considering whether functionality can be teased apart in to separate responsibilities.</p>

<p>The question becomes, can we make one class that accesses Stripe data, and another that&rsquo;s only responsible for caching it?</p>

<p>Of course we can!</p>

<h2>The Solution</h2>

<p>Let&rsquo;s start with the most basic form of accessing our Stripe customer data with the <a href="https://github.com/stripe/stripe-ruby">Stripe gem</a>:</p>

<p>```
class AccountsController &lt; ApplicationController
  before_action :require_authentication</p>

<p>  def show</p>

<pre><code>@customer = Stripe::Customer.retrieve(current_user.stripe_id)
@invoices = @customer.invoices
@upcoming_invoice = @customer.upcoming_invoice
</code></pre>

<p>  end
end
```</p>

<h2>Extract an Adapter</h2>

<p>Because we&rsquo;re interfacing with a third-party system (Stripe), it makes sense for to create a local adapter to access the Stripe methods. It&rsquo;s probably not likely we&rsquo;re going to switch out the official Stripe gem for another one that access the same data, but a better argument might be that we could switch billing systems entirely in the future. And if we make a more generic adapter to our third-party billing system, we would only need to update our adapter when that time comes.</p>

<p>While the adapter optimization may seem like overkill here, we&rsquo;ll see how that generic adapter helps us implement our caching layer shortly.</p>

<p>Let&rsquo;s start by removing the notion that it&rsquo;s Stripe and all and call it <code>Billing</code>. Here we can expose the methods needed from the  <code>AccountsController</code> above:</p>

<p>```
class Billing
  attr_reader :billing_id</p>

<p>  def initialize(billing_id)</p>

<pre><code>@billing_id = billing_id
</code></pre>

<p>  end</p>

<p>  def customer</p>

<pre><code>Stripe::Customer.retrieve(billing_id)
</code></pre>

<p>  end</p>

<p>  def invoices</p>

<pre><code>customer.invoices
</code></pre>

<p>  end</p>

<p>  def upcoming_invoice</p>

<pre><code>customer.upcoming_invoice
</code></pre>

<p>  end
end
```</p>

<p>There we have it. A simple <code>Billing</code> class that wraps the methods that we used in the first place &mdash; no change in functionality. But certainly more organized and isolated.</p>

<p>Let&rsquo;s now use this new class in the accounts controller from earlier:</p>

<p>```
class AccountsController &lt; ApplicationController
  before_action :require_authentication</p>

<p>  def show</p>

<pre><code>billing = Billing.new(current_user.stripe_id)

@customer = billing.customer
@invoices = billing.invoices
@upcoming_invoice = billing.upcoming_invoice
</code></pre>

<p>  end
end
```</p>

<p>Not too bad! At this point we&rsquo;ve provide the exact same functionality we had before, but we have a class that sits in the middle between the controller and Stripe gem &ndash; an adapter if you will.</p>

<h2>Create a Decorator</h2>

<p>Now that we have our adapter set up, let&rsquo;s look at how we can add caching behavior to improve the performance of our accounts page.</p>

<p>The most of basic form of a decorator is to pass in the object we&rsquo;re decorating (<code>Billing</code>), and define the same methods of the billing, but add the additional functionality on top of them.</p>

<p>Let&rsquo;s create a base form of  <code>BillingWithCache</code> that <strong>does nothing more</strong> than call the host methods:</p>

<p>```
class BillingWithCache
  def initialize(billing_service)</p>

<pre><code>@billing_service = billing_service
</code></pre>

<p>  end</p>

<p>  def customer</p>

<pre><code>billing_service.customer
</code></pre>

<p>  end</p>

<p>  def invoices</p>

<pre><code>customer.invoices
</code></pre>

<p>  end</p>

<p>  def upcoming_invoice</p>

<pre><code>customer.upcoming_invoice
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  attr_reader :billing_service
end
```</p>

<p>So while we haven&rsquo;t added any additional functionality, we have created the ability for this class to be used in place of our existing <code>Billing</code> class because it responds to the same API (<code>#customer</code>, <code>#invoices</code>, <code>#upcoming_invoice</code>).</p>

<p>Integrating this new class with <code>AccountsController</code> looks like:</p>

<p>```
class AccountsController &lt; ApplicationController
  before_action :require_authentication</p>

<p>  def show</p>

<pre><code>billing = BillingWithCache.new(Billing.new(current_user.stripe_id))

@customer = billing.customer
@invoices = billing.invoices
@upcoming_invoice = billing.upcoming_invoice
</code></pre>

<p>  end
end
```</p>

<p>As you can see, we only had to change one line &mdash; the line where we decorated the original billing class:</p>

<p><code>
BillingWithCache.new(Billing.new(current_user.stripe_id))
</code></p>

<p>I know what you&rsquo;re thinking, &ldquo;But it doesn&rsquo;t actually cache anything!&rdquo;. You&rsquo;re right! Let&rsquo;s dig in to the <code>BillingWithCache</code> class and add that.</p>

<h2>Adding Caching Functionality</h2>

<p>In order to cache data using <code>Rails.cache</code>, we&rsquo;re going to need a cache key of some kind. Fortunately, the original <code>Billing</code> class provides a reader for <code>billing_id</code> that will allow us to make this unique to that user.</p>

<p><code>
def cache_key(item)
  "user/#{billing_id}/billing/#{item}"
end
</code></p>

<p>In this case, <code>item</code> can refer to things like <code>"customer"</code>, <code>"invoices"</code>, or <code>"upcoming_invoice"</code>. This gives us a method we can use internally with <code>BillingWithCache</code> to provide a cache key unique to the both the user and the type of data we&rsquo;re caching.</p>

<p>Adding in the calls to actually cache the data:</p>

<p>```
class BillingWithCache
  def initialize(billing_service)</p>

<pre><code>@billing_service = billing_service
</code></pre>

<p>  end</p>

<p>  def customer</p>

<pre><code>key = cache_key("customer")

Rails.cache.fetch(key, expires: 15.minutes) do
  billing_service.customer
end
</code></pre>

<p>  end</p>

<p>  def invoices</p>

<pre><code>key = cache_key("invoices")

Rails.cache.fetch(key, expires: 15.minutes) do
  customer.invoices
end
</code></pre>

<p>  end</p>

<p>  def upcoming_invoice</p>

<pre><code>key = cache_key("upcoming_invoice")

Rails.cache.fetch(key, expires: 15.minutes) do
  customer.upcoming_invoice
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  attr_reader :billing_service</p>

<p>  def cache_key(item)</p>

<pre><code>"user/#{billing_service.billing_id}/billing/#{item}"
</code></pre>

<p>  end
end
```</p>

<p>The code above caches the call to each of these methods for 15 minutes. We could go further and move that to an argument with a default value, but I&rsquo;ll leave as an exercise for another time.</p>

<h2>Summary</h2>

<p>Separating your application and third-party services helps keeps your applications flexible &mdash; offering the freedom to switch to another service when one no longer fits the bill.</p>

<p>Another benefit of an adapter is you have the freedom to name the class and methods whatever you like. The base gem for a service might not have the best names, or it may be that the names don&rsquo;t make sense when dragged in to your application&rsquo;s domain. This is a small but important point as applications get larger and its code more complex. The more variable/method names you need to think about when you poke around the code, the harder it&rsquo;ll be to remember what was going on. Not to mention the pain new developers will have if they acquire the code. Whether it&rsquo;s you or the next developer, the time you invest in creating great names will be greatly appreciated.</p>

<p>Using decorators in this way makes it easier for clients of the code to avoid change, but keep your applications flexible. The <code>Billing</code> class above was relatively simple &mdash; intentionally so. If the class being decorated has more than a few methods, it might be worth incorporating <code>SimpleDelegator</code> to ensure the methods that don&rsquo;t need additional functionality still continue to respond appropriately.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using the Sucker Punch Ruby Gem to Cache Stripe Data in Rails]]></title>
    <link href="http://brandonhilkert.com/blog/using-the-sucker-punch-ruby-gem-to-cache-stripe-data-in-rails/"/>
    <updated>2015-02-26T20:46:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/using-the-sucker-punch-ruby-gem-to-cache-stripe-data-in-rails</id>
    <content type="html"><![CDATA[<p>With so many services available these days, it&rsquo;s almost impossible to find or build an application that doesn&rsquo;t rely on a third-party service. Most developers that have dealt with billing systems within the past few years have likely heard of <a href="https://stripe.com/">Stripe</a>. Stripe is, by far, the most developer-friendly billing service I&rsquo;ve implemented.</p>

<p>While Stripe does provide a number of features and plugins that make updating a credit card or signing up for a service simple, there are occasions when data needs to be fetched from Stripe in real-time. For these cases, it&rsquo;s great to be able to fetch and cache this data before-hand, and only expire if you know there&rsquo;s been a change.</p>

<!--more-->


<p>Combining <a href="https://github.com/brandonhilkert/sucker_punch">Sucker Punch</a> with Rails cache allows you to cache Stripe customer data so that billing pages are just as snappy as the rest of the application.</p>

<h2>The Pain</h2>

<p>Even though Stripe is generally pretty fast, retrieving customer data on the fly can be expensive. In order to optimize page load times, we can look to cache this data before it&rsquo;s actually used.</p>

<p>If you&rsquo;re familiary with the Stripe gem, you&rsquo;ve probably seen something like this:</p>

<p><code>
customer = Stripe::Customer.retrieve(user.stripe_id)
</code></p>

<p>With the response of <code>customer</code>, we can further query customer data with the following methods:</p>

<p><code>
invoices = customer.invoices
upcoming_invoices = customer.upcoming_invoices
</code></p>

<p>If we make all 3 of these method calls on page load, we&rsquo;d have 3 separate lookups from Stripe. This is pretty common for the typical billing page where you might want to show the customer&rsquo;s current credit card on file, their past invoices, and charges they can expect for the next invoice.</p>

<p>Three lookups like this could potentially add another second or so to page load, which is not ideal.</p>

<p>So how can we improve this?</p>

<h2>The Solution</h2>

<p>First, we can move the code to fetch the relevant stripe data in to a class of it&rsquo;s own, which wraps the notion of caching around the data retrieval.</p>

<p>```
class StripeCache
  def initialize(user)</p>

<pre><code>@user = user
</code></pre>

<p>  end</p>

<p>  def refresh</p>

<pre><code>purge_all
cache_all
self
</code></pre>

<p>  end</p>

<p>  def customer</p>

<pre><code>return @customer if @customer

@customer = Rails.cache.fetch(cache_key("customer"), expires: 15.minutes) do
  Stripe::Customer.retrieve(user.stripe_id)
end
</code></pre>

<p>  end</p>

<p>  def invoices</p>

<pre><code>Rails.cache.fetch(cache_key("invoices"), expires: 15.minutes) do
  customer.invoices
end
</code></pre>

<p>  end</p>

<p>  def upcoming_invoice</p>

<pre><code>Rails.cache.fetch(cache_key("upcoming_invoice"), expires: 15.minutes) do
  customer.upcoming_invoice
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  attr_reader :user</p>

<p>  def cache_all</p>

<pre><code>customer
invoices
upcoming_invoice
</code></pre>

<p>  end</p>

<p>  def purge_all</p>

<pre><code>Rails.cache.delete_matched("#{user.id}/stripe")
</code></pre>

<p>  end</p>

<p>  def cache_key(item)</p>

<pre><code>"user/#{user.id}/stripe/#{item}"
</code></pre>

<p>  end
end
```</p>

<p>To use this on a billing page, we could do:</p>

<p><code>
stripe = StripeCache.new(current_user).refresh
</code></p>

<p>And from the response of that class, we could access the <code>customer</code>, <code>invoices</code>, and <code>upcoming_invoice</code> respectively:</p>

<p><code>
@customer = stripe.customer
@invoices = stripe.invoices
@upcoming_invoice = stripe.invoices
</code></p>

<p>This is great! All future calls to this customer&rsquo;s Stripe data will be fast &mdash; for 15 minutes, of course.</p>

<p>However, the first time the page is load, the user is still burdened with the initial fetch of the data. So the method above works for every request to the billing page after the first.</p>

<p>But let&rsquo;s be honest, what users are going to the billing page multiple times during a session? Probably not many. So we still need to fix the initial load somehow.</p>

<p>This is where <a href="https://github.com/brandonhilkert/sucker_punch">Sucker Punch</a> comes in. Like other Ruby background processing libraries, Sucker Punch allows you to move the processing of code to the background. However, unlike the others, Sucker Punch doesn&rsquo;t require additional infrastructure like Redis, and doesn&rsquo;t require a separate worker process to monitor and execute enqueued jobs. Because of this, the time it takes to extract code to a Sucker Punch job and have it incorporated with your application code is much lower.</p>

<p>In this case, rather than send a transactional email or perform some database calculation, we can write a job thats only responsibility is to run the Stripe caching code.</p>

<p>```
class StripeCacheJob
  include SuckerPunch::Job</p>

<p>  def perform(user)</p>

<pre><code>StripeCache.new(user).refresh
</code></pre>

<p>  end
end
```</p>

<p>The next question is, when do you run this?</p>

<p>Well, I chose to run it on user login, but you could run it anywhere you think would give you a head start if the user were about to go to the billing page. In my case, on login meant that if they didn&rsquo;t go to the billing page at all, after 15 minutes the data would be exhausted from the cache anyway, so no hard done.</p>

<p>But if the user did navigate to the billing page during that session, they would have up the latest Stripe customer and invoice data to see &mdash; all without a request to stripe on page load.</p>

<p>One other thing to keep in mind is there may be times when we&rsquo;d want invalidate the Rails cache data. One example would be when the user&rsquo;s card information is updated. In that case, we can slip in another call to the Stripe cache job, which would invalidate the previous cache and re-request the customer&rsquo;s billing information:</p>

<p>```
module Accounts
  class CardsController &lt; ApplicationController</p>

<pre><code>before_action :require_authentication

def create
  cust = StripeCache.new(current_user).customer
  cust.save(card: params[:stripeToken])

  StripeCacheJob.new.async.perform(current_user)

  redirect_to account_path, notice: t("card.update.success")
end
</code></pre>

<p>  end
end
```</p>

<h2>Summary</h2>

<p>Using Sucker Punch in combination with Rails cache feels like a great way make optimizations to third-party data requests. This article focused on using it to fetch Stripe data, but it could be used with another service just as easily.</p>

<p>The beauty of Sucker Punch is that it doesn&rsquo;t require a separate worker process to be running in the background. On a platform like Heroku, this saves the cost of an additional dyno.</p>

<p>Sucker Punch excels at background jobs that are relatively fast and if missed,
wouldn&rsquo;t be critical to the operation. In this case, if a cache job is lost,
it&rsquo;s not the end of the world. At worst, the user&rsquo;s Stripe data would be requested on the fly and the page would be slower than usual. But the majority of the time, the request is fast because the data&rsquo;s been cached beforehand.</p>

<p>What other jobs have you used Sucker Punch for?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Rails Fixtures To Seed a Database]]></title>
    <link href="http://brandonhilkert.com/blog/using-rails-fixtures-to-seed-a-database/"/>
    <updated>2015-02-04T06:13:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/using-rails-fixtures-to-seed-a-database</id>
    <content type="html"><![CDATA[<p>It’s no mystery that <a href="/blog/7-reasons-why-im-sticking-with-minitest-and-fixtures-in-rails/">I’ve grown to love Rails fixtures</a>. And I tend to mostly use relational databases in my applications, <a href="/blog/rails-gemfile-teardown-2014/">specifically PostgreSQL</a>.</p>

<p>Most applications have ancillary data that’s required to support the main function of the application — think drop-downs with states for shipping or credit card type.</p>

<!--more-->


<p>This data is almost always never interesting, but completely necessary for the application to work as expected. So when it comes to time send your little baby to production, only to find your users can’t pay because they can’t pick their credit card type, your world comes crashing down.</p>

<p>If you have those credit card types in fixtures from the start, loading them in to your development of production database is just a <code>rake</code> task away.</p>

<h2>The Problem</h2>

<p>Let’s assume our application requires us have a list of supported credit card types, and the user is required to pick from the list to pay for the awesome stuff we sell. A sample fixture might look like:</p>

<p>```
visa:
  name: Visa</p>

<p>mastercard:
  name: Mastercard</p>

<p>amex:
  name: American Express
```</p>

<p>This is a somewhat trivial example because the <code>name</code> matches what one might expect in a potential transaction record if we had a <code>credit_card_type</code> field or something similar if we denormalized.</p>

<p>Perhaps we have a field <code>credit_card_type_id</code> in a <code>transactions</code> table that references the foreign key of the related <code>CreditCardType</code> record.</p>

<p>So how do we get these records in to our development and production databases?</p>

<h2>The Solution</h2>

<p>Fortunately, Rails has our backs. The following rake test is available from a default Rails application:</p>

<p><code>
$ bin/rake -T
...
rake db:fixtures:load # Load fixtures into the current environment's database
</code></p>

<p>The <code>db:fixtures:load</code> task is an interesting start, but quickly we realize it might be a little heavy-handed. If this application has users, we probably wouldn&rsquo;t want to copy them to production. They might, however, be a great starting pointing for development.</p>

<p>So how do we handle getting trivial model data in to production for only specific models?</p>

<p>It turns out that we can specify <strong>ONLY</strong> the models we want to load by using the <code>FIXTURES</code> environment variable:</p>

<p><code>
rake db:fixtures:load FIXTURES=credit_card_types
</code></p>

<p><em>Note: The name of the fixture file (usually the database table name) should be used as the value for <code>FIXTURES</code>, not the model name.</em></p>

<p>With that single command, any environment we specify will immediately get the data for our 3 credit card types.</p>

<p>A word of warning, if we run this command multiple times, it will seed the table multiple times. It&rsquo;s not idempotent.</p>

<p>Additionally, if we wanted to load more than just a single fixture, we can specify the names of the files separated by commas:</p>

<p><code>
rake db:fixtures:load FIXTURES=credit_card_types,states,cities
</code></p>

<p>Let&rsquo;s take a quick look at how Rails implements this functionality, specifically the determination of single models:</p>

<p>```
fixtures_dir = if ENV[&lsquo;FIXTURES_DIR&rsquo;]</p>

<pre><code>             File.join base_dir, ENV['FIXTURES_DIR']
           else
             base_dir
           end
</code></pre>

<p>fixture_files = if ENV[&lsquo;FIXTURES&rsquo;]</p>

<pre><code>              ENV['FIXTURES'].split(',')
            else
              # The use of String#[] here is to support namespaced fixtures
              Dir["#{fixtures_dir}/**/*.yml"].map {|f| f[(fixtures_dir.size + 1)..-5] }
            end
</code></pre>

<p>ActiveRecord::FixtureSet.create_fixtures(fixtures_dir, fixture_files)
```</p>

<p>If the <code>FIXTURES</code> variable is present, code teases appart the model names and looks in the fixtures directory and loads the YAML fixture file for that table name.</p>

<p>An interesting side note, it&rsquo;s possible to specify alternate directories for fixture using the <code>FIXTURES_DIR</code> variable. I personally haven taken advantage of this, but could be useful if you want to keep specific fixture files for production that might be different than those that reside in <code>test/fixtures/*</code>.</p>

<p>I wouldn&rsquo;t suggesting using this approach for anything that needs to reference other foreign keys. When you&rsquo;re transferring to a different database, foreign keys will not match and your application will likely not work as expected.</p>

<h2>Summary</h2>

<p>This approach has saved me quite a bit of time in my last few applications. Build it once, use it everywhere. As mentioned above, using this approach to seed database records  with a foreign key should be avoided.</p>

<p>Most applications have a number of tasks needed for a developer to get up and running. Combining fixture data with additional seed data placed in <code>db/seeds.rb</code> can give you the best of both worlds, while still ensuring you have robust data to test against.</p>
]]></content>
  </entry>
  
</feed>
