<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Brandon Hilkert]]></title>
  <link href="http://brandonhilkert.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://brandonhilkert.com/"/>
  <updated>2014-12-19T21:33:45-05:00</updated>
  <id>http://brandonhilkert.com/</id>
  <author>
    <name><![CDATA[Brandon Hilkert]]></name>
    <email><![CDATA[brandonhilkert@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A Ruby Refactor: Exploring Dependency Injection Options]]></title>
    <link href="http://brandonhilkert.com/blog/a-ruby-refactor-exploring-dependency-injection-options/"/>
    <updated>2014-12-17T07:07:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/a-ruby-refactor-exploring-dependency-injection-options</id>
    <content type="html"><![CDATA[<p>I recently wrote some code to interface with Stripe’s webhooks. After looking at the code and tests, I decided I needed to do something to make it easier to test <em>all</em> pricing tiers— something I wasn’t able to easily do from the start.</p>

<p><a href="http://en.m.wikipedia.org/wiki/Dependency_injection">Dependency injection</a> was a necessary piece of that puzzle. I’ve always been curious about the various forms of dependency injection and the effects each would have on the code. Below I explore 2 options (constructor injection and setter injection).</p>

<!--more-->


<p>In the end, setter injection felt for more natural for this case and it didn’t interfere with the classes argument list and felt ancillary to the responsibility of the code. While the change in code was small, it has a huge impact on my confidence in the code and associated tests.</p>

<h2>The Code</h2>

<p>The class below is responsible for handling Stripe’s <code>invoice.created</code> webhook. Prior to a customer being billed monthly subscription, Stripe will ping your application (if configured) — giving you the opportunity to add additional line items (think metered billing…). It could be additional services, or perhaps the entire bill itself (this use case). Nevertheless, the responsibility of the class is to create an invoice item based on the customer’s usage during the previous period.</p>

<p>```
module StripeEvent
  class InvoiceCreated</p>

<pre><code>attr_reader :payload

def initialize(payload)
  @payload = payload
end

def perform
  Stripe::InvoiceItem.create(
    customer: user.stripe_id,
    amount: additional_charges_in_cents,
    currency: "usd",
    description: "Usage charges"
  )
end

private

def additional_charges_in_cents
  Billing::Tier.new(usage).additional_charges_in_cents
end

def usage
  Billing::Usage.new(user).last_30_days
end

def user
  @user ||= User.find_by(stripe_id: payload["data"]["object"]["customer"])
end
</code></pre>

<p>  end
end
```</p>

<p>I wrote this code pretty quickly and felt pretty good about it. The responsibility of determining the pricing tier had been broken out in to a separate class, as well as determining the customer’s actual usage. At least I thought they were…</p>

<p>So what about the tests?</p>

<p>```
require &lsquo;test_helper&rsquo;</p>

<p>class InvoiceCreatedTest &lt; ActiveSupport::TestCase
  def setup</p>

<pre><code>@payload = {
  "data" =&gt; {
    "object" =&gt; {
      "customer" =&gt; "stripe_brandon"
    }
  }
}
</code></pre>

<p>  end</p>

<p>  test &lsquo;adds invoice item based on usage&rsquo; do</p>

<pre><code>Stripe::InvoiceItem.expects(:create).with(
  customer: "stripe_brandon",
  amount: 1900,
  currency: "usd",
  description: "Usage charges"
).returns(true)
StripeEvent::InvoiceCreated.new(@payload).perform
</code></pre>

<p>  end</p>

<p>  test &lsquo;adds next level charge for usage&rsquo; do</p>

<pre><code>Stat.create!(user: users(:brandon), step: steps(:nav_one), impressions: 3_000, date: 5.days.ago)

Stripe::InvoiceItem.expects(:create).with(
  customer: "stripe_brandon",
  amount: 4900,
  currency: "usd",
  description: "Usage charges"
).returns(true)
StripeEvent::InvoiceCreated.new(@payload).perform
</code></pre>

<p>  end
end
```</p>

<p>The first thing I noticed with this setup was the detailed usage of <code>Stripe::InvoiceItem.expects</code>. I wasn’t sure if this was necessarily a bad thing because it was a third-party service and it seemed like reasonable boundary of the application.</p>

<p>Aside from the mock, another thing that bothered me was the difficulty simulating different pricing tiers and customer usage. You probably noticed the <code>Stat.create!…</code> in the last test. I could’ve duplicated <code>Stat</code> entries until I reached some arbitrary level of usage that bumped this user to the next pricing tier. But that felt risky and very dependent on knowing the actual value of the subsequent tier.</p>

<p>What if I wanted to change the ceiling of that tier next month? I’d have to come in here and adjust the stats being created until it totaled something above the adjustment. It just felt weird…</p>

<p>What if we had a way to easily swap in implementations of the <code>Billing::Usage</code>? It would then allow me to concoct any combination of usage and mock the expected values sent to Stripe.</p>

<h2>Setter Injection</h2>

<p>In a few other articles, I’ve heard this termed “accessors as collaborators”. Whatever the name, it was surprising how such a little a change could produce so much flexibility in my tests. And with that additional flexibility came confidence because it allowed me to test the edge cases with minimal overhead.</p>

<p>```
module StripeEvent
  class InvoiceCreated</p>

<pre><code>attr_writer :usage_service
attr_reader :payload

def initialize(payload)
  @payload = payload
end

def perform
  if user.created_at &lt; 14.days.ago
    Stripe::InvoiceItem.create(
      customer: user.stripe_id,
      amount: additional_charges_in_cents,
      currency: "usd",
      description: "Usage charges"
    )
  end
end

private

def additional_charges_in_cents
  Billing::Tier.new(usage).additional_charges_in_cents
end

def usage
  usage_service.last_30_days
end

def usage_service
  @usage_service ||= Billing::Usage.new(user)
end

def user
  @user ||= User.find_by(stripe_id: payload["data"]["object"]["customer"])
end
</code></pre>

<p>  end
end
```</p>

<p>A couple things changed:</p>

<ol>
<li><p><code>usage_service</code> was created to extract the code to calculate customer usage</p></li>
<li><p>The <code>usage</code> method now calls the <code>last_30_days</code> method on <code>usage_service</code></p>

<p> This is interesting because you’ll notice now that the only important idea about <code>usage_service</code> is the   fact that is has a <code>last_30_days</code> method. We can now take comfort in the idea that <code>usage_service</code> could    be anything really, as long as it implements the <code>last_30_days</code> method.</p></li>
<li><p><code>attr_writer :usage_service</code> was added to allow for other implementations of the usage class</p></li>
</ol>


<p>This allows us to inject other forms of the <code>usage_service</code> to simulate more or less customer usage:</p>

<p>```
require &lsquo;test_helper&rsquo;</p>

<p>class InvoiceCreatedTest &lt; ActiveSupport::TestCase
  def setup</p>

<pre><code>@payload = {
  "data" =&gt; {
    "object" =&gt; {
      "customer" =&gt; "stripe_brandon"
    }
  }
}
</code></pre>

<p>  end</p>

<p>  test &lsquo;adds invoice item based on usage&rsquo; do</p>

<pre><code>Stripe::InvoiceItem.expects(:create).with(
  customer: "stripe_brandon",
  amount: 1900,
  currency: "usd",
  description: "Usage charges"
)
StripeEvent::InvoiceCreated.new(@payload).perform
</code></pre>

<p>  end</p>

<p>  test &lsquo;adds next level charge for usage&rsquo; do</p>

<pre><code>Stat.create!(user: users(:brandon), step: steps(:nav_one), impressions: 3_000, date: 5.days.ago)

Stripe::InvoiceItem.expects(:create).with(
  customer: "stripe_brandon",
  amount: 4900,
  currency: "usd",
  description: "Usage charges"
)
StripeEvent::InvoiceCreated.new(@payload).perform
</code></pre>

<p>  end</p>

<p>  test &lsquo;adds highest tier&rsquo; do</p>

<pre><code>Stripe::InvoiceItem.expects(:create).with(
  customer: "stripe_brandon",
  amount: 49900,
  currency: "usd",
  description: "Usage charges"
)
inv = StripeEvent::InvoiceCreated.new(@payload)
inv.usage_service = Level5Usage.new
inv.perform
</code></pre>

<p>  end</p>

<p>  test &lsquo;adds 2nd highest tier&rsquo; do</p>

<pre><code>Stripe::InvoiceItem.expects(:create).with(
  customer: "stripe_brandon",
  amount: 24900,
  currency: "usd",
  description: "Usage charges"
)
inv = StripeEvent::InvoiceCreated.new(@payload)
inv.usage_service = Level4Usage.new
inv.perform
</code></pre>

<p>  end</p>

<p>  test &lsquo;adds middle tier&rsquo; do</p>

<pre><code>Stripe::InvoiceItem.expects(:create).with(
  customer: "stripe_brandon",
  amount: 12900,
  currency: "usd",
  description: "Usage charges"
)
inv = StripeEvent::InvoiceCreated.new(@payload)
inv.usage_service = Level3Usage.new
inv.perform
</code></pre>

<p>  end</p>

<p>  test &lsquo;adds 2nd tier&rsquo; do</p>

<pre><code>Stripe::InvoiceItem.expects(:create).with(
  customer: "stripe_brandon",
  amount: 4900,
  currency: "usd",
  description: "Usage charges"
)
inv = StripeEvent::InvoiceCreated.new(@payload)
inv.usage_service = Level2Usage.new
inv.perform
</code></pre>

<p>  end</p>

<p>  test &lsquo;adds 1st tier&rsquo; do</p>

<pre><code>Stripe::InvoiceItem.expects(:create).with(
  customer: "stripe_brandon",
  amount: 1900,
  currency: "usd",
  description: "Usage charges"
)
inv = StripeEvent::InvoiceCreated.new(@payload)
inv.usage_service = Level1Usage.new
inv.perform
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  Level5Usage = Class.new { def last_30_days; 2_000_000; end }
  Level4Usage = Class.new { def last_30_days; 900_000; end }
  Level3Usage = Class.new { def last_30_days; 190_000; end }
  Level2Usage = Class.new { def last_30_days; 19_000; end }
  Level1Usage = Class.new { def last_30_days; 1_900; end }
```</p>

<p>I’ve created classes for each usage tier that implement the <code>last_30_days</code> method. In real life, this usage service is more complex, but we can test the complexity of it alone through unit tests. The responsibility of this class is to ensure invoice items are added to Stripe correctly, so removing the complexity of <code>Billing::Usage</code> form this test allows us to maximize this test’s value and keep us isolated from the implementation of <code>Billing::Usage</code> — assuming it implements the <code>last_30_days</code> method.</p>

<h2>Constructor Injection</h2>

<p>Most dependency injection posts focus on constructor injection. The idea being that an implementation can be supplied. If not, a reasonable default will be provided. How might that change this scenario?</p>

<p>```
module StripeEvent
  class InvoiceCreated</p>

<pre><code>attr_reader :payload

def initialize(payload, usage_service = Billing::Usage)
  @payload = payload
  @usage_service = usage_service
end

def perform
  if user.created_at &lt; 14.days.ago
    Stripe::InvoiceItem.create(
      customer: user.stripe_id,
      amount: additional_charges_in_cents,
      currency: "usd",
      description: "Usage charges"
    )
  end
end

private

def additional_charges_in_cents
  Billing::Tier.new(usage).additional_charges_in_cents
end

def usage
  @usage_service.new(user).last_30_days
end

def user
  @user ||= User.find_by(stripe_id: payload["data"]["object"]["customer"])
end
</code></pre>

<p>  end
end
```</p>

<p>Because the <code>usage</code> method requires instantiation from within the class, I had to update the fake test Usage classes to accept <code>user</code> as an argument during instantiation:</p>

<p>```
require &lsquo;test_helper&rsquo;</p>

<p>class InvoiceCreatedTest &lt; ActiveSupport::TestCase
  def setup</p>

<pre><code>@payload = {
  "data" =&gt; {
    "object" =&gt; {
      "customer" =&gt; "stripe_brandon"
    }
  }
}
</code></pre>

<p>  end</p>

<p>  test &lsquo;adds invoice item based on usage&rsquo; do</p>

<pre><code>Stripe::InvoiceItem.expects(:create).with(
  customer: "stripe_brandon",
  amount: 1900,
  currency: "usd",
  description: "Usage charges"
)
StripeEvent::InvoiceCreated.new(@payload).perform
</code></pre>

<p>  end</p>

<p>  test &lsquo;adds next level charge for usage&rsquo; do</p>

<pre><code>Stat.create!(user: users(:brandon), step: steps(:nav_one), impressions: 3_000, date: 5.days.ago)

Stripe::InvoiceItem.expects(:create).with(
  customer: "stripe_brandon",
  amount: 4900,
  currency: "usd",
  description: "Usage charges"
)
StripeEvent::InvoiceCreated.new(@payload).perform
</code></pre>

<p>  end</p>

<p>  test &lsquo;adds highest tier&rsquo; do</p>

<pre><code>Stripe::InvoiceItem.expects(:create).with(
  customer: "stripe_brandon",
  amount: 49900,
  currency: "usd",
  description: "Usage charges"
)
inv = StripeEvent::InvoiceCreated.new(@payload, Level5Usage)
inv.perform
</code></pre>

<p>  end</p>

<p>  test &lsquo;adds 2nd highest tier&rsquo; do</p>

<pre><code>Stripe::InvoiceItem.expects(:create).with(
  customer: "stripe_brandon",
  amount: 24900,
  currency: "usd",
  description: "Usage charges"
)
inv = StripeEvent::InvoiceCreated.new(@payload, Level4Usage)
inv.perform
</code></pre>

<p>  end</p>

<p>  test &lsquo;adds middle tier&rsquo; do</p>

<pre><code>Stripe::InvoiceItem.expects(:create).with(
  customer: "stripe_brandon",
  amount: 12900,
  currency: "usd",
  description: "Usage charges"
)
inv = StripeEvent::InvoiceCreated.new(@payload, Level3Usage)
inv.perform
</code></pre>

<p>  end</p>

<p>  test &lsquo;adds 2nd tier&rsquo; do</p>

<pre><code>Stripe::InvoiceItem.expects(:create).with(
  customer: "stripe_brandon",
  amount: 4900,
  currency: "usd",
  description: "Usage charges"
)
inv = StripeEvent::InvoiceCreated.new(@payload, Level2Usage)
inv.perform
</code></pre>

<p>  end</p>

<p>  test &lsquo;adds 1st tier&rsquo; do</p>

<pre><code>Stripe::InvoiceItem.expects(:create).with(
  customer: "stripe_brandon",
  amount: 1900,
  currency: "usd",
  description: "Usage charges"
)
inv = StripeEvent::InvoiceCreated.new(@payload, Level1Usage)
inv.perform
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  Level5Usage = Struct.new(:user) { def last_30_days; 2_000_000; end }
  Level4Usage = Struct.new(:user) { def last_30_days; 900_000; end }
  Level3Usage = Struct.new(:user) { def last_30_days; 190_000; end }
  Level2Usage = Struct.new(:user) { def last_30_days; 19_000; end }
  Level1Usage = Struct.new(:user) { def last_30_days; 1_900; end }
```</p>

<p>The resulting test classes seem overly complex and sprinkled with details that aren’t particularly relevant to its responsibility. If we were to pass in an already instantiated usage class as an argument, it means we would have to already know the user before-hand, which means we’d have to parse <code>@user ||= User.find_by(stripe_id: payload["data"]["object"]["customer”])</code> outside of this class. I don’t love that solution — the parent that calls this <code>InvoiceCreated</code> class is pretty minimal and I wanted to keep it that way.</p>

<p>Another option would be to provide <code>user</code> as an argument to the to the <code>last_30_days</code> method:</p>

<p><code>
def usage
  @usage_service.new.last_30_days(user)
end
</code></p>

<p>We could then change our fake test usage classes back to:</p>

<p><code>
Level1Usage = Class.new { def last_30_days; 1_900; end }
</code></p>

<p>Notice the lack of <code>Struct</code> with an argument…</p>

<h2>Summary</h2>

<p>Of the two options, I prefer the setter injector in this case. There’s something about changing the signature of a class just for tests that didn’t feel natural.</p>

<p>An accessor (or writer…), in this case, provided the same flexibility without changing the signature. I like being able to quickly look at the argument list of <code>initialize</code> and clearly understand its roles and responsibilities within the system.</p>

<p>Which do you prefer?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Gemfile Teardown - 2014]]></title>
    <link href="http://brandonhilkert.com/blog/rails-gemfile-teardown-2014/"/>
    <updated>2014-12-03T13:14:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/rails-gemfile-teardown-2014</id>
    <content type="html"><![CDATA[<p>What’s the first thing you look at when you see the source code of a Rails project?</p>

<p>For me, it’s the <code>Gemfile</code>. Think about it&hellip;there&rsquo;s very few other files that contain so much information. It describes the building blocks of the application. And at times, you can even see specific features of the application.</p>

<!--more-->


<p>A <code>Gemfile</code> also includes hints about preference and style. And style is something most Ruby developers are very passionate about. It doesn’t take long to find the story of a Rubyist describing their “love at first sight” experience with the language. It’s hard to find another file in a Rails project that’s so telling.</p>

<p>A year ago, I wrote about the <a href="/blog/patterns-in-a-rails-gemfile/">Ruby gems I regularly use in my Rails applications</a>. Because technology and the tools we use change so fast, I thought it’d be interesting to take a look at one of my more recent Gemfiles to see what’s changed.</p>

<h2>Rails Templates</h2>

<p>As I mentioned in the last <a href="/blog/patterns-in-a-rails-gemfile/">Gemfile post</a>, I tend to write a bunch of small applications sprinkled around some larger ones. Despite the size of the project, I feel like I’ve honed in a set of Ruby gems that feel comfortable and productive for me and my workflow.</p>

<p>Knowing the act of bootstrapping a Rails project is sometimes tedious, I took some time to build a <a href="https://github.com/brandonhilkert/rails_templates">Rails template</a> around the gems and patterns I commonly use. I’ll definitely be writing about this experience in the future since there seems to be very little discussion about it.</p>

<p>In short, extracting my preferences to a template has been a HUGE time saver. It no longer feels like a burden to run <code>rails new</code>. I can jump right in and have a consistent set of tools that enable me to be productive within a few minutes.</p>

<h2>My 2014 Gemfile</h2>

<p>The <code>Gemfile</code> below is one of the larger projects I worked on this year. I thought it’d give a good sense of some of my more practical everyday preferences, along with some feature-specific choices for this particular application.</p>

<p>```
source &lsquo;<a href="https://rubygems.org">https://rubygems.org</a>&rsquo;</p>

<p>ruby &lsquo;2.1.4&rsquo;</p>

<p>gem &lsquo;rails&rsquo;, &lsquo;4.1.8&rsquo;
gem &lsquo;pg&rsquo;
gem &lsquo;sass-rails&rsquo;, &lsquo;~> 4.0.3&rsquo;
gem &lsquo;uglifier&rsquo;, &lsquo;>= 1.3.0&rsquo;
gem &lsquo;coffee-rails&rsquo;, &lsquo;~> 4.0.0&rsquo;
gem &lsquo;jquery-rails&rsquo;
gem &lsquo;turbolinks&rsquo;</p>

<p>gem &lsquo;bcrypt-ruby&rsquo;, &lsquo;~> 3.1.2&rsquo;</p>

<p>group :development, :test do
  gem &lsquo;pry&rsquo;
end</p>

<p>group :test do
  gem &lsquo;selenium-webdriver&rsquo;
  gem &lsquo;capybara&rsquo;
  gem &lsquo;timecop&rsquo;
  gem &lsquo;mocha&rsquo;
end</p>

<p>group :development do
  gem &lsquo;quiet_assets&rsquo;
  gem &lsquo;spring&rsquo;
  gem &lsquo;bullet&rsquo;
  gem &lsquo;stripe_tester&rsquo;, &lsquo;~> 0.1.0&rsquo;
end</p>

<p>group :production, :demo do
  gem &lsquo;rails_12factor&rsquo;
  gem &lsquo;heroku-deflater&rsquo;
end</p>

<p>gem &lsquo;font-awesome-rails&rsquo;
gem &lsquo;unicorn&rsquo;
gem &lsquo;bootstrap-sass&rsquo;
gem &lsquo;sidekiq&rsquo;, require: &lsquo;sidekiq/web&rsquo;
gem &lsquo;sinatra&rsquo;
gem &lsquo;local_time&rsquo;
gem &lsquo;gravatar_image_tag&rsquo;
gem &lsquo;so_meta&rsquo;
gem &lsquo;chronic&rsquo;
gem &lsquo;recurrence&rsquo;</p>

<p>gem &lsquo;premailer-rails&rsquo;</p>

<p>gem &lsquo;momentjs-rails&rsquo;
gem &lsquo;bootstrap3-datetimepicker-rails&rsquo;
gem &lsquo;bootstrap-switch-rails&rsquo;
gem &lsquo;bootstrap-wysihtml5-rails&rsquo;
gem &lsquo;bootstrap-select-rails&rsquo;
gem &lsquo;autosize-rails&rsquo;</p>

<p>gem &lsquo;aws-sdk&rsquo;</p>

<p>gem &lsquo;html-pipeline&rsquo;
gem &lsquo;rinku&rsquo;</p>

<p>gem &lsquo;newrelic_rpm&rsquo;
gem &lsquo;doc_raptor&rsquo;
gem &lsquo;stripe&rsquo;
gem &lsquo;jquery-ui-rails&rsquo;
gem &lsquo;active_model_serializers&rsquo;
gem &lsquo;rubyzip&rsquo;
gem &lsquo;render_anywhere&rsquo;, require: false
gem &lsquo;pusher&rsquo;
gem &lsquo;filepicker-rails&rsquo;
gem &lsquo;memcachier&rsquo;
gem &lsquo;dalli&rsquo;
gem &lsquo;intercom-rails&rsquo;
```</p>

<p>A few comments:</p>

<ul>
<li><p>I’ve standardized on <a href="http://www.postgresql.org/">Postgres</a> as the database for my apps, even in development. It’s reliable and allows me to be sure that the code I write will work the same way in production, since I tend to deploy most of my apps to <a href="https://www.heroku.com/">Heroku</a>.</p></li>
<li><p>I leave <code>turbolinks</code> on. Judging from recent posts and comments within the community, this will probably one of the more controversial decisions.</p>

<p>  If I’m being honest, my first experience with Turbolinks wasn’t great. And by “wasn’t great”, I mean — it broke <strong>EVERYTHING</strong>! But the good news was that it brought to light the fact that I sucked at javascript. At the time, I was capable of writing <em>just</em> enough to modify form behavior or fade in an DOM element.</p>

<p>  The time had come to level up on my javascript skills. I was able to improve my javascript and also do it in a way that can took full advantage of the benefits that Turbolinks offers. Since that time, I’ve left Turbolinks on and no longer had to worry that my client-side code will stop working after clicking through a few application links.</p></li>
<li><p>I’ve standardized on using <code>has_secure_password</code> for authentication. I previously used <a href="https://github.com/plataformatec/devise">devise</a>, but found the extra features are no longer worth the additional complexity. <code>has_secure_password</code> provides me reliable authentication patterns that are simple to understand and maintain. Hence the need for <code>bcrypt</code> in the <code>Gemfile</code> above.</p></li>
<li><p>As for my test environment, I’ve written about <a href="/blog/7-reasons-why-im-sticking-with-minitest-and-fixtures-in-rails/">my switch to Minitest and fixtures</a>. I’m still just as happy with that decision as the time I wrote about it. I’ve seen Rspec go through a variety of API changes since then, and thankful I no longer have to worry about updating my test suite every couple months. I continue to find value in <code>capybara</code> and include <code>mocha</code> for the times <code>Minitest</code>’s stubbing and mocking isn’t enough (I’ve been meaning to dig in to the places I use <code>mocha</code>. I’m guessing if the code was better, I probably wouldn’t need it at all).</p></li>
<li><p><code>bullet</code> is a killer gem for tracking down performances issues. It’s saved me countless hours of debugging.</p></li>
<li><p>The inclusion of <code>spring</code> in Rails 4.1 is great. I realize it’s a bandaid in some respects, but waiting for the environment to load on every test run is a drag. I’ve found that because my tests are so responsive when <code>spring</code> is working properly, it encourages me to run my tests more often. Once setup, it works well and only in rare cases has not reloaded when it should have.</p></li>
<li><p>I generally always include <code>bootstrap</code> and <code>font-awesome</code> in my projects. Being a non-designer, it helps me get something on the screen faster, even if it’s not the final design.</p></li>
<li><p>I continue to use <code>unicorn</code>. It’s been around for so long and continues to be competitive in benchmarks against other Ruby web servers. I tested Passenger in a few applications, but got scared off when it printed the entire environment to the screen in production on Heroku on an exception. I’m told there are ways around this with some non-trivial configuration, but I think it’s a bizarre default and isn’t conducive to my workflow.</p></li>
<li><p>For the apps that need background processing, <code>sidekiq</code> continues to be my goto when a separate worker is necessary. I generally mount Sidekiq’s web UI to provide insight to the state of the jobs, which is why <code>sinatra</code> is included.</p></li>
<li><p>I’ve written about putting together <a href="/blog/relative-timestamps-in-rails/">a gem to render relative timestamps</a> on the client side. While I’d love to sit here and tell you I use it, I don’t. Basecamp’s <a href="https://github.com/basecamp/local_time">local_time</a> gem is exceptional for that need and I’m pretty sure we can count on it being updated and maintained well going forward (one of the biggest changes in my mindset for including a new gem).</p></li>
<li><p>This particular app has some pretty hairy time calculations and scheduling. It’s not something I was very experienced with prior, but found value in the combination of <code>chronic</code> and <code>recurrence</code>. Both make the process of targeting a specific <code>datetime</code> and scheduling something in the future relatively simple.</p></li>
<li><p>I included a number of bootstrap related javascript gems (<code>bootstrap3-datetimepicker-rails</code>, <code>bootstrap-switch-rails</code>, <code>bootstrap-switch-rails</code>, <code>bootstrap-select-rails</code>). All are little more than a <a href="/blog/how-to-build-a-rails-engine/">Rails engine</a> that exposes the appropriate javascript and stylesheets to the asset pipeline. These are particularly dependent on the project. I’d normally not start by including anything like this. Side note &ndash; I could’ve copied the relevant assets to <code>vendor/assets</code> rather than requiring a gem that does the same. In a few cases, some added view helpers as well.</p></li>
<li><p>I’ve standardized on using New Relic to collect application metrics and exceptions.</p></li>
<li><p>It shouldn’t be a surprise that <code>stripe</code> is the payment processor I reach for when I’m in control. It’s super developer-friendly and, at this point, I’ve done enough that integration is not much more than a copy/paste from other apps. I recently started using <code>stripe_tester</code> in the test environment. It’s been great for stubbing out calls to Stripe so the test suite continues to be performant. It also allows me to setup some unique edge-case data coming from Stripe so I can protect users from ending up in a crappy state.</p></li>
<li><p>I generally reach for <code>active_model_serializers</code> anytime I need a <code>json</code> response that contains more than a simple hash (in which case I’d continue to render it in the controller response). I’ve used the view equivalent solutions a few times (<code>jbuilder</code>, etc.) and they worked ok too, but for whatever reason, <code>active_model_serializers</code> does it for me.</p></li>
</ul>


<p>The rest are very use case-specific. And in general, the defacto solution for each (<code>pusher</code> for real-time features, <code>dalli</code> for memcached, etc.).</p>

<h2>Summary</h2>

<p>I’m happy with my current toolkit. This doesn’t mean I’m not on the lookout for shiny new things, but I’m generally a little more cautious about replacing something reliable, even if it doesn’t do everything under the sun.</p>

<p>Even though Ruby makes it easy to include third party libraries, it doesn’t mean we always should. As developers, we inherit the stability of the dependencies we include. Even though a gem’s code might be locked away behind a separate git repository, it likely has the same holes and complexities that we’re worried about in our applications. And perhaps, even more…</p>

<p><a href="https://www.ruby-toolbox.com/">Ruby toolbox</a> is a great resource when searching for a gem. I generally consider the number of downloads, age of the project and development activity when deciding which one to go with.</p>

<p>What have your favorite gems been this year?</p>

<h2>Build a Ruby Gem</h2>

<p>Ruby gems are the building blocks of Ruby/Rails applications. If you haven’t built one yourself, there’s no better time to start. Github makes it extremely to contribute to existing gems and sometimes that’s <a href="/blog/3-ways-to-get-started-contributing-to-open-source/">the easiest way to get started contributing to open source</a>. My book, <em>Build a Ruby Gem</em>, includes <a href="/books/build-a-ruby-gem/">everything you to need to get started building a Ruby gem</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Creating Rails Active Record Validation Contexts with Inheritance]]></title>
    <link href="http://brandonhilkert.com/blog/creating-rails-active-record-validation-contexts-with-inheritance/"/>
    <updated>2014-11-18T17:20:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/creating-rails-active-record-validation-contexts-with-inheritance</id>
    <content type="html"><![CDATA[<p>If you’ve used <code>validates</code> in a Rails Active Record model, you know they work great -- at least until the first bit of complexity arises. At that point, they can quickly morph in to a ball of conditional spaghetti convoluting the initial reason the validation was added in the first place.</p>




<p>I recently had an experience using <code>has_secure_password</code> where I wanted control the length of the user-supplied password. Adding a length validation to the password accessor invalidated existing records, so I was in a bit of a bind. In the end, I sub-classed the Active Record model to create a unique model made specifically for that context. This allowed me to inherit the core functionality from the model and sprinkle on existing validations for specific use cases. This was a new tactic for me and I’m still now sure how I feel about it. I like the fact that it removed complexity from the <code>User</code> model. This, in hopes, will keep the minimize the likelihood of it becoming a God object.</p>




<!--more-->




<h2>The Problem</h2>




<p>Using <code>has_secure_password</code> is a relatively easy way to add authentication to a Rails app. In order to disguise the plain text passwords, an <a href="https://github.com/rails/rails/blob/3bdf7b80a11dcb67b18553ff1fe0da82b0cffc20/activemodel/lib/active_model/secure_password.rb#L106">accessor for the plain <code>password</code></a> is added that encrypts it before saving.</p>




<p>The only true Active Record validation <code>has_secure_password</code> adds is a <a href="https://github.com/rails/rails/blob/3bdf7b80a11dcb67b18553ff1fe0da82b0cffc20/activemodel/lib/active_model/secure_password.rb#L68">confirmation of the password</a> — and only when the password is present. This allows us to create a user object without supplying a password, or maybe saving straight to the <code>password_digest</code> field, which is used to store the encrypted password in the database.</p>




<p>I wanted to enforce a minimum password length, because what good is a 1 character password (or 0 for that matter) ?!?!</p>




<p>The first thing I did was add this to the <code>User</code> model:</p>




<pre><code>validates :password, length: { minimum: 8 }
</code></pre>




<p>This works for new users, but not for those with a <code>password_digest</code> already. Attempting to updated an existing user produces the following error:</p>




<pre><code>ActiveRecord::RecordInvalid: Validation failed: Password is too short (minimum is 8 characters)
</code></pre>




<p>The next step was to conditionalize only on create:</p>




<pre><code>validates :password, length: { minimum: 8 }, on: :create
</code></pre>




<p>Except, that wasn’t right either because I’d definitely want to allow users to update their password, in which case, the length validation wouldn’t be enforced.</p>




<p>I found another <a href="http://quickleft.com/blog/rails-tip-validating-users-with-has_secure_password">post suggesting to allow <code>nil</code></a> using:</p>




<pre><code>validates :password, length: { minimum: 8 }, allow_nil: true
</code></pre>




<p>But, again, that felt weird and doesn’t read particularly well when you’re looking through the source trying to understand what condition would generate a <code>nil</code> password.</p>




<p>Other solutions included <a href="http://stackoverflow.com/a/6486345/2261909">mixing conditionals and checking model dirty state</a> and <a href="http://urgetopunt.com/rails/2012/11/12/validate-password-presence-has-secure-password.html">some combination of all of the above</a>.</p>




<p>I’m guessing some combination of the above would’ve worked, but something didn’t feel quite right. A quick glance over any of those solutions left me wanting something cleaner and more approachable. Because it’s a complex and tremendously important part of the app, I wanted to feel comfortable with the solution.</p>




<h2>The Solution</h2>




<p>I recently read <a href="https://leanpub.com/growing-rails"><em>Growing Rails Application in Practice</em></a>. The most interesting takeaway for me was the idea of sub-classing an Active Record object to exactly the problem described above.</p>




<p>Consider this…we have our <code>User</code> model with <code>has_secure_password</code>:</p>




<pre><code>class User &lt; ActiveRecord::Base
  has_secure_password
end
</code></pre>




<p>As we saw above, the variety of validation contexts made the standard ActiveModel validation awkward. What if we sub-class <code>User</code> and add the validation contexts for a specific use case? In our case, minimum length:</p>




<pre><code>class User::AsSignUp &lt; User
  validates :password, length: { minimum: 8 }
end
</code></pre>




<p>In this case, we’re create a separate model, for the purpose of signing up, and perhaps other user-related attribute management (profile, password reset, etc.).</p>




<p>Now, instead of passing the <code>User</code> model to the view from the controller, we pass an instantiated version of the new context-specific model class:</p>




<pre><code>def create
  @user = User::AsSignUp.find(current_user.id)
  …
end
</code></pre>




<p>Lastly, because the sub-class name is inferred within the form, we have to do one more thing to make the params are accessible on the <code>create</code> action using <code>params[:user]</code>. We’ll change the form from:</p>




<pre><code>&lt;%= form_for @user, url: user_confirm_path(@user.invitation_token) do |f| %&gt;
</code></pre>




<p>to:</p>




<pre><code>&lt;%= form_for @user, as: :user, url: user_confirm_path(@user.invitation_token) do |f| %&gt;
</code></pre>




<p>Because the remainder of the app operates fine without any need for the password validation, the <code>User</code> can be used where necessary and without worry of it becoming invalid because the password accessor isn’t present.</p>




<h2>Summary</h2>




<p>While sub-classing models in Rails is generally frowned upon, this use case is one of the few that felt reasonable. It feels relatively low cost and stays in isolation. I’d love to hear how you might have solved this problem. I looked and explored a handful of solutions. While others worked, none seems as expressive as the one above.</p>


<p>A form object using
<a href="http://api.rubyonrails.org/classes/ActiveModel/Model.html">ActiveModel</a> or
similar could&rsquo;ve been an alternative option. I didn&rsquo;t explore it for this
particular use case, mostly because I wanted to give this one a shot. However,
I have no doubt it would&rsquo;ve at least worked equally as well.</p>

<p>I should also point out that I&rsquo;m familiar with the built-in <a href="https://github.com/rails/rails/blob/master/activemodel/lib/active_model/validations.rb#L73">validation
contexts in ActiveModel</a>.
And for whatever reason, I&rsquo;ve not used them before. I&rsquo;ll probably give it a
shot on another occasion for comparison.</p>

<p>What are your thoughts on this technique?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Absolutes as an AntiPattern]]></title>
    <link href="http://brandonhilkert.com/blog/absolutes-as-an-antipattern/"/>
    <updated>2014-09-28T22:35:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/absolutes-as-an-antipattern</id>
    <content type="html"><![CDATA[<p>It’s been awhile since my last post — almost 2 months to be specific. A trip to Portugal, getting sick and a minor run-in with a table saw made it challenging to post anything for the last couple weeks. But I’d be lying if I said I was itching to write.</p>

<p>During that time, I didn’t have anything screaming to be talked about. I have a long list of “decent post” topics, but none of them got me particularly excited. Until today…</p>

<!--more-->


<p>I stumbled on a blog post related to Rails’s upcoming <a href="http://edgeguides.rubyonrails.org/active_job_basics.html">Active Job feature</a>. While demonstrating the syntax for specifying the adapter, there was comment in the code snippet that said <em>“inline and other worse options”</em>. This caught me by surprise and bummed me out at the same time. Not only because I’m the author of <a href="https://github.com/brandonhilkert/sucker_punch">one of them</a>, but because there are a handful of background processing libraries in Ruby that are really good.</p>

<p>So, naturally, I pinged the author and mentioned the comment might be sending the wrong message. He responded with “I consider sidekiq to be the best background processing tool available for Ruby.” And then later, <em>“sidekiq is significantly better that delayed_job and resque. You’re welcome to disagree”</em>.</p>

<p><em>Note: The responses above illustrate a general sentiment. By no means is this post focused on the individual that said them.</em></p>

<p>The thing is, I don’t completely disagree. As you probably already know, I’m a huge fan of of <a href="http://sidekiq.org/">Sidekiq</a>. I’ve contributed to the project and believe Sidekiq’s author, <a href="https://www.mikeperham.com/">Mike Perham</a> is not only a great leader in the Ruby community, but a great example of how to manage and lead open source projects well.</p>

<p>However, those responses reminded me how damaging absolutes can be. You’ve probably heard it before:</p>

<blockquote><p>“we can <strong>ABSOLUTELY NOT</strong> do x, y and z”</p></blockquote>

<p><em>Why not? Will the world end? How do I know?</em></p>

<p>or, what about:</p>

<blockquote><p>“this feature needs to go out tomorrow, no excuses”</p></blockquote>

<p><em>What if there is an excuse? What if it’s not ready? Will I be fired? Will our company go under?</em></p>

<p>There are trade-offs to every decision made. While some options may not be ideal, they may still work, perhaps just not as well.</p>

<p>Absolutes beg the toddler question, <em>”why?”</em>. <em>Why won’t that language X work?</em> <em>Why can’t we use Y?</em>. If you don’t know the answer to those questions, you’re doing yourself a disservice by not asking. Maybe the person has thoroughly researched the topic to come up with those conclusions. But, maybe, they haven’t.</p>

<p>I’ve noticed those who do exhaustive research on a topic tend to present the information in a different manner. They’re confident the facts they found will prove their case and seem to present their findings less defensively. No, <em>”it has to be done like this”</em>. More like, <em>“I found a few ways to fix the problem and here’s why I think option 1 might be the best solution. What do you think?”</em>.</p>

<p>Whether you follow agile or any other methodology, predictions and absolutes have no place in conversations. There are plenty of examples of failed software projects. I’m pretty sure all of them featured people promising the work would be done in time and under budget. Buuuuuuut, it wasn’t.</p>

<h2>Background Jobs for the Big Boys</h2>

<p>Delayed Job was the first Ruby background processing library I used. I remember feeling badass that I was doing all this complicated stuff in the background. But at some point, there we so many jobs and so much activity that pushing and pulling jobs out of the primary data store wasn’t efficient. Reads from the web UI would slow down (and ultimately stop) and users would bail. Unfortunately, I couldn’t pop up a message and say, <em>”hey, hope you don’t mind, but I’m doing some pretty crucial shit in the background here, so you’re experience is gonna be sucky for a bit! sorry :(”</em>.</p>

<p>So, at the time, Resque was the next logical transition. I migrated the previously written jobs from Delayed Job to Resque and experienced a new level of <em>bad ass</em>. Fast forward 4 years — I still work on projects using Resque. Needless to say, it’s a pretty awesome piece of open source software.</p>

<p>A few years ago, Sidekiq came along. While I didn’t know much about multi-threading code in Ruby, I tried it on a side project and was floored at the results. Those 6 Heroku workers that I’d been paying for could be compacted in to 1?!?! And on top of that, I only needed 1 worker that had 25 workers working against the queue?!?!</p>

<p>But then one day, I dropped it in to a project that was using MongoDB and MongoMapper as ORM and things didn’t go so well. In the end, MongoMapper wasn’t thread-safe, which is a requirement of Sidekiq worker code. So in that case, was Sidekiq the best tool for the job? While I would’ve loved to use Sidekiq on that project, it certainly (like the absolute there…) wasn’t the right tool for <em>that</em> job.</p>

<p>And what about when I first started with Delayed Job…we were a small startup with limited cash. While it seems silly to balk over an extra $35 Heorku dyno, it was $35 that could’ve gone towards something else. Not to mention the extra Redis instance, along with the expertise to make sure the thing didn’t fall over and die. Was Sidekiq (or Resque for that matter) the best tool for that job? Nope!</p>

<p>Fast forward a few years, I had the need for an in-process background processing library, so <a href="http://brandonhilkert.com/blog/why-i-wrote-the-sucker-punch-gem/">I wrote one</a>. That need was driven off the motivation above — needing to minimize cost and complexity. Would Sidekiq have worked for that project? Of course! In fact, it was using Sidekiq for a year or so before I transitioned the jobs to use Sucker Punch.</p>

<h2>Use Cases</h2>

<p>At this point, you should be noticing a trend, right? The examples above were unique use cases with a unique set of requirements and limitations. Sure, if every project I worked on had unlimited resources (both time and money), Sidekiq would be probably be my go-to the majority of time (even when writing that sentence I hesitated and almost wrote “all the time”).</p>

<p>But I hesitate now. Because I remember learning about the new cool things and thinking, <em>”This is the best! There’s no way I’ll never not use it”</em>. And when I would talk to other developers, I would rave about how <em>X</em> is the best for <em>Y</em>. And now I realize I was a dummy for doing that. There’s no way I could’ve made that judgement for someone else and their work. What I really should’ve said was, <em>”I tried [insert fancy new gem/technique] for the first time the other day. It worked really well for doing X in my project that does Y”</em>. That definitely doesn’t sound as exciting, but it was the truth.</p>

<p>I feel fortunate to get to write Ruby everyday. It’s incredibly expressive, which is why the debate over the countless ways to do something is great. Does the code express the right intent? For your method, it might. But for mine, it might express the complete opposite. The good news is, that’s OK. Both versions will work and the fact that we can have conversations like that is a praise for the language itself. I prefer to have the opportunity to have that conversation about style, rather than a language more black and white. Maybe it’s the creative in me, but it seems like no 2 Ruby solutions will be identical and that’s one of the things I love most about writing Ruby.</p>

<p>We often joke about the stack overflow post that starts with <em>“I’m thinking about learning Rails…is it better than PHP?”</em>. Or even more relevant today, <em>”Which javascript framework should I use?”</em>.</p>

<p>And then there’s the guy who comes along and is all like, <em>”Let’s back up, what are you doing and why do you absolutely need a FRAMEWORK????”</em>. While I used to ignore those types of comments, they’re the kind that I think about now and find myself typing. And that has me wondering…why the change?</p>

<h2>Experience, Experience, Experience</h2>

<p>I got to thinking about how I felt when I was first learning to program. When I started to feel comfortable with Rails, my confidence was through the roof. But at the same time, my naivety was at an all time high. I had had minimal experiences with software systems that were either critical or heavily-loaded. But having found Resque, I felt like I could solve the world’s problems. This is somewhat of an exaggeration, but not too far off. I realized that, as it relates to my technical career, my naivety is doing this related to time:</p>

<p><img class="center" src="/images/absolutes/naivety-graph.png" title="&ldquo;Graph of Naivety over Time&rdquo;" ></p>

<p>The less naivety, the more options and, naturally, certainty takes a nose dive:</p>

<p><img class="center" src="/images/absolutes/certainty-graph.png" title="&ldquo;Graph of Certainty over Time&rdquo;" ></p>

<p>The more I learn about programming in general, the more questions I have. Fortunately, experiences have brought me to a point where I can fairly weigh the use of Sucker Punch or Delayed Job for a particular use case. I’m not sure projecting absolutes from up high does anyone any good. Beginners will take it as the word and spread the message to others they come across.</p>

<p>Use cases are real. And the less we force our own biases on people, the faster they’ll realize experience is key and the random guy behind the cat avatar on Stack Overflow might actually be asking the right questions — even if they are convoluted.</p>

<p>Next time you hear an absolute, ask <em>”Why?”</em>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Refactoring Logic from a Rails View]]></title>
    <link href="http://brandonhilkert.com/blog/refactoring-logic-from-a-rails-view/"/>
    <updated>2014-07-30T06:03:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/refactoring-logic-from-a-rails-view</id>
    <content type="html"><![CDATA[<p>It’s generally known that leaving any kind of logic in a Rails view is bad news, both for debugging and your own sanity. Rails views can be cumbersome to test and leave a lot to be desired when it comes to debugging.</p>

<!--more-->


<p>I recently went through the process of refactoring a Rails view that included logic. The end result was an isolated <a href="http://blog.jayfields.com/2007/10/ruby-poro.html">PORO</a> that was easily integrated with the controller/view.</p>

<h2>Background</h2>

<p>The app I’m currently working on is a greenfield app with vague specs, at best. I don’t mention this to fault anyone, but more to illustrate a point. Not all greenfield projects have well-defined specs.</p>

<p>In this particular case, the stakeholders were somewhat unsure of what the interface should look like. Together, we tossed around a number of ideas, ultimately leading to a few options. Only once an iteration of the UI was available, would we have a clear picture of whether it <em>felt right</em>.</p>

<h2>The Problem</h2>

<p>I implemented the first option in the most crude way I could think of. Unfortunately, that way involved putting logic in the view. I know, I know — I can hear it now, <em>”C’mon Brandon, everyone knows you shouldn’t do this!”</em>. Here’s the thing — I knew it too.</p>

<p>Here’s what I ended up with:</p>

<p>```</p>

<h1>controller</h1>

<p>def people
  @week_of = params[:week_of] || Checkin::Week.recent(current_company).first.beginning
  @people = current_user.reports
end</p>

<h1>view</h1>

<p>&lt;% @people.each do |person| %>
  &lt;% checkin = person.checkin_for(@week_of) %>
  <tr></p>

<pre><code>&lt;td&gt;
  &lt;%= profile_picture person %&gt;
  &lt;%= person %&gt;
&lt;/td&gt;

&lt;td&gt;
  &lt;%= checkin_status(checkin) %&gt;
&lt;/td&gt;
</code></pre>

<p>  </tr>
&lt;% end %>
```</p>

<p>For each iteration of <code>@people</code>, I looked up the check-in for that particular week from the model:</p>

<p><code>
def checkin_for(week_of)
  Checkin.find_by(user_id: id, week_of: week_of)
end
</code></p>

<p>This crosses concerns, blurs responsibility — all the things that bad Rails app are made of. But I was doing this knowing it would either be entirely ripped out (we’d change the UI altogether), or refactored to something better.</p>

<p><em>Note: I could’ve just saved myself one step and never made the method in the model. For some reason, that made me feel better about it at the time. *shrugs*</em></p>

<p>So I added a Github issue and went on my way…</p>

<p><img class="center" src="/images/view-refactor/gh-issue.png" title="&ldquo;Github issue to refactor Rails view&rdquo;" ></p>

<h2>The Solution</h2>

<p>With a few minor tweaks, this implementation of the functionality and UI was adequate. So as time allowed, I jumped back in to untangling the mess I created.</p>

<p>The biggest variable in the display of a <code>Checkin</code> was the week (a date field corresponding to the beginning of that particular week). Once the date was known, I could look for a <code>Checkin</code> for each user in my visibility, see if it existed, and if not, return a stand-in object to represent a non-completed check-in.</p>

<p>I removed the model method:</p>

<p><code>
def checkin_for(week_of)
  Checkin.find_by(user_id: id, week_of: week_of)
end
</code></p>

<p>and the line in the view largely responsible for the mess:</p>

<p><code>
&lt;% checkin = person.checkin_for(@week_of) %&gt;
</code></p>

<p>I went back to the controller and initialized a new object that would allow me to iterate over a list of check-ins:</p>

<p><code>
def people
  @week_of = params[:week_of] || Checkin::Week.recent(current_company).first.beginning
  @reports = Checkin::Reports.new(current_user, @week_of)
end
</code></p>

<p>Let’s dig in to the new <code>Checkin::Reports</code> class…</p>

<p>```
class Checkin
  class Reports</p>

<pre><code>def initialize(user, week_of)
  @user, @week_of = user, week_of
end

def checkins
  reports.map { |person|
    Checkin.find_or_initialize_by(user_id: person.id, week_of: week_of)
  }
end

private

attr_reader :user, :week_of

def reports
  user.reports
end
</code></pre>

<p>  end
end
```</p>

<p>I instantiate with the user and week, similar to what the <code>checkin_for</code> model method did above.</p>

<p>The only relatively interesting part of this class is that it’s using <code>find_or_intialize_by</code>. It turns out that the view didn’t care if the object was <code>nil</code>, or just a non-persisted <code>Checkin</code> object. All it did was interrogate certain attributes of the object, and guard against the argument being <code>nil</code>. From that perspective, we’ve improved our code even more because now instead of supplying nil to the helper, we are actually supplying it with a newly instantiated <code>Checkin</code> with some default attributes.</p>

<p>This means that our <code>checkin_status</code> helper, went from:</p>

<p>```
def checkin_status(checkin)
  if checkin &amp;&amp; checkin.completed_at?</p>

<pre><code>fa_icon("check-square-o", class: "green") + " Submitted #{local_time checkin.completed_at, format: :short_month_day }".html_safe
</code></pre>

<p>  else</p>

<pre><code>fa_icon("warning", class: "yellow") + " Not completed"
</code></pre>

<p>  end
end
```</p>

<p>to:</p>

<p>```
def checkin_status(checkin)
  if checkin.completed_at?</p>

<pre><code>fa_icon("check-square-o", class: "green") + " Submitted #{local_time checkin.completed_at, format: :short_month_day }".html_safe
</code></pre>

<p>  else</p>

<pre><code>fa_icon("warning", class: "yellow") + " Not completed"
</code></pre>

<p>  end
end
```</p>

<p>It’s a subtle change (removing the check <code>if checkin</code> from the first conditional), but one that’s less susceptible to bizarre edge cases. And clearer — It’s reasonable to expect that by calling the first argument <code>checkin</code>, <strong>the variable should be a <code>Checkin</code></strong>, and not sometimes <code>nil</code>.</p>

<p>Returning back to the view…using the new <code>@reports</code> variable, we no longer have to query during each iteration:</p>

<p>```
&lt;% @reports.checkins.each do |checkin| %>
  <tr></p>

<pre><code>&lt;td&gt;
  &lt;%= profile_picture checkin.user %&gt;
  &lt;%= checkin.user %&gt;
&lt;/td&gt;

&lt;td&gt;
  &lt;%= checkin_status(checkin) %&gt;
&lt;/td&gt;
</code></pre>

<p>  </tr>
&lt;% end %>
```</p>

<p>Tests pass, and we’re in a much better place than we were before.</p>

<h2>Summary</h2>

<p>I’ve seen a lot of people make notes for themselves to improve areas of their application and either never get the opportunity to go back and do so, or get so far removed from the mess, they forget about how bad it was in the first place. The approach I took above by making a note for myself worked because <strong>I knew</strong> I would go back to it. It’s possible this may not work for everyone.</p>

<p>If it takes more than just making a Github issue for your and your team, find what works. The important part is that the refactor takes place, in whatever way convenient for you.</p>

<p>The idea of not putting logic in a Rails view is well regarded as a best practice. Don’t think that just because I did it above, I’m advocating that it’s ok. To me, it’s only acceptable if you go back at a later time (soonish…) and clean it up.</p>

<p>Leaving little bits of bad practice sprinkled all of your app is heading of for a bad time. As <a href="http://sandimetz.com/">Sandi Metz</a> says, <a href="http://www.confreaks.com/presenters/211-sandi-metz">“go ahead, make a mess”</a>. Just be sure to come back and clean it up.</p>
]]></content>
  </entry>
  
</feed>
