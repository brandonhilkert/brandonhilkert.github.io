<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sucker punch | Brandon Hilkert]]></title>
  <link href="http://brandonhilkert.com/blog/categories/sucker-punch/atom.xml" rel="self"/>
  <link href="http://brandonhilkert.com/"/>
  <updated>2015-03-02T07:16:26-05:00</updated>
  <id>http://brandonhilkert.com/</id>
  <author>
    <name><![CDATA[Brandon Hilkert]]></name>
    <email><![CDATA[brandonhilkert@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using the Sucker Punch Ruby Gem to Cache Stripe Data in Rails]]></title>
    <link href="http://brandonhilkert.com/blog/using-the-sucker-punch-ruby-gem-to-cache-stripe-data-in-rails/"/>
    <updated>2015-02-26T20:46:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/using-the-sucker-punch-ruby-gem-to-cache-stripe-data-in-rails</id>
    <content type="html"><![CDATA[<p>With so many services available these days, it&rsquo;s almost impossible to find or build an application that doesn&rsquo;t rely on a third-party service. Most developers that have dealt with billing systems within the past few years have likely heard of <a href="https://stripe.com/">Stripe</a>. Stripe is, by far, the most developer-friendly billing service I&rsquo;ve implemented.</p>

<p>While Stripe does provide a number of features and plugins that make updating a credit card or signing up for a service simple, there are occasions when data needs to be fetched from Stripe in real-time. For these cases, it&rsquo;s great to be able to fetch and cache this data before-hand, and only expire if you know there&rsquo;s been a change.</p>

<!--more-->


<p>Combining <a href="https://github.com/brandonhilkert/sucker_punch">Sucker Punch</a> with Rails cache allows you to cache Stripe customer data so that billing pages are just as snappy as the rest of the application.</p>

<h2>The Pain</h2>

<p>Even though Stripe is generally pretty fast, retrieving customer data on the fly can be expensive. In order to optimize page load times, we can look to cache this data before it&rsquo;s actually used.</p>

<p>If you&rsquo;re familiary with the Stripe gem, you&rsquo;ve probably seen something like this:</p>

<p><code>
customer = Stripe::Customer.retrieve(user.stripe_id)
</code></p>

<p>With the response of <code>customer</code>, we can further query customer data with the following methods:</p>

<p><code>
invoices = customer.invoices
upcoming_invoices = customer.upcoming_invoices
</code></p>

<p>If we make all 3 of these method calls on page load, we&rsquo;d have 3 separate lookups from Stripe. This is pretty common for the typical billing page where you might want to show the customer&rsquo;s current credit card on file, their past invoices, and charges they can expect for the next invoice.</p>

<p>Three lookups like this could potentially add another second or so to page load, which is not ideal.</p>

<p>So how can we improve this?</p>

<h2>The Solution</h2>

<p>First, we can move the code to fetch the relevant stripe data in to a class of it&rsquo;s own, which wraps the notion of caching around the data retrieval.</p>

<p>```
class StripeCache
  def initialize(user)</p>

<pre><code>@user = user
</code></pre>

<p>  end</p>

<p>  def refresh</p>

<pre><code>purge_all
cache_all
self
</code></pre>

<p>  end</p>

<p>  def customer</p>

<pre><code>return @customer if @customer

@customer = Rails.cache.fetch(cache_key("customer"), expires: 15.minutes) do
  Stripe::Customer.retrieve(user.stripe_id)
end
</code></pre>

<p>  end</p>

<p>  def invoices</p>

<pre><code>Rails.cache.fetch(cache_key("invoices"), expires: 15.minutes) do
  customer.invoices
end
</code></pre>

<p>  end</p>

<p>  def upcoming_invoice</p>

<pre><code>Rails.cache.fetch(cache_key("upcoming_invoice"), expires: 15.minutes) do
  customer.upcoming_invoice
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  attr_reader :user</p>

<p>  def cache_all</p>

<pre><code>customer
invoices
upcoming_invoice
</code></pre>

<p>  end</p>

<p>  def purge_all</p>

<pre><code>Rails.cache.delete_matched("stripe")
</code></pre>

<p>  end</p>

<p>  def cache_key(item)</p>

<pre><code>"user/#{user.id}/stripe/#{item}"
</code></pre>

<p>  end
end
```</p>

<p>To use this on a billing page, we could do:</p>

<p><code>
stripe = StripeCache.new(current_user).refresh
</code></p>

<p>And from the response of that class, we could access the <code>customer</code>, <code>invoices</code>, and <code>upcoming_invoice</code> respectively:</p>

<p><code>
@customer = stripe.customer
@invoices = stripe.invoices
@upcoming_invoice = stripe.invoices
</code></p>

<p>This is great! All future calls to this customer&rsquo;s Stripe data will be fast &mdash; for 15 minutes, of course.</p>

<p>However, the first time the page is load, the user is still burdened with the initial fetch of the data. So the method above works for every request to the billing page after the first.</p>

<p>But let&rsquo;s be honest, what users are going to the billing page multiple times during a session? Probably not many. So we still need to fix the initial load somehow.</p>

<p>This is where <a href="https://github.com/brandonhilkert/sucker_punch">Sucker Punch</a> comes in. Like other Ruby background processing libraries, Sucker Punch allows you to move the processing of code to the background. However, unlike the others, Sucker Punch doesn&rsquo;t require additional infrastructure like Redis, and doesn&rsquo;t require a separate worker process to monitor and execute enqueued jobs. Because of this, the time it takes to extract code to a Sucker Punch job and have it incorporated with your application code is much lower.</p>

<p>In this case, rather than send a transactional email or perform some database calculation, we can write a job thats only responsibility is to run the Stripe caching code.</p>

<p>```
class StripeCacheJob
  include SuckerPunch::Job</p>

<p>  def perform(user)</p>

<pre><code>StripeCache.new(user).refresh
</code></pre>

<p>  end
end
```</p>

<p>The next question is, when do you run this?</p>

<p>Well, I chose to run it on user login, but you could run it anywhere you think would give you a head start if the user were about to go to the billing page. In my case, on login meant that if they didn&rsquo;t go to the billing page at all, after 15 minutes the data would be exhausted from the cache anyway, so no hard done.</p>

<p>But if the user did navigate to the billing page during that session, they would have up the latest Stripe customer and invoice data to see &mdash; all without a request to stripe on page load.</p>

<p>One other thing to keep in mind is there may be times when we&rsquo;d want invalidate the Rails cache data. One example would be when the user&rsquo;s card information is updated. In that case, we can slip in another call to the Stripe cache job, which would invalidate the previous cache and re-request the customer&rsquo;s billing information:</p>

<p>```
module Accounts
  class CardsController &lt; ApplicationController</p>

<pre><code>before_action :require_authentication

def create
  cust = StripeCache.new(current_user).customer
  cust.save(card: params[:stripeToken])

  StripeCacheJob.new.async.perform(current_user)

  redirect_to account_path, notice: t("card.update.success")
end
</code></pre>

<p>  end
end
```</p>

<h2>Summary</h2>

<p>Using Sucker Punch in combination with Rails cache feels like a great way make optimizations to third-party data requests. This article focused on using it to fetch Stripe data, but it could be used with another service just as easily.</p>

<p>The beauty of Sucker Punch is that it doesn&rsquo;t require a separate worker process to be running in the background. On a platform like Heroku, this saves the cost of an additional dyno.</p>

<p>Sucker Punch excels at background jobs that are relatively fast and if missed,
wouldn&rsquo;t be critical to the operation. In this case, if a cache job is lost,
it&rsquo;s not the end of the world. At worst, the user&rsquo;s Stripe data would be requested on the fly and the page would be slower than usual. But the majority of the time, the request is fast because the data&rsquo;s been cached beforehand.</p>

<p>What other jobs have you used Sucker Punch for?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Absolutes as an AntiPattern]]></title>
    <link href="http://brandonhilkert.com/blog/absolutes-as-an-antipattern/"/>
    <updated>2014-09-28T22:35:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/absolutes-as-an-antipattern</id>
    <content type="html"><![CDATA[<p>It’s been awhile since my last post — almost 2 months to be specific. A trip to Portugal, getting sick and a minor run-in with a table saw made it challenging to post anything for the last couple weeks. But I’d be lying if I said I was itching to write.</p>

<p>During that time, I didn’t have anything screaming to be talked about. I have a long list of “decent post” topics, but none of them got me particularly excited. Until today…</p>

<!--more-->


<p>I stumbled on a blog post related to Rails’s upcoming <a href="http://edgeguides.rubyonrails.org/active_job_basics.html">Active Job feature</a>. While demonstrating the syntax for specifying the adapter, there was comment in the code snippet that said <em>“inline and other worse options”</em>. This caught me by surprise and bummed me out at the same time. Not only because I’m the author of <a href="https://github.com/brandonhilkert/sucker_punch">one of them</a>, but because there are a handful of background processing libraries in Ruby that are really good.</p>

<p>So, naturally, I pinged the author and mentioned the comment might be sending the wrong message. He responded with “I consider sidekiq to be the best background processing tool available for Ruby.” And then later, <em>“sidekiq is significantly better that delayed_job and resque. You’re welcome to disagree”</em>.</p>

<p><em>Note: The responses above illustrate a general sentiment. By no means is this post focused on the individual that said them.</em></p>

<p>The thing is, I don’t completely disagree. As you probably already know, I’m a huge fan of of <a href="http://sidekiq.org/">Sidekiq</a>. I’ve contributed to the project and believe Sidekiq’s author, <a href="https://www.mikeperham.com/">Mike Perham</a> is not only a great leader in the Ruby community, but a great example of how to manage and lead open source projects well.</p>

<p>However, those responses reminded me how damaging absolutes can be. You’ve probably heard it before:</p>

<blockquote><p>“we can <strong>ABSOLUTELY NOT</strong> do x, y and z”</p></blockquote>

<p><em>Why not? Will the world end? How do I know?</em></p>

<p>or, what about:</p>

<blockquote><p>“this feature needs to go out tomorrow, no excuses”</p></blockquote>

<p><em>What if there is an excuse? What if it’s not ready? Will I be fired? Will our company go under?</em></p>

<p>There are trade-offs to every decision made. While some options may not be ideal, they may still work, perhaps just not as well.</p>

<p>Absolutes beg the toddler question, <em>”why?”</em>. <em>Why won’t that language X work?</em> <em>Why can’t we use Y?</em>. If you don’t know the answer to those questions, you’re doing yourself a disservice by not asking. Maybe the person has thoroughly researched the topic to come up with those conclusions. But, maybe, they haven’t.</p>

<p>I’ve noticed those who do exhaustive research on a topic tend to present the information in a different manner. They’re confident the facts they found will prove their case and seem to present their findings less defensively. No, <em>”it has to be done like this”</em>. More like, <em>“I found a few ways to fix the problem and here’s why I think option 1 might be the best solution. What do you think?”</em>.</p>

<p>Whether you follow agile or any other methodology, predictions and absolutes have no place in conversations. There are plenty of examples of failed software projects. I’m pretty sure all of them featured people promising the work would be done in time and under budget. Buuuuuuut, it wasn’t.</p>

<h2>Background Jobs for the Big Boys</h2>

<p>Delayed Job was the first Ruby background processing library I used. I remember feeling badass that I was doing all this complicated stuff in the background. But at some point, there we so many jobs and so much activity that pushing and pulling jobs out of the primary data store wasn’t efficient. Reads from the web UI would slow down (and ultimately stop) and users would bail. Unfortunately, I couldn’t pop up a message and say, <em>”hey, hope you don’t mind, but I’m doing some pretty crucial shit in the background here, so you’re experience is gonna be sucky for a bit! sorry :(”</em>.</p>

<p>So, at the time, Resque was the next logical transition. I migrated the previously written jobs from Delayed Job to Resque and experienced a new level of <em>bad ass</em>. Fast forward 4 years — I still work on projects using Resque. Needless to say, it’s a pretty awesome piece of open source software.</p>

<p>A few years ago, Sidekiq came along. While I didn’t know much about multi-threading code in Ruby, I tried it on a side project and was floored at the results. Those 6 Heroku workers that I’d been paying for could be compacted in to 1?!?! And on top of that, I only needed 1 worker that had 25 workers working against the queue?!?!</p>

<p>But then one day, I dropped it in to a project that was using MongoDB and MongoMapper as ORM and things didn’t go so well. In the end, MongoMapper wasn’t thread-safe, which is a requirement of Sidekiq worker code. So in that case, was Sidekiq the best tool for the job? While I would’ve loved to use Sidekiq on that project, it certainly (like the absolute there…) wasn’t the right tool for <em>that</em> job.</p>

<p>And what about when I first started with Delayed Job…we were a small startup with limited cash. While it seems silly to balk over an extra $35 Heorku dyno, it was $35 that could’ve gone towards something else. Not to mention the extra Redis instance, along with the expertise to make sure the thing didn’t fall over and die. Was Sidekiq (or Resque for that matter) the best tool for that job? Nope!</p>

<p>Fast forward a few years, I had the need for an in-process background processing library, so <a href="http://brandonhilkert.com/blog/why-i-wrote-the-sucker-punch-gem/">I wrote one</a>. That need was driven off the motivation above — needing to minimize cost and complexity. Would Sidekiq have worked for that project? Of course! In fact, it was using Sidekiq for a year or so before I transitioned the jobs to use Sucker Punch.</p>

<h2>Use Cases</h2>

<p>At this point, you should be noticing a trend, right? The examples above were unique use cases with a unique set of requirements and limitations. Sure, if every project I worked on had unlimited resources (both time and money), Sidekiq would be probably be my go-to the majority of time (even when writing that sentence I hesitated and almost wrote “all the time”).</p>

<p>But I hesitate now. Because I remember learning about the new cool things and thinking, <em>”This is the best! There’s no way I’ll never not use it”</em>. And when I would talk to other developers, I would rave about how <em>X</em> is the best for <em>Y</em>. And now I realize I was a dummy for doing that. There’s no way I could’ve made that judgement for someone else and their work. What I really should’ve said was, <em>”I tried [insert fancy new gem/technique] for the first time the other day. It worked really well for doing X in my project that does Y”</em>. That definitely doesn’t sound as exciting, but it was the truth.</p>

<p>I feel fortunate to get to write Ruby everyday. It’s incredibly expressive, which is why the debate over the countless ways to do something is great. Does the code express the right intent? For your method, it might. But for mine, it might express the complete opposite. The good news is, that’s OK. Both versions will work and the fact that we can have conversations like that is a praise for the language itself. I prefer to have the opportunity to have that conversation about style, rather than a language more black and white. Maybe it’s the creative in me, but it seems like no 2 Ruby solutions will be identical and that’s one of the things I love most about writing Ruby.</p>

<p>We often joke about the stack overflow post that starts with <em>“I’m thinking about learning Rails…is it better than PHP?”</em>. Or even more relevant today, <em>”Which javascript framework should I use?”</em>.</p>

<p>And then there’s the guy who comes along and is all like, <em>”Let’s back up, what are you doing and why do you absolutely need a FRAMEWORK????”</em>. While I used to ignore those types of comments, they’re the kind that I think about now and find myself typing. And that has me wondering…why the change?</p>

<h2>Experience, Experience, Experience</h2>

<p>I got to thinking about how I felt when I was first learning to program. When I started to feel comfortable with Rails, my confidence was through the roof. But at the same time, my naivety was at an all time high. I had had minimal experiences with software systems that were either critical or heavily-loaded. But having found Resque, I felt like I could solve the world’s problems. This is somewhat of an exaggeration, but not too far off. I realized that, as it relates to my technical career, my naivety is doing this related to time:</p>

<p><img class="center" src="/images/absolutes/naivety-graph.png" title="&ldquo;Graph of Naivety over Time&rdquo;" ></p>

<p>The less naivety, the more options and, naturally, certainty takes a nose dive:</p>

<p><img class="center" src="/images/absolutes/certainty-graph.png" title="&ldquo;Graph of Certainty over Time&rdquo;" ></p>

<p>The more I learn about programming in general, the more questions I have. Fortunately, experiences have brought me to a point where I can fairly weigh the use of Sucker Punch or Delayed Job for a particular use case. I’m not sure projecting absolutes from up high does anyone any good. Beginners will take it as the word and spread the message to others they come across.</p>

<p>Use cases are real. And the less we force our own biases on people, the faster they’ll realize experience is key and the random guy behind the cat avatar on Stack Overflow might actually be asking the right questions — even if they are convoluted.</p>

<p>Next time you hear an absolute, ask <em>”Why?”</em>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Reloader: A Lesser Known Railtie Hook]]></title>
    <link href="http://brandonhilkert.com/blog/rails-reloader-a-lesser-known-railtie-hook/"/>
    <updated>2014-04-21T19:48:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/rails-reloader-a-lesser-known-railtie-hook</id>
    <content type="html"><![CDATA[<p>I recently wrote <a href="http://brandonhilkert.com/books/build-a-ruby-gem/?utm_source=bh-come&amp;utm_medium=web&amp;utm_campaign=reloader">a book about integrating with Rails from a Ruby gem</a>, which specifically touched on using a <a href="http://api.rubyonrails.org/classes/Rails/Railtie.html">Railtie</a> to extend <code>ActiveRecord</code>, <code>ActionController</code> and <code>ActionView</code> . While these are the 3 more popular Rails libraries, there’s plenty others <a href="http://guides.rubyonrails.org/configuring.html">that are configurable</a>.</p>

<p>A <a href="https://github.com/brandonhilkert/sucker_punch/issues/49">recent issue</a> in <a href="https://github.com/brandonhilkert/sucker_punch">Sucker Punch</a> caused me to go digging through the Rails source code. Ultimately, the <code>to_prepare</code> method on <code>ActionDispatch::Reloader</code> resolved the issue, but I surprised was to find very little documentation about it.</p>

<!--more-->


<h2>The Problem</h2>

<p><a href="https://github.com/brandonhilkert/sucker_punch">Sucker Punch</a> lazily creates the <a href="https://celluloid.io/">Celluloid</a> pools used for background job queues. For the purpose of keeping track of the queues already initialized, Sucker Punch makes use of the <a href="https://github.com/celluloid/celluloid/wiki/Registry">Celluloid Registry</a>. Think of it as a class-level hash.</p>

<p>This works swimmingly in production, but not so much in development. Rails makes our lives easier by reloading code in between requests while in development, due to this setting in <code>config/environments/development.rb</code>:</p>

<p><code>
  config.cache_classes = false
</code></p>

<p>Without it, we’d be forced to restart the server after almost every request. If that sounds like a giant PITA to you, I whole heartedly agree!</p>

<p>So now you make your awesome job class, do some background work (send an email for example) and reload the page and boom:</p>

<p><code>``
Celluloid::PoolManager: async call</code>perform` aborted!
ArgumentError: A copy of SendInvitationJob has been removed from the module tree but is still active!</p>

<pre><code>    gems/activesupport-4.0.3/lib/active_support/dependencies.rb:446:in `load_missing_constant'
    gems/activesupport-4.0.3/lib/active_support/dependencies.rb:184:in `const_missing'
    my-app/app/jobs/send_invitation_job.rb:6:in `block in perform'
</code></pre>

<p>```</p>

<p>The Celluloid registry still has reference to a the original <code>SendInvitationJob</code> class when it was initialized, however, reloading the code has caused the original reference to disappear and all hell breaks loose when the queue key is fetched to send another job to the class.</p>

<p>In my head, it made sense for the queues to be cleared out upon every request in development. In general, because Sucker Punch doesn’t have persistent queues, the best use case is for quick one-off jobs that aren’t extremely important — email and logging come to mind. Since both of these examples are typically pretty speedy, it’s unlikely there will be a huge job backup upon subsequent requests.</p>

<p>I knew what I wanted, but didn’t know how to accomplish it.</p>

<h2>The Solution</h2>

<p>Knowing the issue was related to the setting <code>config.cache_classes = false</code> in the development environment, I broke open the Rails source code and searched for <code>cache_classes</code>. The first result was the <a href="https://github.com/rails/rails/blob/master/actionpack/lib/action_dispatch/middleware/reloader.rb"><code>ActionDispatch</code> reloader middleware</a>. Fortunately, there’s a very descriptive comment at the top of the class:</p>

<p><code>
  # By default, ActionDispatch::Reloader is included in the middleware stack
  # only in the development environment; specifically, when +config.cache_classes+
  # is false. Callbacks may be registered even when it is not included in the
  # middleware stack, but are executed only when &lt;tt&gt;ActionDispatch::Reloader.prepare!&lt;/tt&gt;
  # or &lt;tt&gt;ActionDispatch::Reloader.cleanup!&lt;/tt&gt; are called manually.
</code></p>

<p>This functionality is exactly what I needed!. From here, I just needed to know what callbacks were valid. A few lines in to the class are the following methods:</p>

<p>```</p>

<pre><code># Add a prepare callback. Prepare callbacks are run before each request, prior
# to ActionDispatch::Callback's before callbacks.
def self.to_prepare(*args, &amp;block)
  unless block_given?
    warn "to_prepare without a block is deprecated. Please use a block"
  end
  set_callback(:prepare, *args, &amp;block)
end

# Add a cleanup callback. Cleanup callbacks are run after each request is
# complete (after #close is called on the response body).
def self.to_cleanup(*args, &amp;block)
  unless block_given?
    warn "to_cleanup without a block is deprecated. Please use a block"
  end
  set_callback(:cleanup, *args, &amp;block)
end
</code></pre>

<p>```</p>

<p><code>to_prepare</code> and <code>to_cleanup</code>…and like the comments say, they do exactly what you’d expect. Given that I wanted to clear our the Celluloid registry BEFORE each request, <code>on_prepare</code> is the golden ticket. Now I just needed to figure out how to clear the registry.</p>

<p>A quick glade over the <a href="http://www.rubydoc.info/gems/celluloid/Celluloid/Registry"><code>Celluloid::Registry</code> class documentation</a> shows some methods that might be of value. It turns out that these are instance methods for an instance of the <code>Celluloid::Registry</code> class. Unfortunately, when Celluloid boots, it instantiates a registry to use internally, so we need a way to get at that particular instance and clear it out. Sure enough, <a href="http://rubydoc.info/gems/celluloid/Celluloid/Actor#clear_registry-class_method">a class method to do just that in <code>Celluloid::Actor</code></a> is available.</p>

<p>Now that we all the pieces of the puzzle, it was time to put together a Railtie to trigger the behavior. Prior to needing this functionality, the Railtie in Sucker Punch was pretty simple:</p>

<p>```
module SuckerPunch
  class Railtie &lt; ::Rails::Railtie</p>

<pre><code>initializer "sucker_punch.logger" do
  SuckerPunch.logger = Rails.logger
end
</code></pre>

<p>  end
end
```</p>

<p>All it did was connect the logger to the existing Rails logger. Adding the callback to <code>ActionDispatch</code> looks like:</p>

<p>```
module SuckerPunch
  class Railtie &lt; ::Rails::Railtie</p>

<pre><code>initializer "sucker_punch.logger" do
  SuckerPunch.logger = Rails.logger
end

config.to_prepare do
  Celluloid::Actor.clear_registry
end
</code></pre>

<p>  end
end
```</p>

<p>Now when the Railtie is loaded, the <code>Celluloid::Actor.clear_registry</code> method is triggered before the reloading of code in the development environment, clearing out the Celluloid registry and allowing Sucker Punch to instantiate new job queues for each request.</p>

<h2>Summary</h2>

<p>I was unaware of any of these methods when the issue was submitted. Rather than throw my hands up and close the issue because it didn’t affect me, I thought through an approach that could work, and only then started to write code. And in fact, didn’t know what code to write!</p>

<p>Comments and well written code serve as great documentation. I probably wouldn’t have stumbled on <code>ActionDispatch::Reloader</code> without the detailed comments at the top of the class. Sure, I would’ve found the <code>cache_classes</code> line, but might not have given it more thought.</p>

<p>Next time you have a question about the syntax of a method or the order of its arguments, clone the repo (if it’s open source, of course) and do a search. I think you’ll be surprised at how quickly you can find what you’re looking for. My guess is you’ll also be pleasantly surprised at the other things you stumble upon in the process.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why I Wrote the Sucker Punch Gem]]></title>
    <link href="http://brandonhilkert.com/blog/why-i-wrote-the-sucker-punch-gem/"/>
    <updated>2014-03-13T13:56:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/why-i-wrote-the-sucker-punch-gem</id>
    <content type="html"><![CDATA[<p>_This is one of the final post leading up the the launch of the
[__Build a Ruby Gem Ebook__](/books/build-a-ruby-gem/?utm_source=bh-com&utm_medium=web&utm_campaign=launch),
which is now available for sale in [3 packages](/books/build-a-ruby-gem/?utm_source=bh-com&utm_medium=web&utm_campaign=launch),
including __14 chapters of code__ and over 2 hours of screencasts_.


</p>

<p>One of the simplest and most common application of background processing is sending emails outside of a web
request. And while background processing is pretty common, most existing Ruby background processing libraries require an additional process to execute these jobs, resulting in increased infrastructure costs.</p>

<p>At the time, I was working on an application hosted on Heroku, and the cost of an additional dyno ($35/month) wasn’t justified. The background jobs did very little more than send emails out of band. To me, the traditional solutions seemed like overkill. And with this, the idea of <a href="https://github.com/brandonhilkert/sucker_punch">sucker_punch</a> was born&hellip;</p>

<!--more-->


<h2>Ruby Background Processing Libraries</h2>

<p>Until I had heard of <a href="http://sidekiq.org/">Sidekiq</a>, <a href="https://github.com/collectiveidea/delayed_job/tree/master">delayed_job</a> and <a href="https://github.com/resque/resque">Resque</a> were the standard options for processing background jobs in Ruby. I&rsquo;ve used both and believe each has a great use case.</p>

<p>In my experience, it&rsquo;s easiest to start with delayed_job if you need background processing in your application. If and when the DB becomes your bottleneck, it&rsquo;s time to move on. Redis is a dependency of both Resque and Sidekiq, which increases the complexity and infrastructure maintenance, however, with <a href="https://addons.heroku.com/?q=redis">Heroku&rsquo;s hosted Redis
Add-ons</a>, this dependency is much less of a pain.</p>

<h2>My work on Sidekiq</h2>

<p>I previously wrote about my my <a href="http://brandonhilkert.com/blog/3-ways-to-get-started-contributing-to-open-source/">open source contributions</a> and how I got started. I had spent the previous several
months contributing to Sidekiq and learning more about concurrency patterns in Ruby.</p>

<p>Sidekiq is multi-threaded, which is the reason a single Sidekiq process is <a href="https://github.com/mperham/sidekiq/wiki/Testimonials">more
efficient</a> than a library like Resque. Although, nothing in life is free &ndash; care must be taken to ensure your jobs are thread-safe. A helpful <a href="https://github.com/mperham/sidekiq/wiki/Best-Practices">guide to writing thread-safe code</a> can be found on the Sidekiq wiki.</p>

<h2>Use Case</h2>

<p>I was working on <a href="http://defriendnotifierapp.com/">Defriend Notifier</a> and needed to notify users via email when their Facebook friend list changed. Using Sidekiq or any of the alternatives mentioned above certainly would’ve worked. In fact, the application originally used Sidekiq and functioned perfectly. However, as time went on, I decided the extra cost of the worker wasn’t justified, especially given that the application didn’t produce any revenue outside of advertising (very little…).</p>

<p>At the time, the only background processing library that didn’t require an additional background process was
<a href="https://github.com/mperham/girl_friday">girl_friday</a>, also written by <a href="https://twitter.com/mperham">Mike
Perham</a>, author of Sidekiq. While this solution worked for awhile, I found the syntax to be slightly non-intuitive and it felt a little dirty to pass around a global variable within the application
to manage a single job queue. I also experienced some memory leaks on Heroku as a result of switching to
girl_friday, but to be fair, I didn&rsquo;t spend much time determining the root cause. <em>Disclaimer: It very likely could’ve been due to code that I wrote</em>.</p>

<h2>Enter Celluloid</h2>

<p><a href="https://github.com/celluloid/celluloid">Celluloid</a> describes itself as an actor-based concurrent object
framework for Ruby. Celluloid is the guts behind Sidekiq and the reason why the multi-threaded Sidekiq code is so readable. Celluloid abstracts away the details of concurrency so your code doesn&rsquo;t have to worry about manually managing thread synchronization and object message queuing.</p>

<h2>Sucker Punch is born</h2>

<p>girl_friday was written several years ago — before Celluloid was created. Realizing the power of Celluloid,
I figured there was an opportunity for a new library that behaved like girl_friday, but utilized
Celluloid&rsquo;s more reliable multi-threading capabilities. And because Celluloid handles so much of the complexity, the gem itself would be relatively simple — really a DSL around enqueuing jobs to a <a href="https://github.com/celluloid/celluloid/wiki/Pools">Celluloid Pool</a>.</p>

<p>I <a href="https://twitter.com/brandonhilkert/status/292630123981729793">posed the question to Mike Perham</a> and he confirmed my suspicions.</p>

<p><img class="center" src="/images/sucker-punch-tweet.png" title="&ldquo;Sucker Punch Tweet&rdquo;" ></p>

<p>Fortunately, Celluloid had all of the functionality needed for background queues already built-in. While the
functionality was there, the usage syntax was awkward.</p>

<p>I spent the next few days creating a DSL around the Celluloid internals, thus making it feel more specific to
background queues.</p>

<p>Here’s the result of a typical job class:</p>

<pre><code>class LogJob
  include SuckerPunch::Job

  def perform(event)
    # do some other stuff to
    # record the event in the background
    puts "#{event} just happened"
  end
end
</code></pre>

<p>I deployed my sucker_punch-converted application code to production and gave it a week or so before I declared it a success. Once I realized sucker_punch was going to be a maintainable method for processing background jobs in a single web process, I added additional niceties like logging and queue configuration details that may be valuable for other use cases.</p>

<p>Have you tried <a href="https://github.com/brandonhilkert/sucker_punch">sucker_punch</a> yet? If so, I&rsquo;d love to know how it went and what you used it for&hellip;</p>
]]></content>
  </entry>
  
</feed>
