<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Brandon Hilkert]]></title>
  <link href="http://brandonhilkert.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://brandonhilkert.com/"/>
  <updated>2014-12-31T16:02:57-05:00</updated>
  <id>http://brandonhilkert.com/</id>
  <author>
    <name><![CDATA[Brandon Hilkert]]></name>
    <email><![CDATA[brandonhilkert@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Creating Rails Active Record Validation Contexts with Inheritance]]></title>
    <link href="http://brandonhilkert.com/blog/creating-rails-active-record-validation-contexts-with-inheritance/"/>
    <updated>2014-11-18T17:20:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/creating-rails-active-record-validation-contexts-with-inheritance</id>
    <content type="html"><![CDATA[<p>If you’ve used <code>validates</code> in a Rails Active Record model, you know they work great -- at least until the first bit of complexity arises. At that point, they can quickly morph in to a ball of conditional spaghetti convoluting the initial reason the validation was added in the first place.</p>




<p>I recently had an experience using <code>has_secure_password</code> where I wanted control the length of the user-supplied password. Adding a length validation to the password accessor invalidated existing records, so I was in a bit of a bind. In the end, I sub-classed the Active Record model to create a unique model made specifically for that context. This allowed me to inherit the core functionality from the model and sprinkle on existing validations for specific use cases. This was a new tactic for me and I’m still now sure how I feel about it. I like the fact that it removed complexity from the <code>User</code> model. This, in hopes, will keep the minimize the likelihood of it becoming a God object.</p>




<!--more-->




<h2>The Problem</h2>




<p>Using <code>has_secure_password</code> is a relatively easy way to add authentication to a Rails app. In order to disguise the plain text passwords, an <a href="https://github.com/rails/rails/blob/3bdf7b80a11dcb67b18553ff1fe0da82b0cffc20/activemodel/lib/active_model/secure_password.rb#L106">accessor for the plain <code>password</code></a> is added that encrypts it before saving.</p>




<p>The only true Active Record validation <code>has_secure_password</code> adds is a <a href="https://github.com/rails/rails/blob/3bdf7b80a11dcb67b18553ff1fe0da82b0cffc20/activemodel/lib/active_model/secure_password.rb#L68">confirmation of the password</a> — and only when the password is present. This allows us to create a user object without supplying a password, or maybe saving straight to the <code>password_digest</code> field, which is used to store the encrypted password in the database.</p>




<p>I wanted to enforce a minimum password length, because what good is a 1 character password (or 0 for that matter) ?!?!</p>




<p>The first thing I did was add this to the <code>User</code> model:</p>




<pre><code>validates :password, length: { minimum: 8 }
</code></pre>




<p>This works for new users, but not for those with a <code>password_digest</code> already. Attempting to updated an existing user produces the following error:</p>




<pre><code>ActiveRecord::RecordInvalid: Validation failed: Password is too short (minimum is 8 characters)
</code></pre>




<p>The next step was to conditionalize only on create:</p>




<pre><code>validates :password, length: { minimum: 8 }, on: :create
</code></pre>




<p>Except, that wasn’t right either because I’d definitely want to allow users to update their password, in which case, the length validation wouldn’t be enforced.</p>




<p>I found another <a href="http://quickleft.com/blog/rails-tip-validating-users-with-has_secure_password">post suggesting to allow <code>nil</code></a> using:</p>




<pre><code>validates :password, length: { minimum: 8 }, allow_nil: true
</code></pre>




<p>But, again, that felt weird and doesn’t read particularly well when you’re looking through the source trying to understand what condition would generate a <code>nil</code> password.</p>




<p>Other solutions included <a href="http://stackoverflow.com/a/6486345/2261909">mixing conditionals and checking model dirty state</a> and <a href="http://urgetopunt.com/rails/2012/11/12/validate-password-presence-has-secure-password.html">some combination of all of the above</a>.</p>




<p>I’m guessing some combination of the above would’ve worked, but something didn’t feel quite right. A quick glance over any of those solutions left me wanting something cleaner and more approachable. Because it’s a complex and tremendously important part of the app, I wanted to feel comfortable with the solution.</p>




<h2>The Solution</h2>




<p>I recently read <a href="https://leanpub.com/growing-rails"><em>Growing Rails Application in Practice</em></a>. The most interesting takeaway for me was the idea of sub-classing an Active Record object to exactly the problem described above.</p>




<p>Consider this…we have our <code>User</code> model with <code>has_secure_password</code>:</p>




<pre><code>class User &lt; ActiveRecord::Base
  has_secure_password
end
</code></pre>




<p>As we saw above, the variety of validation contexts made the standard ActiveModel validation awkward. What if we sub-class <code>User</code> and add the validation contexts for a specific use case? In our case, minimum length:</p>




<pre><code>class User::AsSignUp &lt; User
  validates :password, length: { minimum: 8 }
end
</code></pre>




<p>In this case, we’re create a separate model, for the purpose of signing up, and perhaps other user-related attribute management (profile, password reset, etc.).</p>




<p>Now, instead of passing the <code>User</code> model to the view from the controller, we pass an instantiated version of the new context-specific model class:</p>




<pre><code>def create
  @user = User::AsSignUp.find(current_user.id)
  …
end
</code></pre>




<p>Lastly, because the sub-class name is inferred within the form, we have to do one more thing to make the params are accessible on the <code>create</code> action using <code>params[:user]</code>. We’ll change the form from:</p>




<pre><code>&lt;%= form_for @user, url: user_confirm_path(@user.invitation_token) do |f| %&gt;
</code></pre>




<p>to:</p>




<pre><code>&lt;%= form_for @user, as: :user, url: user_confirm_path(@user.invitation_token) do |f| %&gt;
</code></pre>




<p>Because the remainder of the app operates fine without any need for the password validation, the <code>User</code> can be used where necessary and without worry of it becoming invalid because the password accessor isn’t present.</p>




<h2>Summary</h2>




<p>While sub-classing models in Rails is generally frowned upon, this use case is one of the few that felt reasonable. It feels relatively low cost and stays in isolation. I’d love to hear how you might have solved this problem. I looked and explored a handful of solutions. While others worked, none seems as expressive as the one above.</p>


<p>A form object using
<a href="http://api.rubyonrails.org/classes/ActiveModel/Model.html">ActiveModel</a> or
similar could&rsquo;ve been an alternative option. I didn&rsquo;t explore it for this
particular use case, mostly because I wanted to give this one a shot. However,
I have no doubt it would&rsquo;ve at least worked equally as well.</p>

<p>I should also point out that I&rsquo;m familiar with the built-in <a href="https://github.com/rails/rails/blob/master/activemodel/lib/active_model/validations.rb#L73">validation
contexts in ActiveModel</a>.
And for whatever reason, I&rsquo;ve not used them before. I&rsquo;ll probably give it a
shot on another occasion for comparison.</p>

<p>What are your thoughts on this technique?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Absolutes as an AntiPattern]]></title>
    <link href="http://brandonhilkert.com/blog/absolutes-as-an-antipattern/"/>
    <updated>2014-09-28T22:35:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/absolutes-as-an-antipattern</id>
    <content type="html"><![CDATA[<p>It’s been awhile since my last post — almost 2 months to be specific. A trip to Portugal, getting sick and a minor run-in with a table saw made it challenging to post anything for the last couple weeks. But I’d be lying if I said I was itching to write.</p>

<p>During that time, I didn’t have anything screaming to be talked about. I have a long list of “decent post” topics, but none of them got me particularly excited. Until today…</p>

<!--more-->


<p>I stumbled on a blog post related to Rails’s upcoming <a href="http://edgeguides.rubyonrails.org/active_job_basics.html">Active Job feature</a>. While demonstrating the syntax for specifying the adapter, there was comment in the code snippet that said <em>“inline and other worse options”</em>. This caught me by surprise and bummed me out at the same time. Not only because I’m the author of <a href="https://github.com/brandonhilkert/sucker_punch">one of them</a>, but because there are a handful of background processing libraries in Ruby that are really good.</p>

<p>So, naturally, I pinged the author and mentioned the comment might be sending the wrong message. He responded with “I consider sidekiq to be the best background processing tool available for Ruby.” And then later, <em>“sidekiq is significantly better that delayed_job and resque. You’re welcome to disagree”</em>.</p>

<p><em>Note: The responses above illustrate a general sentiment. By no means is this post focused on the individual that said them.</em></p>

<p>The thing is, I don’t completely disagree. As you probably already know, I’m a huge fan of of <a href="http://sidekiq.org/">Sidekiq</a>. I’ve contributed to the project and believe Sidekiq’s author, <a href="https://www.mikeperham.com/">Mike Perham</a> is not only a great leader in the Ruby community, but a great example of how to manage and lead open source projects well.</p>

<p>However, those responses reminded me how damaging absolutes can be. You’ve probably heard it before:</p>

<blockquote><p>“we can <strong>ABSOLUTELY NOT</strong> do x, y and z”</p></blockquote>

<p><em>Why not? Will the world end? How do I know?</em></p>

<p>or, what about:</p>

<blockquote><p>“this feature needs to go out tomorrow, no excuses”</p></blockquote>

<p><em>What if there is an excuse? What if it’s not ready? Will I be fired? Will our company go under?</em></p>

<p>There are trade-offs to every decision made. While some options may not be ideal, they may still work, perhaps just not as well.</p>

<p>Absolutes beg the toddler question, <em>”why?”</em>. <em>Why won’t that language X work?</em> <em>Why can’t we use Y?</em>. If you don’t know the answer to those questions, you’re doing yourself a disservice by not asking. Maybe the person has thoroughly researched the topic to come up with those conclusions. But, maybe, they haven’t.</p>

<p>I’ve noticed those who do exhaustive research on a topic tend to present the information in a different manner. They’re confident the facts they found will prove their case and seem to present their findings less defensively. No, <em>”it has to be done like this”</em>. More like, <em>“I found a few ways to fix the problem and here’s why I think option 1 might be the best solution. What do you think?”</em>.</p>

<p>Whether you follow agile or any other methodology, predictions and absolutes have no place in conversations. There are plenty of examples of failed software projects. I’m pretty sure all of them featured people promising the work would be done in time and under budget. Buuuuuuut, it wasn’t.</p>

<h2>Background Jobs for the Big Boys</h2>

<p>Delayed Job was the first Ruby background processing library I used. I remember feeling badass that I was doing all this complicated stuff in the background. But at some point, there we so many jobs and so much activity that pushing and pulling jobs out of the primary data store wasn’t efficient. Reads from the web UI would slow down (and ultimately stop) and users would bail. Unfortunately, I couldn’t pop up a message and say, <em>”hey, hope you don’t mind, but I’m doing some pretty crucial shit in the background here, so you’re experience is gonna be sucky for a bit! sorry :(”</em>.</p>

<p>So, at the time, Resque was the next logical transition. I migrated the previously written jobs from Delayed Job to Resque and experienced a new level of <em>bad ass</em>. Fast forward 4 years — I still work on projects using Resque. Needless to say, it’s a pretty awesome piece of open source software.</p>

<p>A few years ago, Sidekiq came along. While I didn’t know much about multi-threading code in Ruby, I tried it on a side project and was floored at the results. Those 6 Heroku workers that I’d been paying for could be compacted in to 1?!?! And on top of that, I only needed 1 worker that had 25 workers working against the queue?!?!</p>

<p>But then one day, I dropped it in to a project that was using MongoDB and MongoMapper as ORM and things didn’t go so well. In the end, MongoMapper wasn’t thread-safe, which is a requirement of Sidekiq worker code. So in that case, was Sidekiq the best tool for the job? While I would’ve loved to use Sidekiq on that project, it certainly (like the absolute there…) wasn’t the right tool for <em>that</em> job.</p>

<p>And what about when I first started with Delayed Job…we were a small startup with limited cash. While it seems silly to balk over an extra $35 Heorku dyno, it was $35 that could’ve gone towards something else. Not to mention the extra Redis instance, along with the expertise to make sure the thing didn’t fall over and die. Was Sidekiq (or Resque for that matter) the best tool for that job? Nope!</p>

<p>Fast forward a few years, I had the need for an in-process background processing library, so <a href="http://brandonhilkert.com/blog/why-i-wrote-the-sucker-punch-gem/">I wrote one</a>. That need was driven off the motivation above — needing to minimize cost and complexity. Would Sidekiq have worked for that project? Of course! In fact, it was using Sidekiq for a year or so before I transitioned the jobs to use Sucker Punch.</p>

<h2>Use Cases</h2>

<p>At this point, you should be noticing a trend, right? The examples above were unique use cases with a unique set of requirements and limitations. Sure, if every project I worked on had unlimited resources (both time and money), Sidekiq would be probably be my go-to the majority of time (even when writing that sentence I hesitated and almost wrote “all the time”).</p>

<p>But I hesitate now. Because I remember learning about the new cool things and thinking, <em>”This is the best! There’s no way I’ll never not use it”</em>. And when I would talk to other developers, I would rave about how <em>X</em> is the best for <em>Y</em>. And now I realize I was a dummy for doing that. There’s no way I could’ve made that judgement for someone else and their work. What I really should’ve said was, <em>”I tried [insert fancy new gem/technique] for the first time the other day. It worked really well for doing X in my project that does Y”</em>. That definitely doesn’t sound as exciting, but it was the truth.</p>

<p>I feel fortunate to get to write Ruby everyday. It’s incredibly expressive, which is why the debate over the countless ways to do something is great. Does the code express the right intent? For your method, it might. But for mine, it might express the complete opposite. The good news is, that’s OK. Both versions will work and the fact that we can have conversations like that is a praise for the language itself. I prefer to have the opportunity to have that conversation about style, rather than a language more black and white. Maybe it’s the creative in me, but it seems like no 2 Ruby solutions will be identical and that’s one of the things I love most about writing Ruby.</p>

<p>We often joke about the stack overflow post that starts with <em>“I’m thinking about learning Rails…is it better than PHP?”</em>. Or even more relevant today, <em>”Which javascript framework should I use?”</em>.</p>

<p>And then there’s the guy who comes along and is all like, <em>”Let’s back up, what are you doing and why do you absolutely need a FRAMEWORK????”</em>. While I used to ignore those types of comments, they’re the kind that I think about now and find myself typing. And that has me wondering…why the change?</p>

<h2>Experience, Experience, Experience</h2>

<p>I got to thinking about how I felt when I was first learning to program. When I started to feel comfortable with Rails, my confidence was through the roof. But at the same time, my naivety was at an all time high. I had had minimal experiences with software systems that were either critical or heavily-loaded. But having found Resque, I felt like I could solve the world’s problems. This is somewhat of an exaggeration, but not too far off. I realized that, as it relates to my technical career, my naivety is doing this related to time:</p>

<p><img class="center" src="/images/absolutes/naivety-graph.png" title="&ldquo;Graph of Naivety over Time&rdquo;" ></p>

<p>The less naivety, the more options and, naturally, certainty takes a nose dive:</p>

<p><img class="center" src="/images/absolutes/certainty-graph.png" title="&ldquo;Graph of Certainty over Time&rdquo;" ></p>

<p>The more I learn about programming in general, the more questions I have. Fortunately, experiences have brought me to a point where I can fairly weigh the use of Sucker Punch or Delayed Job for a particular use case. I’m not sure projecting absolutes from up high does anyone any good. Beginners will take it as the word and spread the message to others they come across.</p>

<p>Use cases are real. And the less we force our own biases on people, the faster they’ll realize experience is key and the random guy behind the cat avatar on Stack Overflow might actually be asking the right questions — even if they are convoluted.</p>

<p>Next time you hear an absolute, ask <em>”Why?”</em>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Patterns in a Rails Gemfile]]></title>
    <link href="http://brandonhilkert.com/blog/patterns-in-a-rails-gemfile/"/>
    <updated>2013-11-06T21:04:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/patterns-in-a-rails-gemfile</id>
    <content type="html"><![CDATA[<h2>Rails Rumble</h2>

<p>The <a href="http://railsrumble.com/">2013 Rails Rumble</a> concluded last week and like
in previous years, <a href="http://www.dwellable.com/">Dwellable</a> analyzed the <a href="http://www.dwellable.com/blog/Rails-Rumble-Gem-Teardown">Gemfiles of the submitted
projects</a>.</p>

<p>While it&rsquo;s not an indication of the only gems used in the Ruby community, it&rsquo;s
a pretty good summary of the most common needs in a typical Rails app.</p>

<ul>
<li><p>The majority of the projects used Rails defaults of
<a href="http://coffeescript.org/">Coffeescript</a>, <a href="http://sass-lang.com/">Sass</a>,
<a href="http://jquery.com/">jQuery</a>, and
<a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/erb/rdoc/ERB.html">ERB</a></p></li>
<li><p>Only 37% of the projects used <a href="http://getbootstrap.com/">Bootstrap</a>. I
thought this number would be higher. It feels like every MVP out there starts
with bootstrap.</p></li>
</ul>


<!--more-->


<ul>
<li><p>Only 33% used HAML. I thought this number would be higher as well. I&rsquo;m not a
huge fan of HAML, but it seems like it&rsquo;s the default templating language for
most Rails developers I&rsquo;ve worked with.</p></li>
<li><p>Around 1/3 of the projects turned off
<a href="https://github.com/rails/turbolinks/">Turbolinks</a>. I&rsquo;ve spent a little bit
of time using Turbolinks and while I&rsquo;m not opposed to it, there are a handful
of common practices that I was used to that didn&rsquo;t work with Turbolinks. I
suspect this was the case for many teams and just chose to turn it off out of
frustration or interest in making progress elsewhere. I&rsquo;ve definitely done
this in the past when I just wanted to get something out the door.</p></li>
<li><p>Usage of <a href="http://www.mysql.com/">MySQL</a> and
<a href="http://www.postgresql.org/">Postgres</a> was even. This, to me, is great
news. The more Postgres is used in the community, the more available it will
be hosting services (<a href="https://www.heroku.com/">Heroku</a> has done a great job
promoting the usage of Postgres).</p></li>
<li><p>Javascript front-end frameworks were barely used. 7% is a pretty small
number. Part of me believes this number would&rsquo;ve been larger if the teams had
more time to devote to development, but with many people believing JS is the
future of the web, I&rsquo;m still surprised more projects weren&rsquo;t largely
JS-based. With the 1.0 release of <a href="http://emberjs.com/">Ember.js</a> behind us, perhaps
next year will support a continuing movement towards these types of frameworks.</p></li>
<li><p><a href="http://sidekiq.org/">Sidekiq</a> was the overwhelming favorite for background
jobs! I love Sidekiq (full disclaimer: I&rsquo;m a contributor), but I thought
usage of <a href="https://github.com/resque/resque">Resque</a> would be closer to that
of Sidekiq.</p></li>
</ul>


<h2>My Gemfiles</h2>

<p>Most developers have a handful of gems that they rely on during development.
This got me thinking about the gems that I most commonly used in my own projects.</p>

<p>I tend to write a lot of small apps, so I create new Rails projects all the
time. The first hour is always spent setting up the project with the gems I&rsquo;m
most familiar with. I know there are some tools that could make this process
easier (<a href="http://edgeguides.rubyonrails.org/rails_application_templates.html">Rails
templates</a>
and <a href="https://github.com/drnic/appscrolls">AppScrolls</a> ), but I haven&rsquo;t spent
the time to implement them in to my workflow.</p>

<p>Below is the Gemfile of an app I recently started:</p>

<p>``` ruby Gemfile
source &lsquo;<a href="https://rubygems.org">https://rubygems.org</a>&rsquo;</p>

<p>ruby &lsquo;2.0.0&rsquo;
gem &lsquo;rails&rsquo;, &lsquo;4.0.1&rsquo;</p>

<p>group :production do
  gem &lsquo;pg&rsquo;
  gem &lsquo;rails_12factor&rsquo;
end</p>

<p>group :test do
  gem &lsquo;factory_girl_rails&rsquo;
  gem &lsquo;capybara&rsquo;
  gem &lsquo;selenium-webdriver&rsquo;
  gem &lsquo;database_cleaner&rsquo;
  gem &lsquo;shoulda-matchers&rsquo;
end</p>

<p>group :development do
  gem &lsquo;quiet_assets&rsquo;
  gem &lsquo;rails_best_practices&rsquo;
  gem &lsquo;rack-mini-profiler&rsquo;
  gem &lsquo;bullet&rsquo;
  gem &lsquo;better_errors&rsquo;
end</p>

<p>group :development, :test do
  gem &lsquo;rspec-rails&rsquo;
  gem &lsquo;pry&rsquo;
  gem &lsquo;sqlite3&rsquo;
end</p>

<p>gem &lsquo;sass-rails&rsquo;, &lsquo;~> 4.0.0&rsquo;
gem &lsquo;uglifier&rsquo;, &lsquo;>= 1.3.0&rsquo;
gem &lsquo;coffee-rails&rsquo;, &lsquo;~> 4.0.0&rsquo;
gem &lsquo;jquery-rails&rsquo;
gem &lsquo;turbolinks&rsquo;
gem &lsquo;anjlab-bootstrap-rails&rsquo;, :require => &lsquo;bootstrap-rails&rsquo;,</p>

<pre><code>                          :github =&gt; 'anjlab/bootstrap-rails'
</code></pre>

<p>gem &lsquo;font-awesome-rails&rsquo;
gem &lsquo;unicorn&rsquo;</p>

<p>gem &lsquo;sidekiq&rsquo;, require: &ldquo;sidekiq/web&rdquo;
gem &lsquo;sinatra&rsquo;
gem &lsquo;yajl-ruby&rsquo;, require: &lsquo;yajl/json_gem&rsquo;
gem &lsquo;newrelic_rpm&rsquo;
```</p>

<p>A few comments:</p>

<ul>
<li><p>Most of my apps end up on Heroku, at least to start, so, for ease, I tend to
developing locally using <a href="http://www.sqlite.org/">SQLite</a>, while using
Postgres on Heroku. As far as deployments go, I haven&rsquo;t seen any easier than Rails on Heroku.</p></li>
<li><p>My testing stack is what I would consider to be the standard
<a href="https://github.com/rspec/rspec">Rspec</a> setup with integration specs using
Capybara. I never got on the Cucumber bandwagon. I&rsquo;ve experimented with using
<a href="http://docs.seattlerb.org/minitest/">Minitest</a>, but I always end up back
with Rspec for one reason or another. Mostly, for no other reason than I&rsquo;m more comfortable with Rspec and can things done faster as a result.</p></li>
<li><p>I&rsquo;ve found <a href="https://github.com/flyerhzm/bullet">bullet</a> and
<a href="https://github.com/MiniProfiler/rack-mini-profiler">rack-mini-profiler</a> to
be essential for optimizing SQL and notifying me of the poor decisions I&rsquo;ve
made with regards to database calls. There&rsquo;s really no downside to trying
either of these. Give them a shot if you haven&rsquo;t!</p></li>
<li><p>I&rsquo;m still baffled that the logs from assets are so noisy.
<a href="https://github.com/evrone/quiet_assets">quiet_assets</a> removes this noise
allowing you to focus on the logs that matter.</p></li>
<li><p>I typically add <a href="http://fontawesome.io/">Font Awesome</a> and bootstrap to
start. The above includes 2 gems that merge these assets in to the Rails
<a href="http://guides.rubyonrails.org/asset_pipeline.html">asset pipeline</a>
seamlessly.</p></li>
<li><p>I love the <a href="http://pryrepl.org/">Pry</a> gem. I probably use less than 10% of
its designed functionality. But, to me, it&rsquo;s king of debugging both live
requests and tests. I used to use the debugger gem, but got frustrated with
its dependencies when using different versions of Ruby. The pry gem has never
been a problem in that regard.</p></li>
</ul>


<p>When I encounter code I&rsquo;m not familiar with, the Gemfile is often one of the
first places I explore to feel out what&rsquo;s going on. It&rsquo;s almost like a personal signature. There are so many gems, and so little time&hellip;I
feel like I&rsquo;m just scratching the surface for awesome functionality.</p>

<p>Leave a comment let me know what your favorite gems are!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build something]]></title>
    <link href="http://brandonhilkert.com/blog/build-something/"/>
    <updated>2013-10-29T20:10:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/build-something</id>
    <content type="html"><![CDATA[<p><em>A variation of this post originally appeared on the <a href="http://railsmasterclass.com/">Rails Masterclass</a>
newsletter.</em></p>

<p>Learning new technologies can be a challenge. With books, forums, videos, blog
posts&hellip;where do you start?!?! I&rsquo;ve used all these resources in the past and
only one thing has reliably led to me to really learn the concepts &ndash; building something REAL!</p>

<h2>How I learned Ruby and Rails</h2>

<p>Several years ago, I was learning both <a href="https://www.ruby-lang.org/en/">Ruby</a>
and <a href="http://rubyonrails.org/">Rails</a> and trying to figure out which books were
worth the time. I ended up starting with <a href="http://pragprog.com/book/rails4/agile-web-development-with-rails-4">Agile Web Development with
Rails</a>,
which was a fantastic introduction to the features and benefits you&rsquo;ll get from
learning the Rails framework. However, like many other books, it guides you
through building a website with little real world value &ndash; an e-commerce
shopping cart (you&rsquo;ve heard this one before, right???).  The concepts in the
book generally apply to other products built with Rails, but it was sometimes
hard for me to see their value elsewhere.  I found that the books and articles often skipped over things that were fairly
trivial for a more experienced developer, but essential to get a real world application out the door.</p>

<!--more-->


<h2>The best way to learn (with a catch)</h2>

<p>I propose you build something&hellip;anything really. But it would be more useful if
the thing you build is useful to either you, someone else, or even
better&hellip;everyone! But there&rsquo;s a catch&hellip;whatever you build, you must not only
put it out there for the world to see, but you must share it in whatever way
you feel comfortable.</p>

<h2>My Craigslist Scraper</h2>

<p>A few years ago, I was in the market for a new job. I built a small Craigslist
scraper that searched for &ldquo;my perfect job&rdquo; and had it notify me via email
whenever it found a similar post.</p>

<p>The process of creating this little scraper did two things for me. First, it
allowed me to learn (I wrote it in Perl and at the time knew very little about
the language&hellip;). And second, it saved the 15 minutes or so it would take me
each day to sift through the new job postings. It really was a win-win!</p>

<h2>Start to Finish</h2>

<p>It&rsquo;s easy to copy and paste code snippets from a blog post or book. It&rsquo;s much
harder to see these applications through to the point where they&rsquo;re useful. Who
cares if no one uses it? The value you get from seeing your application code
all the way to the point of production is exponentially greater than the value
of having run &ldquo;rails server&rdquo; on your local development machine.</p>

<p>Questions such as &ldquo;How will I log and be notified of errors?&rdquo; and &ldquo;How will I
backup my production data store?&rdquo; take time and thought to answer.</p>

<p>There are so many easy to use
<a href="http://en.wikipedia.org/wiki/Platform_as_a_service">PAAS</a> platforms
now-a-days, even if you&rsquo;re not the devops guru that you aspire to be, you too
can have production code running with minimal effort for FREE!
<a href="https://www.heroku.com">Heroku</a> is a great example of a place that you can
host your Rails applications without hassle or cost. If you have an application
running locally that you&rsquo;d like to share, hosting it at Heroku is a no-brainer.</p>

<p>If you have more aspirational goals of managing servers and understanding what
makes a Rails application tick, servers at <a href="https://www.digitalocean.com/">Digital
Ocean</a>, <a href="https://www.linode.com/">Linode</a>, and
<a href="http://www.rackspace.com/">Rackspace</a> can be extremely cost effective.</p>

<h2>Dogfooding</h2>

<p>Building an application that can save you time in your daily routine (ie. task
tracker, appt. reminder, etc.) is a great first step to learning more. It&rsquo;s
also very possible that if the application helps you, it could help other
people. I&rsquo;ll leave the marketing talk for another time, but stepping back and
being an actual user of your application will cause you to look at it in a very
different light. It&rsquo;s likely that you&rsquo;ll find ways to drastically improve your
application within the first 10 minutes of usage.</p>

<h2>Sharing (this is my favorite part)</h2>

<p>You&rsquo;ve now spent several weeks/months building something interesting &ndash; tell the
world about it. Tweet about it, post it to your local user group mailing list,
email your friends, anything&hellip;the more people that see it, the better. Like
dogfooding, you&rsquo;ll get valuable feedback that you might not have gotten
otherwise.</p>

<p>I can hear all the perfectionists now&hellip;&ldquo;I don&rsquo;t want to share it until it&rsquo;s
perfect&rdquo;. Having worked on a number of large applications, the candid truth is
that it will <strong>NEVER</strong> be perfect. The feedback you&rsquo;ll get sooner is more
valuable than the time you&rsquo;ll waste by attempting perfection. Besides, I have a
feeling that most the features you thought you <em>had</em> to have before you
launched are unimportant to the people that actually want to use your
application.</p>

<p>There&rsquo;s a more subtle point to sharing your new application&hellip;subconsciously
you&rsquo;re likely not going to share something that you think is crappy. If your
goal is to ultimately share what you&rsquo;ve built, you&rsquo;ll put the work in to make
it worthy of sharing, and in the process, learn about the finer details of
releasing a web application in to the wild, not just a basic shopping cart that
has minimal real-world value.</p>

<h2>Where to go from here?</h2>

<p>Knowing what you want to build is easier said than done. I keep a list of ideas
that I ultimately want to build someday. Some have very little use outside my
own world and others probably have potential to be used by other people, but
either way, bringing these ideas to life with new technologies or concepts
really helps me to solidify their real-world value.</p>

<p>If you don&rsquo;t have ideas, a quick Google search for &ldquo;startup ideas&rdquo; will provide
you with some very interesting results. However, I&rsquo;d think about the things
you&rsquo;re doing everyday and ask yourself if any of them can be solved, or aided,
with software. If the answer is &ldquo;yes&rdquo; to any of them, you have yourself a great
candidate.</p>

<p>I&rsquo;d love to hear about what you&rsquo;re building and the challenges you&rsquo;re facing.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3 Ways To Get Started Contributing To Open Source]]></title>
    <link href="http://brandonhilkert.com/blog/3-ways-to-get-started-contributing-to-open-source/"/>
    <updated>2013-10-15T16:30:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/3-ways-to-get-started-contributing-to-open-source</id>
    <content type="html"><![CDATA[<p><em>I&rsquo;m writing a <a href="http://brandonhilkert.com/books/build-a-ruby-gem/?utm_source=bh-com&amp;utm_medium=web&amp;utm_campaign=contribute-post">book on building a Ruby
gem</a>. If you&rsquo;re interested in sample chapters and a 20% discount code when the book launches, <a href="http://brandonhilkert.com/books/build-a-ruby-gem/?utm_source=bh-com&amp;utm_medium=web&amp;utm_campaign=contribute-post">sign up here</a>
. The book will include tips for managing and contributing to open source
projects.</em></p>

<p>Towards the end of 2012, I began feeling like a had a good grip on the Ruby
language. As mentioned in a <a href="/blog/the-technology-hump/">previous
post</a>, I felt confident enough in my skills that
I could make a positive contribution to the open source community.</p>

<p>I learned a lot by watching certain projects and getting involved with others
and hope that my notes are helpful for you and your endeavors.</p>

<h2>1. Fix a bug in an existing gem because it affects you</h2>

<p>My experience with <a href="/about">Meeteor</a> and <a href="/about">Spokely</a> caused me to move
FAST and break a lot of things along the way. Because of the pace, when I did
find a bug, I wasn&rsquo;t great at contributing code back to the source repository.
In many cases, my fixes were brute force <a href="http://en.wikipedia.org/wiki/Monkey_patch">monkey
patches</a> or something else that I
would probably be pretty embarassed about today.</p>

<!--more-->


<p>Some of the more extreme cases caused me to <a href="https://github.com/brandonhilkert/jquery-tokeninput">fork a
gem</a> and <a href="https://github.com/brandonhilkert/jquery-tokeninput/commits/master">commit
changes</a> to
my version of the repo and reference my version of them gem in the application.
Thinking back on this now, doing so probably did more harm than good. The
downside is that it creates yet another fork of the gem and it also suffers
from lack of future updates by the original author. Unless, of course, you&rsquo;re
diligent about merging in changes from master, but let&rsquo;s admit, this never
happens.</p>

<p>In hindsight, I should have spent the extra 30 minutes to write organized and
tested code in order to contribute back to the original project. If I
experienced the bug, it&rsquo;s likely that others would too, if they hadn&rsquo;t already.</p>

<p><em>Be sure to review the Github issues for other reports of the bug.
It&rsquo;s possible there may already be an open pull request, thus
saving you the effort of preparing the fix.</em></p>

<h2>2. Improve an existing gem to learn more about the subject</h2>

<p>It&rsquo;s best to head towards projects that you either have passion for or use
heavily.  If you&rsquo;re unsure of the level of effort required for an issue or
feature, ask the gem&rsquo;s author. Also, before you prepare that killer feature
that&rsquo;s going to take you 2 weeks to prepare, make sure it&rsquo;s known and approved
by the author. It&rsquo;s a bummer to put in all that work only to learn that it&rsquo;s
not something the author is interested in adding and supporting. They&rsquo;ll likely
be happy for the extra help and point you in the right direction.</p>

<p>For me, this was <a href="http://sidekiq.org/">Sidekiq</a>. I had been a long time user of
<a href="https://github.com/collectiveidea/delayed_job">Delayed Job</a> and
<a href="https://github.com/resque/resque">Resque</a>. When I first tried Sidekiq, I was
dumbfounded at how much faster it was because of its multi-threading
capabilities. I was also really surprised how easy it was to get started.
Sidekiq&rsquo;s author, <a href="https://twitter.com/mperham">Mike Perham</a>, has done a great job at
keeping the API similar to that of Resque, thus minimizing the pain of
switching.</p>

<p>Often, a popular gem will have a list of pending features to be written for
upcoming versions. If you can&rsquo;t find this list documented in the source code,
again, ask the gem&rsquo;s contributors. They&rsquo;ll likely have thought through upcoming
features and can make recommendations on how to get started.</p>

<p>There&rsquo;s no better way to learn than reading code. Sidekiq uses
Celluloid to handle the concurrency and for me, concurrency was an
afterthought. I realized this and figured by contributing, it would force me to
better understand the fundamental patterns of concurrency in Ruby.</p>

<p>I can hear the next question&hellip;how can you contribute to a codebase you want to
learn about but know nothing about?  At the time, Sidekiq&rsquo;s Web UI wasn&rsquo;t
great. Web applications are what I&rsquo;m good at, so I took it as an opportunity to
improve the Sidekiq Web UI, while I became more familiar with Sidekiq&rsquo;s
internals. I spent a few weeks <a href="https://github.com/mperham/sidekiq/contributors">playing with graphs and improving Sidekiq&rsquo;s
internal API</a> and was able to
make the Web UI significantly better than it was before I started.</p>

<p>That was the start of my contribution to Sidekiq and since then have learned
quite a bit more about what makes the system tick. It&rsquo;s by no means a straight
forward gem and probably one I wouldn&rsquo;t urge you to cut your teeth on, but
certainly a challenge and very well maintained.</p>

<h2>3. Create a new gem by extracting code that you commonly use</h2>

<p>Greenfielding Rails apps is exciting. It starts out as <code>rails new
my-awesome-new-app</code>. You boot the server only to be greeted by the default
index page. The next steps are a series of copying and pasting from previous
applications or blog posts on the subject of configuring a Rails app. Whichever
<a href="http://words.steveklabnik.com/rails-has-two-default-stacks">stack</a> you prefer,
there&rsquo;s generally a number of changes/additions that need to be made to kickstart the productivity.</p>

<p>Rather than paste in the same old code to handle &ldquo;______&rdquo; (insert your
favoritie super important feature), what better than to simply include a gem
that does it all for you. And what better person to create this gem than YOU!</p>

<p>On a previous project, I found myself calling the same view helper methods over
and over again, so I pulled it out into a
<a href="https://github.com/brandonhilkert/so_meta">gem</a> so I didn&rsquo;t have to worry
about copying the code across projects. It&rsquo;s a trivial example, but one that
can save you a lot of time and headache.</p>

<p>The ease of creating a gem is both a blessing and a curse for the community.
Ruby advocates writing code in a way that&rsquo;s modular, which tends to make
extracting that code to a gem pretty easy when done correctly. With a little
<a href="https://www.google.com/search?q=how+to+make+a+ruby+gem&amp;oq=how+to+make+a+ruby+gem">Google'ing</a>,
you can pretty quickly extract a feature that&rsquo;s already written and have it up
on RubyGems for the world to consume in no time.</p>

<h2>In summary</h2>

<p>I spent a fair amount of time trying to plot my entrace in to the Open Source
community. <a href="http://github.com">Github</a> has made it tremendously easy to not
only collaborate, but scour other products in search of code that might be
interesting to both learn and contribute to.</p>

<p>For those that write Ruby, I would urge you to avoid starting by contributing
to gems like Rails or other large codebases. Despite having plenty of work to
do, they&rsquo;re often hard to navigate and have quite a few idosyncrasies due to
their long and complex histories. It&rsquo;s also hard to know whether other people
are working on the same issue you might think is relatively trivial. There&rsquo;s
not much worse than putting in a few hard hours on a bug, only to have a pull
request fixing the same buy show up a few minutes before.</p>

<p>Start with a smaller project and figure out the path that works best for you.
Everyone is different, but that&rsquo;s what makes you so valuable to the open source
community. Work on things you love and make open source software better than
when you started.</p>

<p>What will your next open source project be?</p>
]]></content>
  </entry>
  
</feed>
