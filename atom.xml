<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Brandon Hilkert]]></title>
  <link href="http://brandonhilkert.com/atom.xml" rel="self"/>
  <link href="http://brandonhilkert.com/"/>
  <updated>2016-06-15T08:33:07-04:00</updated>
  <id>http://brandonhilkert.com/</id>
  <author>
    <name><![CDATA[Brandon Hilkert]]></name>
    <email><![CDATA[brandonhilkert@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails Progress Indicator Using Nprogress]]></title>
    <link href="http://brandonhilkert.com/blog/rails-progress-indicator-using-nprogress/"/>
    <updated>2016-04-29T09:44:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/rails-progress-indicator-using-nprogress</id>
    <content type="html"><![CDATA[<p>Contrary to popular opinion, I&rsquo;m a fan of <a href="https://github.com/turbolinks/turbolinks">Turbolinks</a>.
I leave it enabled in all my Rails applications. Most of the negative opinions I hear relate to it &ldquo;breaking&rdquo; third-party jQuery plugins. I say &ldquo;breaking&rdquo; because it&rsquo;s not <em>really</em> changing the plugin&rsquo;s behavior &mdash; just requires the plugin to be initialized differently.</p>

<!--more-->


<p>If you&rsquo;re upgrading to a newer version of Rails and have a bunch of legacy JavaScript code, I can imagine this being difficult. But if you&rsquo;re green-fielding a new application, there&rsquo;s no reason not to take advantage of it. I wrote extensively about <a href="http://brandonhilkert.com/blog/organizing-javascript-in-rails-application-with-turbolinks/">how to organize JavaScript in a Rails application with Turbolinks enabled</a>. If you&rsquo;re struggling to get your JavaScript code to work as expected on clicks through the application, take a look at that post. I continue to use that organization pattern for all my applications and it never lets me down.</p>

<p>With Turbolinks enabled, interacting with an application feels smooth and fast. No more full page refreshes.</p>

<p>Every once in awhile we&rsquo;ll stumble on a page request takes longer than others. Rather than having the user sit there thinking nothing is happening, we can offer better feedback through a loading progress bar, specifically <a href="http://ricostacruz.com/nprogress/">nprogress</a>. I&rsquo;ve found it to be the perfect companion to Turbolinks to create a great user experience.</p>

<h2>The Problem</h2>

<p>In a traditional web application, when we click a link or submit a form, we get a loading spinner where the favicon typically appears. We might also see text in the status bar saying &ldquo;Connecting&hellip;&rdquo; or &ldquo;Loading&hellip;&rdquo;. These are the loading indications that internet users have become accustomed to.</p>

<p>By adopting Turbolinks, we not longer get those loading feedback mechanisms because the request for the new page is asynchronous. Once the request is complete, the new content is rendered in place of the previous page&rsquo;s body element. For fast page loads, this isn&rsquo;t a problem. However, if you have applications like mine, every once in awhile, you might have a page request take a few seconds (reasons for this are beyond the scope of this article). In those cases, a user might click a link and sit there for 2-3 sec. without any indication the page is loading. While Turbolinks generally improves the user experience of our application, having no user feedback for several seconds is not ideal (ideally, you&rsquo;d want to address a page request that takes multiple seconds). This is where <code>nprogress</code> can help.</p>

<h2>The Solution</h2>

<p><a href="http://ricostacruz.com/nprogress/"><code>nprogress</code></a> is a progress loading indicator, like what you see on YouTube.</p>

<p>Like other JavaScript libraries, there&rsquo;s <a href="https://github.com/caarlos0/nprogress-rails">a Ruby Gem that vendors the code and includes it in the Rails asset pipeline</a>.</p>

<p>We&rsquo;ll first add <code>nprogress-rails</code> to our Gemfile:</p>

<figure class='code'><pre><code>gem "nprogress-rails"</code></pre></figure>


<p>Bundle to install the new gem:</p>

<figure class='code'><pre><code>$ bundle install</code></pre></figure>


<p>Now with <code>nprogress</code> installed, we need to include the JavaScript in our application. We&rsquo;ll do this by adding the following the <code>app/assets/javascripts/application.js</code> manifest:</p>

<figure class='code'><pre><code>//= require nprogress
//= require nprogress-turbolinks</code></pre></figure>


<p>We first include the <code>nprogress</code> JavaScript source, and then an adapter that&rsquo;ll hook the Turbolinks request to the progress indicator.</p>

<p><em>Note: If you&rsquo;re familiar with Turbolinks and its events, you&rsquo;ll recognize the <a href="https://github.com/caarlos0/nprogress-rails/blob/master/app/assets/javascripts/nprogress-turbolinks.js">events triggered</a>.</em></p>

<p>By default, the <code>nprogress</code> loading bar is anchored to the top of the browser window, but we need to include some CSS to make this work. Let&rsquo;s open the <code>app/assets/stylesheets/application.scss</code> manifest file and add the following:</p>

<figure class='code'><pre><code>*= require nprogress
*= require nprogress-bootstrap</code></pre></figure>


<p><em>Note: Including <code>nprogress-bootstrap</code> isn&rsquo;t necessary if you don&rsquo;t use <a href="http://getbootstrap.com/css/">Bootstrap</a> in your application. I typically do, so I&rsquo;m going to include it.</em></p>

<p>At this point, we&rsquo;ll have a working loading indicator. But what if we want to tweak the styles to match your application&rsquo;s theme?</p>

<h2>Customizing Nprogress Styles</h2>

<p>Because the <a href="https://github.com/caarlos0/nprogress-rails/blob/master/app/assets/stylesheets/nprogress.scss#L1"><code>nprgress</code> styles are Sass</a>, we can overwrite the variables for customization.</p>

<p>There are 3 variables available to overwite:</p>

<ul>
<li><code>$nprogress-color</code></li>
<li><code>$nprogress-height</code></li>
<li><code>$nprogress-zindex</code></li>
</ul>


<p>For <a href="https://www.bark.us/">Bark</a>, we have an aqua accent color with use throughout the site. It made sense for the <code>nprogress</code> loading indicator to be that same color.</p>

<p>Back in our <code>app/assets/stylesheets/application.scss</code>, I overwrote the variable before including the <code>nprogress</code> source code:</p>

<figure class='code'><pre><code>$nprogress-color: #37c8c9;

@import "nprogress";
@import "nprogress-bootstrap";</code></pre></figure>


<h2>Summary</h2>

<p>I&rsquo;ve found <code>nprogress</code> to be a great companion library to Turbolinks. The two libraries together provide a much better user experience over full page refreshes. Turbolinks helps asynchronously load the page content that&rsquo;s changing and <code>nprogress</code> gives the user feedback that their request is in progress. Now, even when a user has to suffer through multi-second page loads, at least they&rsquo;ll know it&rsquo;s not broken and don&rsquo;t have to click again.</p>

<p>The <a href="https://github.com/turbolinks/turbolinks/blob/master/src/turbolinks/progress_bar.coffee">latest version of Turbolinks has a progress bar
built-in</a>.
I&rsquo;m looking forward to removing the dependency if it performs similarly.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Guide to Ruby Gem Post-Install Messages]]></title>
    <link href="http://brandonhilkert.com/blog/ruby-gem-post-install-message/"/>
    <updated>2016-04-22T20:13:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/ruby-gem-post-install-message</id>
    <content type="html"><![CDATA[<p>As gem authors, one of the ways we can provide important information to users of our gems is through post-install messages. Let&rsquo;s explore what they are, how to set them up, what to include and when to use them.</p>

<!--more-->


<h2>What are Post-Install Messages?</h2>

<p>As Rubyists, we have plenty experiences installing gems. By running <code>gem install rails</code>, we&rsquo;re asking Rubygems to install the gem named <code>rails</code> on to our system.</p>

<p>The typical output of installing a gem with no other dependencies (assuming it completes successfully) is minimal:</p>

<figure class="code"><pre><code class="bash">$ gem install so_meta
Successfully installed so_meta-0.1
1 gem installed
</code></pre></figure>


<p>As you can see, we ran <code>gem install so_meta</code> and the output confirmed the install, with nothing more.</p>

<p>If you&rsquo;ve used the <a href="https://github.com/jnunemaker/httparty">HTTParty</a> gem, you&rsquo;ve probably seen the additional line of output it generates when you run <code>gem install httparty</code>:</p>

<figure class="code"><pre><code class="bash">$ gem install httparty
When you HTTParty, you must party hard!
Successfully installed httparty-0.13.7
1 gem installed
</code></pre></figure>


<p>Where did <code>When you HTTParty, you must party hard!</code> come from? It turns out the source of that text was a [post-install message defined in the <a href="https://github.com/jnunemaker/httparty/blob/v0.13.7/httparty.gemspec#L22"><code>gemspec</code></a>.</p>

<p>Now, I know what you&rsquo;re probably thinking&hellip;what good is that message? That&rsquo;s up for debate. In fact, that specific message in <code>HTTParty</code> has been the source of much debate over the years.</p>

<h2>How to configure a Post-Install Message</h2>

<p>As we&rsquo;ve seen before, the <code>gemspec</code> file (located at the root of the gem) defines the specification of a Ruby gem. Using bundler to bootstrap a new gem will automatically create this file. Here&rsquo;s an example of a default <code>gemspec</code> file created by bundler using the command <code>bundle gem brandon</code> (<code>brandon</code> being the name of my fake gem):</p>

<figure class="code"><pre><code class="ruby"># coding: utf-8
lib = File.expand_path('../lib', __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
require 'brandon/version'

Gem::Specification.new do |spec|
  spec.name          = "brandon"
  spec.version       = Brandon::VERSION
  spec.authors       = ["Brandon Hilkert"]
  spec.email         = ["brandonhilkert@gmail.com"]

  spec.summary       = %q{TODO: Write a short summary, because Rubygems requires one.}
  spec.description   = %q{TODO: Write a longer description or delete this line.}
  spec.homepage      = "TODO: Put your gem's website or public repo URL here."

  # Prevent pushing this gem to RubyGems.org by setting 'allowed_push_host', or
  # delete this section to allow pushing this gem to any host.
  if spec.respond_to?(:metadata)
    spec.metadata['allowed_push_host'] = "TODO: Set to 'http://mygemserver.com'"
  else
    raise "RubyGems 2.0 or newer is required to protect against public gem pushes."
  end

  spec.files         = `git ls-files -z`.split("\x0").reject { |f| f.match(%r{^(test|spec|features)/}) }
  spec.bindir        = "exe"
  spec.executables   = spec.files.grep(%r{^exe/}) { |f| File.basename(f) }
  spec.require_paths = ["lib"]

  spec.add_development_dependency "bundler", "~> 1.11"
  spec.add_development_dependency "rake", "~> 10.0"
  spec.add_development_dependency "minitest", "~> 5.0"
end
</code></pre></figure>


<p>Aside from <code>summary</code>, <code>description</code>, and <code>homepage</code>, we can leave the rest of this file intact. These setter attributes on the <code>Gem::Specification.new</code> instance allow us to define the options and metadata necessary to properly configure and release a Ruby gem (see <a href="http://guides.rubygems.org/specification-reference/">the Rubygems specification reference</a> for an extensive list of options).</p>

<p>As you might have guessed by now, a post-install message is an <a href="http://guides.rubygems.org/specification-reference/#post_install_message">option available in the gemspec</a>. The value can be a simple string or a more complex <a href="https://en.wikipedia.org/wiki/Here_document">heredoc</a>.</p>

<p>The simplest example being:</p>

<figure class="code"><pre><code class="ruby">spec.post_install_message = "My test post-install message."
</code></pre></figure>


<p>With that in our <code>gemspec</code>, now when we install our fake gem <code>brandon</code>, we&rsquo;ll see the following output:</p>

<figure class="code"><pre><code class="bash">$ gem install brandon
My test post-install message.
Successfully installed brandon-0.1.0
1 gem installed
</code></pre></figure>


<p>Easy, huh?</p>

<p>If we wanted to include a more complex message with line breaks and other formatting, another option would be something like:</p>

<figure class="code"><pre><code class="ruby">s.post_install_message = %q{
My test post-install message.

Another post-install message a few lines down.
}
</code></pre></figure>


<p>The formatting of these messages can get weird because whitespace is preserved in multiline strings. If you&rsquo;re looking to include anything more complex than a simple string literal, it&rsquo;s worth experimenting by installing locally and confirming it&rsquo;s what you want.</p>

<p>The <a href="https://github.com/newrelic/rpm">NewRelic gem</a> is another example that comes to mind that commonly includes more than just a simple string. Looking back at an <a href="https://github.com/newrelic/rpm/blob/v2.12.0/newrelic_rpm.gemspec#L193">older version of the NewRelic gem</a> yields the following <code>post_install_message</code>:</p>

<figure class="code"><pre><code class="ruby">s.post_install_message = %q{
Please see http://support.newrelic.com/faqs/docs/ruby-agent-release-notes
for a complete description of the features and enhancements available
in version 2.12 of the Ruby Agent.

For details on this specific release, refer to the CHANGELOG file.

}
</code></pre></figure>


<p>Notice the message includes a line break both before and after the message. This will help isolate from our post-install messages when included in the longer output of a command like <code>bundle install</code>. Again, if you&rsquo;re focused on formatting and getting it right, it&rsquo;s worth installing locally in to something like a Rails application which yields more output than using <code>gem install [gemname]</code>.</p>

<h2>When to Use Post-Install Messages</h2>

<p>The examples above use post-install messages for different reasons. <code>HTTParty</code>&rsquo;s message wasn&rsquo;t for a serious technical or information reason, just a light-hearted message that&rsquo;s garnered quite a bit of negative attention from users that don&rsquo;t appreciate it.</p>

<p>My suggestion would be to avoid any non-sensical messages and only provide a post-install message for something like breaking changes or information you think is critical to the usage of your gem. In most cases, <strong>post-install messages are most useful when a user is upgrading from an older version of your gem and the new version includes backwards-incompatible changes</strong>. Whether is be syntactical changes or core functionality, post-install messages provide us as gem authors a means to keep our users updated.</p>

<h2>What to Include in Post-Install Messages</h2>

<p>If you&rsquo;re adhering to semantic versioning and introduce any breaking changes in a major release, a post-install message is a great way to warn users about the changes. However, one thing you want to avoid is enumerating your gem&rsquo;s full changelog in the message. In most cases, a short notice about the backwards incompatible changes and a URL for more information is enough.</p>

<p>I <a href="http://brandonhilkert.com/blog/lessons-learned-from-building-a-ruby-gem-api/">introduced a new public API in Sucker Punch</a>, which warranted a major release. Because of these backwards-incompatible changes, I added a post-install message to the new version:</p>

<figure class="code"><pre><code class="bash">$ gem install sucker_punch
Fetching: sucker_punch-2.0.1.gem (100%)
Sucker Punch v2.0 introduces backwards-incompatible changes.
Please see https://github.com/brandonhilkert/sucker_punch/blob/master/CHANGES.md#20 for details.
Successfully installed sucker_punch-2.0.1
1 gem installed
</code></pre></figure>


<p>&ldquo;Sucker Punch v2.0 introduces backwards-incompatible changes&rdquo; provided the heads up that something was different. The URL in the following line allows the users to see a more extension list of the changes and to make adjustments in their application if necessary.</p>

<h2>Summary</h2>

<p>In addition to documentation through a <code>README</code> or wiki, post-install messages are a great way to keep users of our gems informed. Having access to the output of their console is a privilege, so use it sparingly. Like the boy who cried wolf, if we include a wall of text with each release of our gem, users will learn to ignore it and that would negatively affect its value for everyone.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Solving backwards compatibility in Ruby with a proxy object]]></title>
    <link href="http://brandonhilkert.com/blog/solving-backwards-compatibility-in-ruby-with-a-proxy-object/"/>
    <updated>2016-01-26T07:00:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/solving-backwards-compatibility-in-ruby-with-a-proxy-object</id>
    <content type="html"><![CDATA[<p>In a previous article, I <a href="http://brandonhilkert.com/blog/lessons-learned-from-building-a-ruby-gem-api/">documented the upcoming public API changes slated for Sucker Punch v2</a>. Because of a poor initial design, these API changes are <strong>backwards incompatible</strong>.</p>

<p>When I published the previous article, <a href="https://twitter.com/mperham/status/684529380446441472">Mike Perham rightly pointed out the opportunity to support the previous versions&rsquo;s API through an opt-in module</a>. I was hesitant to include support for the old syntax by default, but allowing a developer to require a file to get the old syntax made complete sense to me. My intent was never to abandon existing Sucker Punch users, but it felt necessary for the success of the project going forward.</p>

<!--more-->


<h2>The Problem</h2>

<p>The following is an example of enqueueing a background job with Sucker Punch using the old syntax:</p>

<figure class='code'><pre><code>LogJob.new.async.perform("new_user")</code></pre></figure>


<p>And with the new syntax:</p>

<figure class='code'><pre><code>LogJob.perform_async("new_user")</code></pre></figure>


<p><em>How do we support the old syntax in the new version?</em></p>

<p>Let&rsquo;s step back and reminder ourselves of what a typical job class looks like:</p>

<figure class='code'><pre><code>class LogJob
  include SuckerPunch::Job

  def perform(event)
    Log.new(event).track
  end
end</code></pre></figure>


<p>Important points to notice:</p>

<ol>
<li>Each job includes the <code>SuckerPunch::Job</code> module to gain access to asynchronous behavior</li>
<li>Each job executes its logic using the <code>perform</code> instance method</li>
<li>Each job passes arguments needed for its logic as arguments to the <code>perform</code> instance method</li>
</ol>


<h2>The Solution</h2>

<p>We&rsquo;ll start with the test:</p>

<figure class='code'><pre><code># test/sucker_punch/async_syntax_test.rb

require 'test_helper'

module SuckerPunch
  class AsyncSyntaxTest &lt; Minitest::Test
    def setup
      require 'sucker_punch/async_syntax'
    end

    def test_perform_async_runs_job_asynchronously
      arr = []
      latch = Concurrent::CountDownLatch.new
      FakeLatchJob.new.async.perform(arr, latch)
      latch.wait(0.2)
      assert_equal 1, arr.size
    end

    private

    class FakeLatchJob
      include SuckerPunch::Job

      def perform(arr, latch)
        arr.push true
        latch.count_down
      end
    end
  end
end</code></pre></figure>


<p><em>Note: Some details of this are complex because the job&rsquo;s code is running in another thread. I&rsquo;ll walk through those details in a future article.</em></p>

<p>The basic sequence is:
1. require <code>sucker_punch/async_syntax</code>
2. Execute a background job using the <code>async</code> syntax
3. Assert changes made in that job were successful</p>

<p>Running the tests above, we get the following error:</p>

<figure class='code'><pre><code>1) Error:
SuckerPunch::AsyncSyntaxTest#test_perform_async_runs_job_asynchronously:
LoadError: cannot load such file -- sucker_punch/async_syntax
  /Users/bhilkert/Dropbox/code/sucker_punch/test/sucker_punch/async_syntax_test.rb:6:in `require'
  /Users/bhilkert/Dropbox/code/sucker_punch/test/sucker_punch/async_syntax_test.rb:6:in `setup'

1 runs, 0 assertions, 0 failures, 1 errors, 0 skips</code></pre></figure>


<p>Ok, so the file doesn&rsquo;t exist. Let&rsquo;s create it and re-run the tests:</p>

<figure class='code'><pre><code>1) Error:
SuckerPunch::AsyncSyntaxTest#test_perform_async_runs_job_asynchronously:
NoMethodError: undefined method `async' for #&lt;SuckerPunch::AsyncSyntaxTest::FakeLatchJob:0x007fbc73cbf548&gt;
  /Users/bhilkert/Dropbox/code/sucker_punch/test/sucker_punch/async_syntax_test.rb:12:in `test_perform_async_runs_job_asynchronously'</code></pre></figure>


<p>Progress! The job doesn&rsquo;t have an <code>async</code> method. Let&rsquo;s add it:</p>

<figure class='code'><pre><code>module SuckerPunch
  module Job
    def async # &lt;--- New method
    end
  end
end</code></pre></figure>


<p><em>Notice: We&rsquo;re monkey-patching the <code>SuckerPunch::Job</code> module. This will allow us to add methods to the background job since it&rsquo;s included in the job.</em></p>

<p>The tests now:</p>

<figure class='code'><pre><code>1) Error:
SuckerPunch::AsyncSyntaxTest#test_perform_async_runs_job_asynchronously:
NoMethodError: undefined method `perform' for nil:NilClass
  /Users/bhilkert/Dropbox/code/sucker_punch/test/sucker_punch/async_syntax_test.rb:12:in `test_perform_async_runs_job_asynchronously'</code></pre></figure>


<p>More progress&hellip;the <code>async</code> method we added returns nil, and because of the syntax <code>async.perform</code>, there&rsquo;s no <code>perform</code> method on the output of <code>async</code>. In short, we need to return something from <code>async</code> that responds to <code>perform</code> and can run the job.</p>

<p>In its most basic form, suppose we create a proxy object that responds to <code>perform</code>:</p>

<figure class='code'><pre><code>class AsyncProxy
  def perform
  end
end</code></pre></figure>


<p>We&rsquo;ll need to do some work in <code>perform</code> to execute the job, but this&rsquo;ll do for now. Now, let&rsquo;s integrate this new proxy to our <code>async_syntax.rb</code> file and return a new instance of the proxy from the <code>async</code> method:</p>

<figure class='code'><pre><code>module SuckerPunch
  module Job
    def async
      AsyncProxy.new # &lt;--- new instance of the proxy
    end
  end

  class AsyncProxy
    def perform
    end
  end
end</code></pre></figure>


<p>Running our tests gives us the following:</p>

<figure class='code'><pre><code>1) Error:
SuckerPunch::AsyncSyntaxTest#test_perform_async_runs_job_asynchronously:
ArgumentError: wrong number of arguments (2 for 0)
  /Users/bhilkert/Dropbox/code/sucker_punch/lib/sucker_punch/async_syntax.rb:9:in `perform'
  /Users/bhilkert/Dropbox/code/sucker_punch/test/sucker_punch/async_syntax_test.rb:12:in `test_perform_async_runs_job_asynchronously'</code></pre></figure>


<p>Now we&rsquo;re on to something. We see an error related to the number of arguments on the <code>perform</code> method. Because each job&rsquo;s argument list will be different, we need to find a way to be flexible for whatever&rsquo;s passed in, something like&hellip;the splat operator! Let&rsquo;s try it:</p>

<figure class='code'><pre><code>module SuckerPunch
  module Job
    def async
      AsyncProxy.new
    end
  end

  class AsyncProxy
    def perform(*args) # &lt;--- Adding the splat operator, will handle any # of args
    end
  end
end</code></pre></figure>


<p>The tests now:</p>

<figure class='code'><pre><code>1) Failure:
SuckerPunch::AsyncSyntaxTest#test_perform_async_runs_job_asynchronously [/Users/bhilkert/Dropbox/code/sucker_punch/test/sucker_punch/async_syntax_test.rb:14]:
Expected: 1
Actual: 0</code></pre></figure>


<p>At this point, we&rsquo;ve reached the end of test output suggesting the path forward. This error is saying, &ldquo;Your assertions failed.&rdquo;. This is good because it means our syntax implementation will work and it&rsquo;s just about executing the actual job code in the proxy&rsquo;s <code>perform</code> method.</p>

<p>We want to leverage our new syntax (<code>perform_async</code>) to run the actual job asynchronously so it passes through the standard code path. To do so, we&rsquo;ll need a reference to the original job in the proxy object. Let&rsquo;s pass that to the proxy during instantiation:</p>

<figure class='code'><pre><code>module SuckerPunch
  module Job
    def async
      AsyncProxy.new(self) # &lt;--- Pass the job instance
    end
  end

  class AsyncProxy
    def initialize(job) # &lt;--- Handle job passed in
      @job = job
    end

    def perform(*args)
    end
  end
end</code></pre></figure>


<p>Now that the proxy has a reference to the job instance, we can call the <code>perform_async</code> class method to execute the job:</p>

<figure class='code'><pre><code>module SuckerPunch
  module Job
    def async
      AsyncProxy.new(self)
    end
  end

  class AsyncProxy
    def initialize(job)
      @job = job
    end

    def perform(*args)
      @job.class.perform_async(*args) # &lt;---- Execute the job
    end
  end
end
</code></pre></figure>


<p>Lastly, the tests:</p>

<figure class='code'><pre><code>ress ENTER or type command to continue
bundle exec rake test TEST="test/sucker_punch/async_syntax_test.rb"
Run options: --seed 43886

# Running:

.

1 runs, 1 assertions, 0 failures, 0 errors, 0 skips</code></pre></figure>


<p>Success!</p>

<p>Just like that, new users of Sucker Punch will be able to add <code>require 'sucker_punch/async_syntax'</code> to their projects to use the old syntax. This will allow existing projects using Sucker Punch to take advantage of the reworked internals without the need to make sweeping changes to the enqueueing syntax.</p>

<p>Support for the old syntax will be available for foreseeable future via this include. All new code/applications should use the new syntax going forward.</p>

<h2>Conclusion</h2>

<p>Before realizing a proxy object would work, I tinkered with <code>alias_method</code> and a handful of other approaches to latching on to the job&rsquo;s <code>perform</code> method and saving it off to execute later. While some combinations of these might have worked, the proxy object solution is simple and elegant. There&rsquo;s no magic, which means less maintenance going forward. The last thing I want is to make a breaking change, add support for the old syntax and find the support to be bug-ridden.</p>

<p>Ruby is incredibly flexible. Sometimes a 9-line class is enough to get the job done without reaching for an overly complex metaprogramming approach.</p>

<p>Having said all that, <a href="https://github.com/brandonhilkert/sucker_punch">Sucker Punch <code>v2</code> has been
released</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lessons Learned from Building a Ruby Gem API]]></title>
    <link href="http://brandonhilkert.com/blog/lessons-learned-from-building-a-ruby-gem-api/"/>
    <updated>2016-01-04T13:12:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/lessons-learned-from-building-a-ruby-gem-api</id>
    <content type="html"><![CDATA[<p>Sucker Punch was created because I had a <a href="http://brandonhilkert.com/blog/why-i-wrote-the-sucker-punch-gem/">need for background processing without a separate worker</a>. But I also figured others did too, given that adding a worker dyno on Heroku was $35. For hobby apps, this was a significant cost.</p>

<p>Having gotten familiar with Celluloid from my work on Sidekiq, I knew Celluloid had all the pieces to puzzle to make this easier. In fact, one of the earliest incarnations of Sucker Punch wasn&rsquo;t a gem at all, just some Ruby classes implementing the pieces of Celluloid necessary to put together a background processing queue.</p>

<!--more-->


<p>The resulting code was less than ideal. It worked, but didn&rsquo;t feel like an API that anyone would want to use. From a beginner&rsquo;s perspective, this would stop adoption in its tracks. This is a common challenge with any code we encounter. No doubt, the Ruby standard library has all the tools necessary to make just about anything we can dream of, but sometimes the result isn&rsquo;t ideal. It&rsquo;s the same reason libraries like Rspec and HTTParty can exist. Developers prefer to use simplistic <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSLs</a> over convoluted, similarly-functioning code. Ruby has always been a language where developers consistently tout their ability to write code that reads well, feeding the levels of developer happiness.</p>

<h2>Why Rewrite Sucker Punch</h2>

<p>It started when <a href="https://github.com/brandonhilkert/sucker_punch/issues/122">a version of Celluloid was yanked from RubyGems.org</a>. This resulted in a flurry of tweets and GH issues detailing their inability to bundle their applications.</p>

<p>As of version <code>0.17</code>, methods in public API changed without supporting documentation. On top of that, the core <code>celluloid</code> gem was split in to a series of child gems causing navigation to be painful.</p>

<p>This made my life as the Sucker Punch maintainer difficult. There were some requests to upgrade Sucker Punch to use Celluloid <code>~&gt; 0.17</code> and I feared of what would happen if I did. This caused me to think about what the future of Sucker Punch looked like without Celluloid. I still use Sucker Punch and believe it&rsquo;s a valuable asset to the community. My goal was to find a way to move it forward productively without experiencing similar pains.</p>

<p>In the end, thanks to some <a href="https://github.com/brandonhilkert/sucker_punch/pull/126">communinity contributions</a>, <a href="https://github.com/brandonhilkert/sucker_punch/blob/master/CHANGES.md#160">Sucker Punch <code>1.6.0</code> was released with Celluloid <code>0.17.2</code> support</a>.</p>

<h2>Where to now?</h2>

<p>Around that same time, Mike Perham had been writing about his experiences <a href="http://www.mikeperham.com/2015/10/14/optimizing-sidekiq/">optimizing Sidekiq</a> and <a href="http://www.mikeperham.com/2015/10/14/should-you-use-celluloid/">whether continuing with Celluloid made sense for Sidekiq</a>. Having less experience with multi-threading, it didn&rsquo;t make sense for me to reinvent the wheel.</p>

<p>I had been hearing about <a href="https://github.com/ruby-concurrency/concurrent-ruby"><code>concurrent-ruby</code></a> through a variety of outlets, one of which was Rails <a href="https://github.com/rails/rails/pull/20866">replacing the existing concurrency latch with similar functionality from <code>concurrent-ruby</code></a>. After poking around <code>concurrent-ruby</code>, I realized it had all the tools necessary to build a background job processing library. Much like Celluloid in that respect, had the tools, but lacked the simple DSL for the use case.</p>

<p>What if Sucker Punch used <code>concurrent-ruby</code> in place of <code>celluloid</code>?</p>

<p>I can hear what you&rsquo;re thinking&hellip;&ldquo;What&rsquo;s the difference? You&rsquo;re swapping one dependency for another!&rdquo;. 100% true. The difference was that the little bit of communication I had with the maintainers of <code>concurrent-ruby</code> felt comfortable, easy, and welcoming. And with <code>concurrent-ruby</code> now a dependency of Rails, it&rsquo;s even more accessible for those using Sucker Punch within a Rails application (a common use case). But like before, there&rsquo;s no way to be sure that  <code>concurrent-ruby</code> won&rsquo;t cause similar pains/frustrations.</p>

<h2>Celluloid Basics</h2>

<p>A basic Sucker Punch job looks like:</p>

<figure class='code'><pre><code>class LogJob
  include SuckerPunch::Job

  def perform(event)
    Log.new(event).track
  end
end</code></pre></figure>


<p>To run the job asynchronously, we use the following syntax:</p>

<figure class='code'><pre><code>LogJob.new.async.perform("new_user")</code></pre></figure>


<p>The most interesting part of this method chain is the <code>async</code>. Removing <code>async</code>, leaves us with a call to a regular instance method.</p>

<p>It so happens that <a href="https://github.com/celluloid/celluloid/wiki/Basic-usage"><code>async</code> is a method in Celluloid that causes the next method to execute asynchronously</a>. And this works because by including <code>SuckerPunch::Job</code>, we&rsquo;re including <code>Celluloid</code>, which gives us the <code>async</code> method on instances of the job class.</p>

<h2>Developing APIs</h2>

<p>If you&rsquo;re familiar with the basics of Celluloid, you&rsquo;ll notice there&rsquo;s not much to Sucker Punch. It adds the Celluloid functionality to job classes and does some things under the hood to ensure there&rsquo;s one queue for each job class.</p>

<p><strong>Early in my <code>concurrent-ruby</code> spike, I realized what a mistake to tie Sucker Punch&rsquo;s API to the API of Celluloid</strong>. Tinkering with the idea of removing Celluloid has left Sucker Punch with two options:</p>

<ol>
<li>Continue using the <code>async</code> method with the new dependency</li>
<li>Break the existing DSL and create a dependency-independent syntax and try my best to document and support the change through the backwards-incompatible change</li>
</ol>


<p>Option 1 is the easy way out. Option 2 is more work, far more scary, but the right thing to do.</p>

<p>I decided to abandon my thoughts about previous versions and write as if it were new today. This will be the basis for the next major release of Sucker Punch (<code>2.0.0</code>).</p>

<p>Settling on abandoning the existing API, the next question is, <strong>&ldquo;What should the new API look like?&rdquo;</strong>.</p>

<p>Being a fan of Sidekiq, it didn&rsquo;t take long for me to realize it could actually make developers lives easier if Sucker Punch&rsquo;s API was the same.</p>

<p>Switching between Sidekiq and Sucker Punch is not uncommon. I look at Sidekiq as Sucker Punch&rsquo;s big brother and often suggest people use it instead when the use case makes sense.</p>

<p>If you&rsquo;re familiar with Sidekiq, using the <code>perform_async</code> class method should look familiar:</p>

<figure class='code'><pre><code>LogJob.peform_async("new_user")</code></pre></figure>


<p><strong>So why not use the same for Sucker Punch?</strong></p>

<p>If so, switching between Sidekiq and Sucker Punch would be no more than swapping <code>include Sidekiq::Worker</code> for <code>include SuckerPunch::Job</code> in the job class, aside from the gem installation itself. The result would be less context switching and more opportunity focus on the important parts of the application.</p>

<p>I can hear the same question again, &ldquo;What&rsquo;s the difference? You suggested isolating yourself from a dependency&rsquo;s API and now you&rsquo;re suggesting using another!&rdquo;. I look at this one a little differently&hellip;</p>

<p>Sidekiq is uniquely positioned in the community as a paid open source project. We&rsquo;re happy users of Sidekiq Pro and continue to do so for the support. You can certainly get support for the open source version, but one way to ensure Sidekiq is actively maintained is by paying for it. This financial support from us and others decreases the likelihood Mike will choose to abandon it. Mike&rsquo;s also been public about his long-term interest in maintaining Sidekiq. With all this in mind, I&rsquo;m willing to bank on its existence as the defacto way to enqueue jobs for background processing.</p>

<p>And if for some reason Sidekiq does disappear, there&rsquo;s nothing lost on Sucker Punch. There&rsquo;s no dependency. Just a similar syntax.</p>

<p>Sucker Punch <code>2.0.0</code> will have 2 class methods to enqueue jobs:</p>

<figure class='code'><pre><code>LogJob.perform_async("new_user")</code></pre></figure>


<p>and</p>

<figure class='code'><pre><code>LogJob.perform_in(5.minutes, "new_user")</code></pre></figure>


<p>The latter defining a delayed processing of the <code>perform</code> method 5 minutes from now.</p>

<h2>Summary</h2>

<p>Settling on a library&rsquo;s API isn&rsquo;t easy. Isolating it from underlying dependencies is the best bet for long-term stability. Using the <a href="https://en.wikipedia.org/wiki/Adapter">adapter pattern</a> can help create a layer (adapter) between your code and the dependency&rsquo;s API. But like always, there are always exceptions.</p>

<p>I&rsquo;m taking a leap of faith that doing what I believe is right won&rsquo;t leave existing users frustrated, ultimately abandoning Sucker Punch altogether.</p>

<p>Sucker Punch <code>v2.0</code> is shaping up to be the best release yet. I&rsquo;m looking forward to sharing it with you.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sidekiq As A Microservice Message Queue]]></title>
    <link href="http://brandonhilkert.com/blog/sidekiq-as-a-microservice-message-queue/"/>
    <updated>2015-11-30T12:06:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/sidekiq-as-a-microservice-message-queue</id>
    <content type="html"><![CDATA[<p>In the recent series on transitioning to microservices, I detailed a path to move a large legacy Rails monolith to a cluster of a dozen microservices. But not everyone starts out with a legacy monolith. In fact, given Rails popularity amongst startups, <strong>it&rsquo;s likely most Rails applications don&rsquo;t live to see 4+ years in production</strong>. So what if we don&rsquo;t have a huge monolith on our hands? Are microservices still out of the question?</p>

<p>Sadly, the answer is, &ldquo;it depends&rdquo;. The &ldquo;depends&rdquo; part is specific to your context. While microservices may seem like the right move for you and your application, it&rsquo;s also possible it could cause a mess if not done carefully.</p>

<!--more-->


<p>This post will explore opportunities for splitting out unique microservices using <a href="http://sidekiq.org/">Sidekiq</a>, without introducing an enterprise message broker like <a href="https://www.rabbitmq.com/">RabbitMQ</a> or <a href="http://kafka.apache.org/">Apache Kafka</a>.</p>

<h2>When are Microservices right?</h2>

<p>Martin Fowler <a href="http://martinfowler.com/articles/microservice-trade-offs.html">wrote about trade-offs that come when introducing microservices</a>.</p>

<p>The article outlines 6 pros and cons introduced when you moved a microservices-based architecture. The strongest argument for microservices is the strengthening of module boundaries.</p>

<p>Module boundaries are naturally strengthened when we&rsquo;re forced to move code to another codebase. The result being, in most cases a group of microservices appears to be better constructed than the legacy monolith it was extracted from.</p>

<p>There&rsquo;s no doubt Rails allows developers to get something up and running very quickly. Sadly, you can do so while making a big mess at the same time. It&rsquo;s worth noting there&rsquo;s nothing stopping a monolith from being well constructed. With some discipline, <a href="https://www.youtube.com/watch?v=KJVTM7mE1Cc">your monolith can be the bright and shiny beauty that DHH wants it to be</a>.</p>

<h2>Sidekiq Queues</h2>

<p>Ok, ok. You get it. Microservices can be awesome, but they can also make a big mess. I want to tell you about how I recently avoided a big mess without going &ldquo;all in&rdquo;.</p>

<p>There&rsquo;s no hiding I&rsquo;m a huge <a href="http://sidekiq.org/">Sidekiq</a> fan. It&rsquo;s my goto solution for background processing.</p>

<p>Sidekiq has the notion of <a href="https://github.com/mperham/sidekiq/wiki/Advanced-Options#workers">named queues</a> for both <a href="https://github.com/mperham/sidekiq/wiki/Advanced-Options#workers">jobs</a> and <a href="https://github.com/mperham/sidekiq/wiki/Advanced-Options#queues">workers</a>. This is great from the standpoint that it allows you to put that unimportant long-running job in a different queue without delayed other important fast-running jobs.</p>

<p>A typical worker might look like:</p>

<figure class='code'><pre><code>class ImportantWorker
  include Sidekiq::Worker

  def perform(id)
    # Do the important stuff
  end
end</code></pre></figure>


<p>If we want to send this job to a different queue, we&rsquo;d add <code>sidekiq_options queue: :important</code> to the worker, resulting in:</p>

<figure class='code'><pre><code>class ImportantWorker
  include Sidekiq::Worker
  sidekiq_options queue: :important

  def perform(id)
    # Do the important stuff
  end
end</code></pre></figure>


<p>Now, we need to make sure the worker process that&rsquo;s running the jobs knows to process jobs off this queue. A typical worker might be invoked with:</p>

<figure class='code'><pre><code>bin/sidekiq</code></pre></figure>


<p>Since new jobs going through this worker will end up on the <code>important</code> queue, we want to make sure the worker is processing jobs from the <code>important</code> queue too:</p>

<figure class='code'><pre><code>bin/sidekiq -q important -q default</code></pre></figure>


<p><em>Note: Jobs that don&rsquo;t specify a queue will go to the <code>default</code> queue. We have to include the <code>default</code> queue when we using the <code>-q</code> option, otherwise the default queue will be ignored in favor of the queue passed to the <code>-q</code> option.</em></p>

<p>The best part, you don&rsquo;t even have to have multiple worker processes to process jobs from multiple queues. Furthermore, the <code>important</code> queue can be checked twice as often as the <code>default</code> queue:</p>

<figure class='code'><pre><code>bin/sidekiq -q important,2 -q default</code></pre></figure>


<p>This flexibility of where jobs are enqueued and how they&rsquo;re processed gives us an incredible amount of freedom when building our applications.</p>

<h2>Extracting Worker to a Microservice</h2>

<p>Let&rsquo;s assume that we&rsquo;ve deployed your main application to Heroku. The application uses Sidekiq and we&rsquo;ve included a Redis add-on. With the addition of the add-on, our application now has a <code>REDIS_URL</code> environment variable that Sidekiq connects to on startup. We have a web process, and worker process. A pretty standard Rails stack:</p>

<p><img class="center" src="http://brandonhilkert.com/images/sidekiq/rails-web-worker.png" title="&#34;Rails with typical worker process&#34;" alt="&#34;Rails with typical worker process&#34;"></p>

<p><strong>What&rsquo;s stopping us from using that same <code>REDIS_URL</code> in another application?</strong></p>

<p>Nothing, actually. And if we consider what we know about the isolation of jobs in queue and workers working on specific queues, there&rsquo;s nothing stopping us from having workers for a specific queue in a different application altogether.</p>

<p>Remember <code>ImportantWorker</code>, imagine the logic for that job was better left for a different application. We&rsquo;ll leave that part a little hand-wavey because there still should be a really good reason to do so. But we&rsquo;ll assume you&rsquo;ve thought long and hard about this and decided the core application was not a great place for this job logic.</p>

<p>Extracting the worker a separate application might now look something like this:</p>

<p><img class="center" src="http://brandonhilkert.com/images/sidekiq/rails-with-microservice.png" title="&#34;Using Sidekiq as a Message Queue between two Rails microservices&#34;" alt="&#34;Using Sidekiq as a Message Queue between two Rails microservices&#34;"></p>

<h2>Enqueueing Jobs with the Sidekiq Client</h2>

<p>Typically, to enqueue the <code>ImportantWorker</code> above, we&rsquo;d call the following from our application:</p>

<figure class='code'><pre><code>ImportantWorker.perform_async(1)</code></pre></figure>


<p>This works great when <code>ImportantWorker</code> is defined in our application. With the expanded stack above, <code>ImportantWorker</code> now lives in a new microservice, which means we don&rsquo;t have access to the <code>ImportantWorker</code> class from within the application. We <em>could</em> define it in the application just so we can enqueue it, with the intent that the application won&rsquo;t process jobs for that worker, but that feels funny to me.</p>

<p>Rather, we can turn to the underlying Sidekiq client API to enqueue the job instead:</p>

<figure class='code'><pre><code>Sidekiq::Client.push(
  "class" =&gt; "ImportantWorker",
  "queue" =&gt; "important",
  "args" =&gt; [1]
)
</code></pre></figure>


<p><em>Note: We have to be sure to define the <code>class</code> as a string <code>"ImportantWorker"</code>, otherwise we&rsquo;ll get an exception during enqueuing because the worker isn&rsquo;t defined in the application.</em></p>

<h2>Processing Sidekiq Jobs from a Microservice</h2>

<p>Now we&rsquo;re pushing jobs to the <code>important</code> queue, but have nothing in our application to process them. In fact, our worker process isn&rsquo;t even looking at that queue:</p>

<figure class='code'><pre><code>bin/sidekiq -q default</code></pre></figure>


<p>From our microservice, we setup a worker process to <strong>ONLY</strong> look at the <code>important</code> queue:</p>

<figure class='code'><pre><code>bin/sidekiq -q important</code></pre></figure>


<p>We define the <code>ImportantWorker</code> in our microservice:</p>

<figure class='code'><pre><code>class ImportantWorker
  include Sidekiq::Worker
  sidekiq_options queue: :important

  def perform(id)
    # Do the important stuff
  end
end</code></pre></figure>


<p>And now when the worker picks jobs out of the <code>important</code> queue, it&rsquo;ll process them using the <code>ImportantWorker</code> defined above in our microservice.</p>

<p>If we wanted to go one step further, the microservice could then enqueue a job using the Sidekiq client API to a queue that only the core application is working on in order to send communication back the other direction.</p>

<h2>Summary</h2>

<p>Any architectural decision has risks. Microservices are no exception. Microservices can be easier than an enterprise message broker, cluster of new servers and a handful of devops headaches.</p>

<p>I originally dubbed this the &ldquo;poor man&rsquo;s message bus&rdquo;. With more thought, there&rsquo;s nothing &ldquo;poor&rdquo; about this. Sidekiq has a been a reliable piece of our infrastructure and I have no reason to believe that&rsquo;ll change, even if we are using it for more than just simple background processing from a single application.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Path to Services - Part 3 - Synchronous Events]]></title>
    <link href="http://brandonhilkert.com/blog/a-path-to-services-part-3-synchronous-events/"/>
    <updated>2015-10-15T09:07:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/a-path-to-services-part-3-synchronous-events</id>
    <content type="html"><![CDATA[<p><em>This article was originally posted on the <a href="http://plumbing.pipelinedeals.com/">PipelineDeals Engineering
Blog</a></em></p>

<p>In the <a href="http://brandonhilkert.com/blog/a-path-to-services-part-1-start-small/">previous article in this series</a>, we introduced a billing service to determine which features an account could access. If you remember, <a href="http://brandonhilkert.com/our-path-to-services-part-1-start-small/">the email service</a> was a &ldquo;fire and forget&rdquo; operation and was capable of handling throughput delays given its low value to the core application.</p>

<p>This post will explore how we handle synchronous communication for a service like billing where an inline response is required to service a request from the core application.</p>

<!--more-->


<h2>Background</h2>

<p>If you remember from the previous post, we introduced the billing service to an infrastructure that looked like this:</p>

<p><img class="center" src="http://brandonhilkert.com/images/services/app-email-billing.png" title="&#34;Web application with Email and Billing Microservice&#34;" alt="&#34;Web application with Email and Billing Microservice&#34;"></p>

<p>Handling multiple pricing tiers in a SaaS app means you have to control authorization based on account status. Our billing service encapsulates the knowledge of which features correspond to which pricing tier.</p>

<p>For instance, one feature is the ability to send trackable email to contacts in your PipelineDeals account. To service this request, we add an option to the bulk action menu from a list view:</p>

<p><img class="center" src="http://brandonhilkert.com/images/services/send-email.png" title="&#34;Send email feature&#34;" alt="&#34;Send email feature&#34;"></p>

<h2>Service Request</h2>

<p>Before we can conditionally show this option based on the pricing tier, we have to first make a request to the billing service to get the list of features available to that user.</p>

<figure class='code'><pre><code>class Billing::Features
  def initialize(user)
    @user = user
    @account = user.account
  end

  def list
    Rails.cache.fetch("account_#{account.id}_billing_features") do
      response = Billing::Api.get "account/#{account.id}/features"
      response['features']
    end
  end

  private

  attr_reader :user, :account
end</code></pre></figure>


<p><code>Billing::Api</code>, in this case, is a wrapper around the API calls to handle exceptions and other information like security.</p>

<p><em>Note: When making synchronous HTTP calls like this, it&rsquo;s worth considering the failure state and providing a default response set in that case so the user isn&rsquo;t burdened with a failure page. In this case, one option would be dumb down the features on the page to the most basic tier.</em></p>

<h2>Serving a JSON API</h2>

<p>Plenty of articles have been written about how to create a JSON API with Rails, so we won&rsquo;t rehash those techniques here. Instead, we&rsquo;ll highlight patterns we&rsquo;ve used for consistency.</p>

<p>We tend to reserve the root URL namespace for UI-related routes, so we start by creating a unique namespace for the API:</p>

<figure class='code'><pre><code>namespace :api do
  resources :account do
    resource :features, only: :show
  end
end</code></pre></figure>


<p>This setup gives us the path <code>/api/account/:account_id/features</code>. We haven&rsquo;t found a need for versioning internal APIs. If we decided to in the future, we could always add the API version as a request header.</p>

<p>The <code>features</code> endpoint looks like:</p>

<figure class='code'><pre><code>class Api::FeaturesController &lt; Api::ApiController
  skip_before_filter :verify_authenticity_token

  def show
    render json: {
      success: true,
      features: AccountFeatures.new(@account_id).list
    }
  end
end</code></pre></figure>


<p>Notice <code>Api::FeaturesController</code> inherits from <code>Api::ApiController</code>. We keep the API-related functionality in this base controller so each endpoint will get access to security and response handling commonalities.</p>

<p><code>AccountFeatures</code> is a PORO that knows how to list billing features for a particular account. We could&rsquo;ve queried it straight from an ActiveRecord-based model, but our handling of features is a little more complicated than picking them straight from the database.</p>

<p>Another note here is that we haven&rsquo;t introduced a serializing library like <code>active_model_serializers</code> or <code>jbuilder</code>. Using <code>render json</code> alone has serviced us well for simple APIs. We reach for something more complex when the response has more attributes than shown above.</p>

<h2>Handling Service Response</h2>

<p>By introducing <code>Rails.cache</code>, we can serve requests (after the initial) without requiring a call to the billing service.</p>

<p>One of the first things we do is serialize the set of features to JavaScript so our client-side code has access:</p>

<figure class='code'><pre><code>&lt;%= javascript_tag do %&gt;
  window.Features = &lt;%= Billing::Features.new(logged_in_user).list.to_json %&gt;;
&lt;% end %&gt;</code></pre></figure>


<p>We also include a helper module in to our Rails views/controllers, so we can handle conditional feature logic:</p>

<figure class='code'><pre><code>module Features
  def feature_enabled?(feature)
    Billing::Features.new(logged_in_user).list.include?(feature.to_s)
  end
end</code></pre></figure>


<h2>Synchronous Side Effects</h2>

<p>When we <a href="http://brandonhilkert.com/our-path-to-services-part-2-synchronous-vs-asynchronous/">looked at asynchronous service requests</a>, there was less immediacy associated with the request due to its &ldquo;fire-and-forget&rdquo; nature. A synchronous request, on the other hand, will handle all requests to the core application, so scaling can be challenge and infrastructure costs can add up.</p>

<p><img class="center" src="http://brandonhilkert.com/images/services/synchronous-service-cost.png" title="&#34;Increased cost by introducing synchronous microservice&#34;" alt="&#34;Increased cost by introducing synchronous microservice&#34;"></p>

<p>In addition to the infrastructure costs, performance can be a factor. If the original page response time was 100ms and we&rsquo;re adding a synchronous service request that takes another 100ms, all of a sudden we&rsquo;ve doubled our users&#8217; response times. And while this architectural decision might seem like an optimization, I&rsquo;m positive none of our users will thank us for making their page load times 2x slower.</p>

<h2>Summary</h2>

<p>As you can see, there&rsquo;s little magic to setting up a synchronous service request.</p>

<p>Challenges appear when you consider failure states at every point in the service communication &ndash; the service could be down, or the HTTP request itself could fail due to network connectivity. As mentioned above, providing a default response during service failure is a great start to increasing the application&rsquo;s reliability. Optionally, <a href="https://en.wikipedia.org/wiki/Circuit_breaker_design_pattern">the circuit break pattern</a> can provide robust handling of network failures.</p>

<p>Part 4 in this series will cover how we manage asynchronous communication between services, specifically around an <a href="https://github.com/PipelineDeals/mantle">open source gem we built called Mantle</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Path to Services - Part 2 - Synchronous vs. Asynchronous]]></title>
    <link href="http://brandonhilkert.com/blog/a-path-to-services-part-2-synchronous-vs-asynchronous/"/>
    <updated>2015-08-14T10:32:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/a-path-to-services-part-2-synchronous-vs-asynchronous</id>
    <content type="html"><![CDATA[<p><em>This article was originally posted on the <a href="http://plumbing.pipelinedeals.com/">PipelineDeals Engineering
Blog</a></em></p>

<p>In the <a href="http://brandonhilkert.com/blog/a-path-to-services-part-1-start-small/">previous article in this series</a>, we moved the responsibility of emails to a separate Rails application. In order to leverage this new service, we created a PORO to encapsulate the specifics of communicating with our new service by taking advantage of Sidekiq&rsquo;s built-in retry mechanism to protect from intermittent network issues.</p>

<p>Communication between microservices can be broken down in to 2 categories: <strong>synchronous</strong> and  <strong>asynchronous</strong>.
Understanding when to use each is critical in maintaining a healthy infrastructure. This post will explore details about these two methods of communication and their associated use cases.</p>

<!--more-->


<h2>Background</h2>

<p>Continuing the discussion of our architecture from last time, we have a primary
Rails web application serving the majority of our business logic. We now have an additional application that&rsquo;s only responsibility is the formatting and sending of emails.</p>

<p><img class="center" src="http://brandonhilkert.com/images/services/app-email.png" title="&#34;Application service with email microservice&#34;" alt="&#34;Application service with email microservice&#34;"></p>

<p>In this article, we&rsquo;ll discuss the addition of our Billing service. The service&rsquo;s responsibility to is to process transactions related to money. This can come in the form of a trial conversion, adding a seat to an additional account, or deleting users from an existing account, among others.</p>

<p>Like many SaaS applications, PipelineDeals has multiple tiers of service. The most expensive intended for customers needing advanced functionality. Part of the billing service&rsquo;s responsibility is to manage the knowledge of which features an account can access.</p>

<p>So stepping back to the main PipelineDeals web application, the app has to decide which features to render at page load. Because the billing service is our source of truth for this information, a page load will now require a call to this service to understand which features to render.</p>

<p>This new dependency looks a little different than the email dependency from the
<a href="http://brandonhilkert.com/blog/a-path-to-services-part-1-start-small/">previous article</a>. Email has the
luxury of not being in the dependency path of a page load. Very few customers
will complain if an email is 10 seconds late. On the other hand, they&rsquo;ll
complain immediately if their account won&rsquo;t load, and rightfully so.</p>

<p><img class="center" src="http://brandonhilkert.com/images/services/app-email-billing.png" title="&#34;Application service include email and billing microservices&#34;" alt="&#34;Application service include email and billing microservices&#34;"></p>

<p>An interesting benefit from having already extracted the email service is that the billing service sends email regarding financial transactions and account changes. Typically, we would have done the same thing for every other Rails app that needed to send email, which was integrate <code>ActionMailer</code> and setup the templates and mailers needed to do the work. In this case, we can add those emails to the email service and use the same communication patterns we do from the main web application to trigger the sending of an email from the billing service. This does require making changes to 2 different projects for a single feature (business logic in billing and mailer in email), but removes the necessity to configure another app to send email properly. We viewed this as a benefit.</p>

<h2>Asynchronous Events</h2>

<p>As the easier of the two, asynchronous would be any communication not necessary for the request/response cycle to complete. Email is the perfect example. Logging also falls in to this category.</p>

<p>For the networks gurus out there, this would be similar to UDP communication. More of a fire-and-forget approach.</p>

<p>An email, in this case, is triggered due to something like an account sign up.
We send a welcome email thanking the customer for signing up and giving them
some guidance on how to get the most benefit from the application. Somewhere in
the process of signing up, the code triggers an email and passes along the data
needed for email template.</p>

<p>As shown in the previous article, the call to send the email looks something like this:</p>

<figure class='code'><pre><code>Email.to current_user, :user_welcome</code></pre></figure>


<p>The value in this call is that under the covers, it&rsquo;s enqueuing a Sidekiq job:</p>

<figure class='code'><pre><code>EmailWorker.perform_async(opts)</code></pre></figure>


<p>where <code>opts</code> is a hash of data related to the email and the variables needed for the template.</p>

<p><em>Note: Because the options are serialized to JSON, values in hash must be simple structures. Objects won&rsquo;t work here.</em></p>

<p>As you can see above, the code invoking the <code>Email.to</code> method doesn&rsquo;t care about what it returns. In fact, it doesn&rsquo;t return anything we care about at this point. So as long as the method is called, the code can move forward without waiting for the email to finish sending.</p>

<p>Extracting asynchronous operations like this that exist in a code path is a
great way to improve performance. There are times, though, where deferring an operation to background job might not make sense.</p>

<p>For example, imagine a user changes the name of a person. They click one of their contact&rsquo;s names, enter a new name, and click &ldquo;Save&rdquo;. It doesn&rsquo;t make sense to send the task of updating the actual name in the database to a background job because depending on what else is in the queue at that time, the update might not complete until after the next refresh, which would make the user believe their update wasn&rsquo;t successful. This would be incredibly confusing.</p>

<p>Logging is another perfect candidate for asynchronicity. In most cases, our users don&rsquo;t care if a log of their actions has been written to the database before their next refresh. It&rsquo;s information we may want to store, and as a result, can be a fire-and-forget operation. We can rest easy knowing we&rsquo;ll have that information, soon-ish, and it won&rsquo;t add any additional overhead to the end user&rsquo;s request cycle.</p>

<p>The opposite of asynchronous events like this are <strong>synchronous</strong> events! (surprise right?). Let&rsquo;s explore how they&rsquo;re different.</p>

<h2>Synchronous Events</h2>

<p>We can look at synchronous events as dependencies of the request cycle. We use MySQL as a backend for the main PipelineDeals web application and queries to MySQL would be considered synchronous. In that, in order to successfully fulfill the current request, we require the information returned from MySQL before we can respond.</p>

<p>In most cases, we don&rsquo;t think of our main datastore as a service. It doesn&rsquo;t necessarily have a separate application layer on top of it, but it&rsquo;s behavior and requirements are very much like a service.</p>

<p>If we consider the addition of our billing service above, we require information about the features allowed for a particular account before we can render the page. This allows us to include/exclude modules they should or should not see. The flow goes something like this:</p>

<p><code>Web request -&gt; lookup account in DB -&gt; Request features from Billing service -&gt; render page</code></p>

<p>If the request to the billing service didn&rsquo;t require a response, we would consider this to be an <strong>asynchronous</strong> service, which might change how we invoke the request for data.</p>

<p>Synchronous communication can happen over a variety of protocols. The most
common is a JSON payload over HTTP. In general, it&rsquo;s not the most performant,
but it&rsquo;s one of the easier to debug and is human-readable, so it tends to be pretty popular.</p>

<p>The synchronous services we&rsquo;ve setup all communicate over HTTP. Rails APIs are a known thing. We&rsquo;re familiar with the stack and the dependencies required to set up a common JSON API, which is a large part of the reason it&rsquo;s our preferred communication protocol between services.</p>

<h2>Summary</h2>

<p>We&rsquo;ve simplified the communication between services into these two categories. Knowing this helps dictate the infrastructure and configuration of the applications.</p>

<p>Next time, we&rsquo;ll take a closer look at the synchronous side and the specifics about the JSON payloads involved to send an email successfully.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Path to Services - Part 1 - Start Small]]></title>
    <link href="http://brandonhilkert.com/blog/a-path-to-services-part-1-start-small/"/>
    <updated>2015-07-27T11:18:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/a-path-to-services-part-1-start-small</id>
    <content type="html"><![CDATA[<p><em>This article was originally posted on the <a href="http://plumbing.pipelinedeals.com/">PipelineDeals Engineering
Blog</a></em></p>

<p>The PipelineDeals web application recently celebrated its ninth birthday. It&rsquo;s
seen its fair share of developers, all of whom had their own idea of &ldquo;clean
code&rdquo;. As a team, we&rsquo;d been brainstorming ways to wrangle certain areas of the
application. The question we&rsquo;d frequently ask ourselves was <em>&ldquo;How do we clean
up [x] (some neglected feature of the application)?</em>&rdquo;.</p>

<!--more-->


<p>Reasonable solutions ended up being:</p>

<ol>
<li>Rewrite it</li>
<li>Rewrite and put it elsewhere</li>
</ol>


<p>In short, we chose to rewrite many of the hairy areas of the app into separate services communicating over HTTP. It&rsquo;s been about a year since our first commit in a separate service, and we&rsquo;ve learned quite a bit since then. This is part 1 in a series of posts related to our transition to microservices.</p>

<h2>How we got here</h2>

<p>This was us 18 months ago. PipelineDeals was a crufty Rails 2 application that many of us were scared to open. It&rsquo;d been several years of adding feature upon feature without consistent knowledge, style, or guidance. And it&rsquo;s probably not surprising we had what we did. Regardless, we needed to fix it.</p>

<p>One of our goals was to move to Rails 3, and later more updated versions, but in order to get there, we had to refactor (or remove) quite a bit of code to make the transition easier.</p>

<p>This, to me, was a huge factor around our decision to move to a more service-focused approach. <a href="https://www.youtube.com/watch?v=KJVTM7mE1Cc">At this year&rsquo;s Railsconf keynote</a>, DHH joked about the &ldquo;majestic monolith&rdquo; and how many companies prematurely piece out services, all to later suffer pain when they realize it was a premature optimization.</p>

<p>The same could be said for our move. Instead of spinning out separate services, we could have cleaned up the mess we had by refactoring every nasty piece of our app. We could have turned our ugly monolith into a majestic one. But while it would&rsquo;ve been possible, our team agreed we were better served by more or less starting over. Not in the big-bang rewrite sense, but instead to stand up brand new service apps when we added new features, and when it made sense. &ldquo;Made sense&rdquo; is the key here. There have been many times when it didn&rsquo;t make sense over the past 12 months. But we&rsquo;re learning and getting better at identifying the things that are good candidates for a more isolated service.</p>

<h2>Now what?</h2>

<p><em>Do we wait for the next requested feature or what?</em></p>

<p>At one of our weekly team hangouts, we watched a talk focused on starting by isolating the responsibility of Email. It was the perfect introduction and motivation for us to get a small win and some experience under our belts. For some reason prior, we didn&rsquo;t have a great sense of how to start making that transition.</p>

<p>The idea was to take our emails (and there were plenty) and move them to a separate Rails app that&rsquo;s only responsibilty is sending email. While it sounds trivial, the idea alone introduces a lot of interesting questions: <em>What do we do with those really nasty emails that have 30 instance variables? What do we do if the email service is down? How do we trigger an email to be sent?</em></p>

<h2>Rails new</h2>

<p>We created a new Rails 4 app, removed all the stuff we didn&rsquo;t need and created a golden shrine where emails could flourish&hellip;but seriously, that&rsquo;s all it did. And it did it really well.</p>

<p>The next question was how to send emails from the main application. We&rsquo;re very happy <a href="http://sidekiq.org/pro/">Sidekiq Pro</a> users, and one of the benefits we love about Sidekiq is the built-in retries. This gives us a layer of reliability outside of the code layer. So rather than build some ad-hoc retry mechanism by creating a counter in ruby, and rescuing failures within a certain range, we shoot off a job. If it fails because the network is down, or the endpoint isn&rsquo;t available, the job will retry soon after and continue down the happy path. Sidekiq retries are a recurring theme with our infrastructure. We&rsquo;ve made a number of decisions around the fact that we have this advantage already built-in, and we might as well take advantage of it. More on that to come.</p>

<h2>Communicate</h2>

<p>The defacto communication method between services is over HTTP. And we did nothing different. Our services use JSON payloads to exchange data, which let&rsquo;s us easily take advantage of Sidekiq on both ends.</p>

<p>So now, rather than invoking a built-in Rails mailer like:</p>

<figure class='code'><pre><code>UserMailer.welcome(current_user).deliver</code></pre></figure>


<p>we invoke a PORO to send off the communication:</p>

<figure class='code'><pre><code>Email.to current_user, :user_welcome</code></pre></figure>


<p>where <code>Email</code> is defined as</p>

<figure class='code'><pre><code>class Email
  def initialize(users, email_key, opts)
    @users, @email_key, @opts = users, email_key, opts
  end

  def self.to(users, email_key, opts = {})
    new(users, email_key, opts).queue_email
  end

  def queue_email
    opts[:email_key] = email_key
    opts[:to] ||= email_array
    opts[:name] ||= first_users_name
    opts[:user_id] ||= user_id
    opts[:account_id] ||= account_id

    json = JSON.generate(opts)
    RestClient.post(ENV["PIPELINE_EMAIL_URL"], json, :content_type =&gt; :json)
  end
end</code></pre></figure>


<p>There&rsquo;re a number of use-case specific variables above, but the <code>email_key</code> is probably the most important. We used that to describe what email should be invoked on the service.</p>

<p>In the above example, we triggered the <code>welcome</code> email on the <code>UserMailer</code> class. We translated this request into an email key of <code>user_welcome</code>.</p>

<p>This key then gets interpreted by the Email service app and turned into an actual <code>Mailer</code> class and method within it. We could have done this in a variety of ways, but we split the string on the service-side at the <code>_</code>, and the first element described the mailer, the rest the method. So in this case, it gets interpreted as <code>UserMailer#welcome</code>.</p>

<p>One thing this pattern allowed us to do was almost full copy/paste the old mailer methods in to the new Email service application.</p>

<h2>Failures, failures, failures</h2>

<p>&ldquo;What if the service is down?&rdquo; you say, &ldquo;the email request will fail!&rdquo; Sure will.</p>

<p>So let&rsquo;s wrap that request in a Sidekiq job to take advantage of the built-in retries.</p>

<p>Rather than invoke the following method in the email object:</p>

<figure class='code'><pre><code>RestClient.post(ENV["PIPELINE_EMAIL_URL"], json, :content_type =&gt; :json)</code></pre></figure>


<p>we&rsquo;ll shoot off a Sidekiq job instead, changing the <code>queue_email</code> method to:</p>

<figure class='code'><pre><code>def queue_email
  opts[:email_key] = email_key
  opts[:to] ||= email_array
  opts[:name] ||= first_users_name
  opts[:user_id] ||= user_id
  opts[:account_id] ||= account_id

  EmailWorker.perform_async(opts)
end</code></pre></figure>


<p>There we have it. Network-proof email requests!</p>

<p>Not so fast&hellip;</p>

<p>Astute readers will probably recognize that the service-side network communication can potentially also fail. This is becoming a pattern, huh? More communication, more potential for failure and more potential headaches.</p>

<p>On the <strong>service side</strong>, we have a controller that takes in the request for the email and immediately serializes it to a Sidekiq job:</p>

<figure class='code'><pre><code>  def create
    EmailWorker.perform_async(parsed_params)
    head :accepted
  end

  private

  def parse_params
    JSON.parse(request.body) || {}
  end
end</code></pre></figure>


<p>Because we immediately serialize the job to Sidekiq, we&rsquo;ve successfully acknowledged the job was received, and the main app&rsquo;s Sidekiq job completes successfully. Now the email service can move on to doing the heavy-lifting in whatever way makes the most sense. In our case, we use Mailgun to send our emails, so the <code>EmailWorker</code> Sidekiq job invokes a new mailer based on the <code>email_key</code> param and sends it off to mailgun for transport. And because it&rsquo;s wrapped in a Sidekiq job, we can sleep well knowing that the Mailgun request can fail and the job will successfully retry until it goes through.</p>

<h2>Summary</h2>

<p>Service communication is definitely not for the faint of heart and as a team, we can completely appreciate the challenges that come along with keeping services in sync now&mdash;especially having stood up about 8 new services in the last 12 months.</p>

<p>Sidekiq has been the queueing solution we&rsquo;ve leaned on to keep communication in sync and reliable. We&rsquo;ve also written a few internal tools that piggy-backy off Sidekiq that we&rsquo;re really excited share with the community in the near future.</p>

<p>Part II, in this series, will discuss the methods of communication necessary to consider when implementing a service-based architecture.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Ruby Book Bundle Is Live]]></title>
    <link href="http://brandonhilkert.com/blog/the-ruby-book-bundle-is-live/"/>
    <updated>2015-07-06T07:01:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/the-ruby-book-bundle-is-live</id>
    <content type="html"><![CDATA[<p>Afew fellow authors and friends of mine have put together the <a href="http://rubybookbundle.com/?c=bh">Ruby Book Bundle</a> includingsome of the best Ruby/Rails books out there.The <a href="http://rubybookbundle.com/?c=bh">bundle went on sale this morning</a>! It&#8217;ll<strong>only be available for a week</strong>, so be sure to pick it up soon if you&rsquo;re interested.</p>

<!--more-->


<p><img class="center" src="http://brandonhilkert.com/images/ruby-book-bundle.png" title="&#34;The Ruby Book Bundle&#34;" alt="&#34;The Ruby Book Bundle&#34;"></p>

<p>Here&rsquo;s a quick rundown of the details:</p>

<p><strong>Is this bundle right for me?</strong></p>

<p>The books in the Ruby BookBundle span a range from beginner to advanced developers.<strong>As long as you understand the Ruby basics, though, youll learn a lot from these books.</strong></p>

<p>Youll probably get the<em>most</em>out of the bundle if youre an intermediate Ruby dev, focused on building more specific development skills. But if youre interested in mastering the most important and most challenging parts of Rails, like testing, refactoring, gem-building, metaprogramming/DSL-writing, and app-building, this bundle will be perfect for you.</p>

<h2>What will I get?</h2>

<p>When you buy the bundle, youll immediately get the following to download:</p>

<ul>
<li><strong>Build a Ruby Gem</strong>(pdf, epub, mobi) with source code and screencasts</li>
<li><strong>Minitest Cookbook</strong>(pdf, epub, mobi) and source code examples</li>
<li><strong>Practicing Rails</strong>(pdf, epub, mobi)</li>
<li><strong>Fearless Refactoring</strong>(pdf)</li>
<li><strong>Ruby DSL Handbook</strong>(pdf, epub, mobi) with cheat sheets, sample code and screencasts</li>
<li><strong>Rebuilding Rails</strong>(pdf)</li>
</ul>


<h2>How long will the sale run?</h2>

<p>The bundle will be <strong>available for 1 week only</strong> &ndash; ending<strong>July 10th, 11:59PM PDT</strong>.</p>

<h2>What if Im not happy with the bundle?</h2>

<p>We want you to be happy with what youve bought!<strong>So if youre not 100% satisfied with the value you got from the bundle, shoot mean email at<a href="mailto:brandonhilkert%2Bbundle@gmail.com">brandonhilkert+bundle@gmail.com</a>within 30 days, and Ill refund your money.</strong></p>

<p>I feel fortunate to be part of such a great group of developers. They&rsquo;ve
provided a ton of value to the community and their books continue to impress
me.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Organizing Javascript in Rails Application with Turbolinks]]></title>
    <link href="http://brandonhilkert.com/blog/organizing-javascript-in-rails-application-with-turbolinks/"/>
    <updated>2015-06-30T16:10:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/organizing-javascript-in-rails-application-with-turbolinks</id>
    <content type="html"><![CDATA[<p>It&rsquo;s impossible to escape Javascript in a Rails application. From a tiny script to a full-on Javascript framework, websites are becoming more and more reliant on Javascript, whether we like it or not.</p>

<p>Several articles back, I documented <a href="http://brandonhilkert.com/blog/page-specific-javascript-in-rails/">how I handle page-specific Javascript in a Rails application</a>. My solution included a third-party jQuery plugin that did some magic on the <code>$(document).ready</code> function in combination with CSS style scoping to limit the functionality.</p>

<!--more-->


<p>The plugin worked well for awhile, but with the advent of Turbolinks, the
solution felt less and less appropriate. I&rsquo;ve since settled on some techniques
to not only handle page-specific Javascript, but overall organization and structure of Javascript within a Rails application. I&rsquo;ve used it in a hand full of large applications over the past few months and it&rsquo;s held up incredibly well.</p>

<h2>The Problem</h2>

<p>Using &ldquo;sprinkles&rdquo; of Javascript throughout a Rails application can get unwieldly fast if we&rsquo;re not consistent. What we ideally want is some techniques and guidelines that can keep the Javascript organized in our projects. <strong>We also don&rsquo;t want to have to disable Turbolinks to make our application work as we expect</strong>.</p>

<h2>The Solution</h2>

<p>Generally, javascript behavior can be boiled down to the following categories:</p>

<ol>
<li>Behavior that&rsquo;s &ldquo;always on&rdquo;</li>
<li>Behavior that&rsquo;s triggered from a user action</li>
</ol>


<p>But first, a few things to will help us stay organized&hellip;</p>

<h2>Class Scoping</h2>

<p>I still like to scope the body element of the layout(s) with the controller and action name:</p>

<figure class='code'><pre><code>&lt;body class="&lt;%= controller_name %&gt; &lt;%= action_name %&gt;"&gt;
  &lt;%= yield %&gt;
&lt;/body&gt;</code></pre></figure>


<p>This not only let&rsquo;s us control access to the DOM through jQuery if we need to, but also provides some top-level styling classes to allow us to easily add page-specific CSS.</p>

<p>In the case we&rsquo;re working on the proverbial blog posts application, the body tag ends up looking like:</p>

<figure class='code'><pre><code>&lt;body class="posts index"&gt;
  &lt;%= yield %&gt;
&lt;/body&gt;</code></pre></figure>


<p>This gives us the opportunity to scope CSS and Javascripts to all <code>posts</code>-related pages in the controller with the <code>.posts</code> class, or down to the specific page using a combination of both the controller and action: <code>.posts.index</code>.</p>

<h2>Default Application Manifest</h2>

<p>Here&rsquo;s the default <code>app/assets/javascripts/application.js</code>:</p>

<figure class='code'><pre><code>// This is a manifest file that'll be compiled into application.js, which will include all the files
// listed below.
//
// Any JavaScript/Coffee file within this directory, lib/assets/javascripts, vendor/assets/javascripts,
// or any plugin's vendor/assets/javascripts directory can be referenced here using a relative path.
//
// It's not advisable to add code directly here, but if you do, it'll appear at the bottom of the
// compiled file.
//
// Read Sprockets README (https://github.com/rails/sprockets#sprockets-directives) for details
// about supported directives.
//
//= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .</code></pre></figure>


<p>I start by removing the line <code>//= require_tree .</code>. I do this because if you don&rsquo;t, the javascript files in the folder will be loaded in alphabetical order. As you&rsquo;ll see below, there&rsquo;s an initialization file that needs to be loaded before other Javascript. We&rsquo;ll also remove the comments from the top of the file to preserve space.</p>

<p>So we&rsquo;re left with:</p>

<figure class='code'><pre><code>//= require jquery
//= require jquery_ujs
//= require turbolinks</code></pre></figure>


<h2>Initialization</h2>

<p>Let&rsquo;s start by adding the file <code>app/assets/javascripts/init.coffee</code> with the following:</p>

<figure class='code'><pre><code>window.App ||= {}

App.init = -&gt;
  $("a, span, i, div").tooltip()

$(document).on "page:change", -&gt;
  App.init()</code></pre></figure>


<p>Let&rsquo;s dig in to each pagef of this:</p>

<figure class='code'><pre><code>window.App ||= {}</code></pre></figure>


<p>We&rsquo;re creating the <code>App</code> object on window so the functionality added to the object is available throughout the application.</p>

<p>Next, we define an <code>init()</code> function on <code>App</code> to initialize common jQuery plugins and other Javascript libraries:</p>

<figure class='code'><pre><code>App.init = -&gt;
  $("a, span, i, div").tooltip()</code></pre></figure>


<p>The call to <code>$("a, span, i, div").tooltip()</code> initializes Bootstrap Tooltips. This is an example of the type of libraries that can/should be setup here. Obviously, if you&rsquo;re not using Bootstrap tooltips, you would haven&rsquo;t this here, but coupled with the next line, we&rsquo;ll see why this works.</p>

<p>As many have found out the hard way, <strong>when Turbolinks is enabled</strong> in a project, jQuery <code>$(document).ready</code> functions <strong>don&rsquo;t get fired from page to page</strong>. In order to call the <code>init()</code> function on each page transition, we&rsquo;ll hook in to the <code>page:change</code> event:</p>

<figure class='code'><pre><code>$(document).on "page:change", -&gt;
  App.init()</code></pre></figure>


<p><em>Note: the <code>page:change</code> transition is also triggered on the well known document ready event, so there&rsquo;s no need to add any special handling for first page load.</em></p>

<p>Lastly, we need to add <code>init.coffee</code> to the asset pipeline:</p>

<figure class='code'><pre><code>//= require jquery
//= require jquery_ujs
//= require turbolinks
//= require init</code></pre></figure>


<h2>&ldquo;Always On&rdquo; Javascript Functionality</h2>

<p>Now with the defaults out of the way, let&rsquo;s take a look at adding some behavior.</p>

<p>Let&rsquo;s assume one of our pages will show a Javascript graph of data. We&rsquo;ll start by adding a file with a name related to that responsibility.</p>

<figure class='code'><pre><code># app/assets/javascripts/app.chart.coffee

class App.Chart
  constructor: (@el) -&gt;
    # intialize some stuff

  render: -&gt;
    # do some stuff

$(document).on "page:change", -&gt;
  chart = new App.Chart $("#chart")
  chart.render()
</code></pre></figure>


<p>A few things to note here&hellip;</p>

<h3>Structure</h3>

<p>I created a class in the <code>App</code> namespace &mdash; the same we initialized in <code>app/assets/javascripts/init.coffee</code>. This gives us an isolated class that has a clear responsiblity. Like our Ruby, we want to do our best to keep its responsibilities to a minimium.</p>

<p>You might notice the file takes the form:</p>

<figure class='code'><pre><code>|
|
class definition
|
|


|
invocation
|</code></pre></figure>


<p>While this may seem obvious, it&rsquo;s an important point to keep in mind. I&rsquo;ve found it offers a predictable structure that allows me to open any coffeescript file that we&rsquo;ve written in the project and generally know where to look for what.</p>

<h3>Turbolinks-Proof</h3>

<p>We called this &ldquo;Always On&rdquo; functionality because, as you probably noticed, using the following event listener <code>$(document).on "page:change", -&gt;</code>, we know with Turbolinks, this gets triggered on every page transition.</p>

<h3>Add to Manifest</h3>

<p>Because we removed the <code>//= require_tree .</code> line in the default <code>application.js</code> manifest file, we&rsquo;ll have to add our chart file to be included in the asset pipeline (last line):</p>

<figure class='code'><pre><code>//= require jquery
//= require jquery_ujs
//= require turbolinks
//= require init
//= require app.chart</code></pre></figure>


<h3>Page-Specific Javascript</h3>

<p>Uh oh, so maybe we don&rsquo;t want the graph to show up on every page! In this case, we&rsquo;re looking for &ldquo;Always On&rdquo; functionality for specific pages <strong>ONLY</strong>.</p>

<p>We can limit the page pages certain functionality is loaded on by using the classes we added to the body of the layout. In this case, a small conditional to the invocation can prevent this being triggered on pages it shouldn&rsquo;t be.</p>

<figure class='code'><pre><code>$(document).on "page:change", -&gt;
  return unless $(".posts.index").length &gt; 0
  f = new App.Chart $("#chart")
  f.render()</code></pre></figure>


<p>We added <code>return unless $(".posts.index").length &gt; 0</code> to make sure <code>App.Chart</code> never gets instantiated if we&rsquo;re on the <code>.posts.index</code> page. While this may seem verbose, I&rsquo;ve found that it&rsquo;s not very common to need page-specific functionality. There are probably plenty of libraries that do something similar, like <a href="http://brandonhilkert.com/blog/page-specific-javascript-in-rails/">the one I previously suggested</a>. <strong>However, to me, limiting javascript to a single page and very explicit when I read the code, it&rsquo;s almost never worth dragging in a separate plugin for this. YMMV.</strong></p>

<h2>User-Triggered Javascript</h2>

<p>This type of Javascript is exactly what you&rsquo;d think &mdash; Javascript invoked as a result of a user clicking or performing some type of action. You&rsquo;re probably thinking, &ldquo;I know how to do this, I&rsquo;ll just add a random file to the javascripts directory and throw in some jQuery&rdquo;. While this will functionally work just fine, I&rsquo;ve found that keeping the structure of these files similar will give you great piece of mind going forward.</p>

<h3>&ldquo;data-behavior&rdquo; Attribute</h3>

<p>Let&rsquo;s assume there&rsquo;s a link in the user&rsquo;s account that allows them to update their credit card. In this case, we have the following:</p>

<figure class='code'><pre><code>&lt;%= link_to "Update Credit Card", "#", data: { behavior: "update-credit-card" } %&gt;</code></pre></figure>


<p>You&rsquo;ll probably notice the <code>data-behavior</code> tag being added to the link. This is the key we&rsquo;ll use to attach the Javascript behavior.</p>

<p>We could have added a unique class to the link:</p>

<figure class='code'><pre><code>&lt;%= link_to "Update Credit Card", "#", class: "update-credit-card" %&gt;</code></pre></figure>


<p>or, perhaps, even assign an ID:</p>

<figure class='code'><pre><code>&lt;%= link_to "Update Credit Card", "#", id: "update-credit-card" %&gt;</code></pre></figure>


<p>Both of these techniques don&rsquo;t really indicate whether we added the <code>update-card-card</code> for the use of CSS styling, or to attach Javascript behavior. So in my applications, I leave classes for <strong>styling ONLY</strong>.</p>

<p>So now to the Javascript:</p>

<figure class='code'><pre><code>App.Billing =
  update: -&gt;
    # do some stuff

$(document).on "click", "[data-behavior~=update-credit-card]", =&gt;
  App.Billing.update()</code></pre></figure>


<p>We can use the selector <code>[data-behavior~=update-credit-card]</code> to latch on to the <code>data-behavior</code> tag we defined in the view. We use the <code>on</code> jQuery method to ensure that we&rsquo;re listening to this event whether the element&rsquo;s on the page or not. This is what allows us to load this Javascript when on other pages and have it still work when a user clicks through to the page with the actual link on it.</p>

<p>We could latch on to the <code>change</code> event, or whatever is appropriate to the element we&rsquo;re adding behavior.</p>

<h3>Add to Manifest</h3>

<p>Again, because Javascripts assets we add to <code>app/assets/javascripts</code> won&rsquo;t automatically be inserted in to the asset pipeline, we&rsquo;ll add <code>//= require app.billing</code> to the manifest file:</p>

<figure class='code'><pre><code>//= require jquery
//= require jquery_ujs
//= require turbolinks
//= require init
//= require app.chart
//= require app.billing</code></pre></figure>


<h2>Summary</h2>

<p>Using the techniques above, we can keep the Javascript in our Rails applications organized and predictable. We can rest easy knowing the files will all generally look the same. There&rsquo;s not been any uses cases where this structure hasn&rsquo;t worked for me personally.</p>

<p>One thing that makes me feel good about this approach is there&rsquo;s no real magic or extra plugins. It&rsquo;s using all the tools we already have in a basic Rails application, which is one less thing to maintain and keep up to date. Less depedencies == less pain down the road.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Start with Ruby?]]></title>
    <link href="http://brandonhilkert.com/blog/how-to-start-with-ruby/"/>
    <updated>2015-05-06T06:03:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/how-to-start-with-ruby</id>
    <content type="html"><![CDATA[<p>In light of RailsConf last month, I spent some time thinking about my experience learning Ruby and Rails back in 2009. The conference included quite a few seasoned veterans, but like any popular technology, there was also plenty of people that either just started learning Rails, or are considering doing so in the near future.</p>

<p>Turning the clocks back to when you knew much less about something is hard. But putting yourself back in that position can offer valuable insight to the opportunities available and how they might be improved in the future.</p>

<!--more-->


<h2>How I Started</h2>

<p>Most come to the Rails community not knowing much about Ruby. Learning any new technology is hard. And learning a few at the same time is even harder.</p>

<p>This was me in 2009. A relatively new Rails 2.3 app was dropped in to my lap, and despite only having experience with PHP, my job was to aggressively ship new features. I read Agile Web Development with Rails cover to cover and dove in head first. Little did I know it would be one of the best career decisions of my life.</p>

<p>I spent the next few months pounding my head against my desk. The days and weeks of frustration seemed endless. And then&hellip;it just went away. The pain I&rsquo;d endured merged in to an intense desire to dig in harder.  There were more light bulbs moments in the months that followed than any other time I can remember.</p>

<p>During those intense months of frustration, I leaned heavily on the Rails and Philly.rb IRC rooms. In the former, I tried not to say anything too stupid. Fortunately, the latter felt more welcoming and approachable and I owe that group a lot of holding my hand through what might have otherwise been a deathwish for me and the Ruby language.</p>

<p>A few questions pop out in my head&hellip;I was confused about filtering an ActiveRecord query and was surprised to learn methods that were built in to the Ruby language would do exactly what I want. At the time, if it wasn&rsquo;t in ActiveRecord, it might as well have not existed to me.</p>

<p>From someone who <a href="http://brandonhilkert.com/blog/7-reasons-why-im-sticking-with-minitest-and-fixtures-in-rails/">advocates for using tools without fancy DSL&rsquo;s</a>, this is hysterical to me. Ruby, of all things, had the answer. At that point, I&rsquo;m almost certain I&rsquo;d never seen the Ruby standard library documentation.</p>

<h2>Rails Starts Where Ruby Stops</h2>

<p>Out of convenience, Rails does a lot to make our experience with the Ruby language easier than it is out of the box. Like <code>2.hours.ago</code>&hellip;.none of this is possible if Rails doesn&rsquo;t <a href="http://api.rubyonrails.org/classes/Integer.html">monkey patch the <code>Integer</code> class</a>. For someone who doesn&rsquo;t know any better (me in 2009!), being able to calls <code>#hours</code> on an integer just seems like something the language would do. Because Ruby was created for developer happiness, right?</p>

<p>So perhaps the approach of monkey patching doesn&rsquo;t offer a clear indication of where functionality is coming from. The flip side of that argument is convenience. If I had to instantiate a time-related class every time I wanted &ldquo;noon time yesterday&rdquo;, maybe I&rsquo;d be slightly less enthralled with my ability to get stuff done in Rails. Perhaps it would cater more to the true OO neckbeards, but also may have resulted in far less adoption. Who knows!</p>

<p>I don&rsquo;t have strong numbers to back this up, but I&rsquo;m guessing large majority of developers that get paid to write Ruby, due so within the context of a Rails application. And whether we want to admit it or not, a large reason new developers learn Ruby, is to learn Rails. So does it matter that newcomers don&rsquo;t know Ruby?</p>

<p>From the standpoint of creating a web application fast and being able to iterate quickly, maybe not. But certainly if the person is interested in understanding the interworkings of what&rsquo;s happening within the application, knowing where Ruby stops and Rails starts is ideal.</p>

<h2>How to Start?</h2>

<p>I&rsquo;ve talked to quite a few people that are new to Ruby and I always struggle to suggest a good start project when they ask.  Everyone learns differently and has different interests, but in general, I think there are core-level motivating factors that can keep someone focused and interested.</p>

<p>To me, it&rsquo;s the following:</p>

<ol>
<li>Does the project have real-world value?</li>
<li>Does the project offer immediate feedback?</li>
</ol>


<p>Why does it matter if the project has real-world value? For one, continuing on something that doesn&rsquo;t improve our lives is sometimes hard to keep up with. And learning Ruby/Rails is definitely something that&rsquo;ll take more than a few nights and weekends. If the project we&rsquo;re driving towards continues to seem desirable, we&rsquo;ll have a better chance not to lose focus.</p>

<p>Second, I don&rsquo;t want to get too philosophical, but there are plenty of resources that suggest if you want something badly enough and can visualize the end goal, there&rsquo;s a higher likelyhood that it&rsquo;ll come to be. Our desires will be stronger when we can see the end goal and know there is an increased real-world value for this application to be in existence.</p>

<p>The immediate feedback piece shortens the time we&rsquo;re able to see changes and progress. This brings a lower rate of abandonment and better chance we&rsquo;ll see the project through.</p>

<p>Rails answers both of these questions with a resounding, &ldquo;<strong>YES!</strong>&rdquo;. Think about it&hellip;</p>

<p><strong>Does a Rails application have real world value?</strong> Of course it does. It&rsquo;s a web application. There has been no better time to be focused on Rails, where it be for the web and the backend of a mobile app.</p>

<p><strong>Does the project offer immediate feedback?</strong> Sure does! A couple keystrokes and a refresh can give you instant gratifcation in the browser (or the occasional disappointment!).</p>

<p>Whether it&rsquo;s a command-line tool, game, or other utility, I struggle to find other oppotunities to get people started. Frankly, many newcomers to Rails have never used a terminal before. So why would we suggest a command-line application as a good place to start? This is especially true for someone with little programming experience.</p>

<p>For the experienced developer, it&rsquo;d be much easier to suggest writing something like a markdown processor, but only because they have the context of another language. At that point, they&rsquo;re really just comparing the Ruby language to what they already know and figuring out how to translate the things they <em>do</em> know to Ruby.</p>

<p>For a new developer altogether, they would get little value of writing a markdown processor, and in fact, probably seems more like a research project than a sure-fire way to learn a developer-friendly programming language.</p>

<p>So now we&rsquo;re back to suggesting Rails, but then you consider everything else a newcomer would need familiarity with to traverse the Rails eco-stytem: HTML, CSS, Javascript, Coffeescript, Sass, SQL&hellip;</p>

<p>The list goes on and on. Not so easy after all. No wonder people get intimidated and bail. I suppose there&rsquo;s starting with Sinatra, but the doesn&rsquo;t remove you from the HTML and CSS requirements. Perhaps those impossible to dodge, given the medium. And even with Sinatra, we often end up creating the functionality that&rsquo;s in Rails anyway.</p>

<p>I wish I had a better answer.</p>

<p><strong>How would you suggest someone start with Ruby?</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Adding Functionality to Ruby Classes with Decorators]]></title>
    <link href="http://brandonhilkert.com/blog/adding-functionality-to-ruby-classes-with-decorators/"/>
    <updated>2015-03-09T15:37:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/adding-functionality-to-ruby-classes-with-decorators</id>
    <content type="html"><![CDATA[<p>In my <a href="http://brandonhilkert.com/blog/using-the-sucker-punch-ruby-gem-to-cache-stripe-data-in-rails/">last article</a>, I presented some code that wrapped up accessing a customer&rsquo;s Stripe data and added a caching layer on top. I wanted to take some time to dig in to that code and see how we can make it better.</p>

<p>Decorators give us a tool to add additional functionality to a class while still keeping the public API consistent. From the perspective of the client, this is a win-win! Not only do they get the added behavior, but they don&rsquo;t need to call different methods to do so.</p>

<!--more-->


<h2>The Problem</h2>

<p>Our original class accessed data from Stripe <strong>AND</strong> cached the response for some time period. I accentuated &ldquo;AND&rdquo; because it&rsquo;s generally the word to be on alert for when considering whether functionality can be teased apart in to separate responsibilities.</p>

<p>The question becomes, can we make one class that accesses Stripe data, and another that&rsquo;s only responsible for caching it?</p>

<p>Of course we can!</p>

<h2>The Solution</h2>

<p>Let&rsquo;s start with the most basic form of accessing our Stripe customer data with the <a href="https://github.com/stripe/stripe-ruby">Stripe gem</a>:</p>

<figure class='code'><pre><code>class AccountsController &lt; ApplicationController
  before_action :require_authentication

  def show
    @customer = Stripe::Customer.retrieve(current_user.stripe_id)
    @invoices = @customer.invoices
    @upcoming_invoice = @customer.upcoming_invoice
  end
end</code></pre></figure>


<h2>Extract an Adapter</h2>

<p>Because we&rsquo;re interfacing with a third-party system (Stripe), it makes sense for to create a local adapter to access the Stripe methods. It&rsquo;s probably not likely we&rsquo;re going to switch out the official Stripe gem for another one that access the same data, but a better argument might be that we could switch billing systems entirely in the future. And if we make a more generic adapter to our third-party billing system, we would only need to update our adapter when that time comes.</p>

<p>While the adapter optimization may seem like overkill here, we&rsquo;ll see how that generic adapter helps us implement our caching layer shortly.</p>

<p>Let&rsquo;s start by removing the notion that it&rsquo;s Stripe and all and call it <code>Billing</code>. Here we can expose the methods needed from the  <code>AccountsController</code> above:</p>

<figure class='code'><pre><code>class Billing
  attr_reader :billing_id

  def initialize(billing_id)
    @billing_id = billing_id
  end

  def customer
    Stripe::Customer.retrieve(billing_id)
  end

  def invoices
    customer.invoices
  end

  def upcoming_invoice
    customer.upcoming_invoice
  end
end</code></pre></figure>


<p>There we have it. A simple <code>Billing</code> class that wraps the methods that we used in the first place &mdash; no change in functionality. But certainly more organized and isolated.</p>

<p>Let&rsquo;s now use this new class in the accounts controller from earlier:</p>

<figure class='code'><pre><code>class AccountsController &lt; ApplicationController
  before_action :require_authentication

  def show
    billing = Billing.new(current_user.stripe_id)

    @customer = billing.customer
    @invoices = billing.invoices
    @upcoming_invoice = billing.upcoming_invoice
  end
end</code></pre></figure>


<p>Not too bad! At this point we&rsquo;ve provide the exact same functionality we had before, but we have a class that sits in the middle between the controller and Stripe gem &ndash; an adapter if you will.</p>

<h2>Create a Decorator</h2>

<p>Now that we have our adapter set up, let&rsquo;s look at how we can add caching behavior to improve the performance of our accounts page.</p>

<p>The most of basic form of a decorator is to pass in the object we&rsquo;re decorating (<code>Billing</code>), and define the same methods of the billing, but add the additional functionality on top of them.</p>

<p>Let&rsquo;s create a base form of  <code>BillingWithCache</code> that <strong>does nothing more</strong> than call the host methods:</p>

<figure class='code'><pre><code>class BillingWithCache
  def initialize(billing_service)
    @billing_service = billing_service
  end

  def customer
    billing_service.customer
  end

  def invoices
    customer.invoices
  end

  def upcoming_invoice
    customer.upcoming_invoice
  end

  private

  attr_reader :billing_service
end</code></pre></figure>


<p>So while we haven&rsquo;t added any additional functionality, we have created the ability for this class to be used in place of our existing <code>Billing</code> class because it responds to the same API (<code>#customer</code>, <code>#invoices</code>, <code>#upcoming_invoice</code>).</p>

<p>Integrating this new class with <code>AccountsController</code> looks like:</p>

<figure class='code'><pre><code>class AccountsController &lt; ApplicationController
  before_action :require_authentication

  def show
    billing = BillingWithCache.new(Billing.new(current_user.stripe_id))

    @customer = billing.customer
    @invoices = billing.invoices
    @upcoming_invoice = billing.upcoming_invoice
  end
end</code></pre></figure>


<p>As you can see, we only had to change one line &mdash; the line where we decorated the original billing class:</p>

<figure class='code'><pre><code>BillingWithCache.new(Billing.new(current_user.stripe_id))</code></pre></figure>


<p>I know what you&rsquo;re thinking, &ldquo;But it doesn&rsquo;t actually cache anything!&rdquo;. You&rsquo;re right! Let&rsquo;s dig in to the <code>BillingWithCache</code> class and add that.</p>

<h2>Adding Caching Functionality</h2>

<p>In order to cache data using <code>Rails.cache</code>, we&rsquo;re going to need a cache key of some kind. Fortunately, the original <code>Billing</code> class provides a reader for <code>billing_id</code> that will allow us to make this unique to that user.</p>

<figure class='code'><pre><code>def cache_key(item)
  "user/#{billing_id}/billing/#{item}"
end</code></pre></figure>


<p>In this case, <code>item</code> can refer to things like <code>"customer"</code>, <code>"invoices"</code>, or <code>"upcoming_invoice"</code>. This gives us a method we can use internally with <code>BillingWithCache</code> to provide a cache key unique to the both the user and the type of data we&rsquo;re caching.</p>

<p>Adding in the calls to actually cache the data:</p>

<figure class='code'><pre><code>class BillingWithCache
  def initialize(billing_service)
    @billing_service = billing_service
  end

  def customer
    key = cache_key("customer")

    Rails.cache.fetch(key, expires: 15.minutes) do
      billing_service.customer
    end
  end

  def invoices
    key = cache_key("invoices")

    Rails.cache.fetch(key, expires: 15.minutes) do
      customer.invoices
    end
  end

  def upcoming_invoice
    key = cache_key("upcoming_invoice")

    Rails.cache.fetch(key, expires: 15.minutes) do
      customer.upcoming_invoice
    end
  end

  private

  attr_reader :billing_service

  def cache_key(item)
    "user/#{billing_service.billing_id}/billing/#{item}"
  end
end</code></pre></figure>


<p>The code above caches the call to each of these methods for 15 minutes. We could go further and move that to an argument with a default value, but I&rsquo;ll leave as an exercise for another time.</p>

<h2>Summary</h2>

<p>Separating your application and third-party services helps keeps your applications flexible &mdash; offering the freedom to switch to another service when one no longer fits the bill.</p>

<p>Another benefit of an adapter is you have the freedom to name the class and methods whatever you like. The base gem for a service might not have the best names, or it may be that the names don&rsquo;t make sense when dragged in to your application&rsquo;s domain. This is a small but important point as applications get larger and its code more complex. The more variable/method names you need to think about when you poke around the code, the harder it&rsquo;ll be to remember what was going on. Not to mention the pain new developers will have if they acquire the code. Whether it&rsquo;s you or the next developer, the time you invest in creating great names will be greatly appreciated.</p>

<p>Using decorators in this way makes it easier for clients of the code to avoid change, but keep your applications flexible. The <code>Billing</code> class above was relatively simple &mdash; intentionally so. If the class being decorated has more than a few methods, it might be worth incorporating <code>SimpleDelegator</code> to ensure the methods that don&rsquo;t need additional functionality still continue to respond appropriately.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using the Sucker Punch Ruby Gem to Cache Stripe Data in Rails]]></title>
    <link href="http://brandonhilkert.com/blog/using-the-sucker-punch-ruby-gem-to-cache-stripe-data-in-rails/"/>
    <updated>2015-02-26T20:46:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/using-the-sucker-punch-ruby-gem-to-cache-stripe-data-in-rails</id>
    <content type="html"><![CDATA[<p>With so many services available these days, it&rsquo;s almost impossible to find or build an application that doesn&rsquo;t rely on a third-party service. Most developers that have dealt with billing systems within the past few years have likely heard of <a href="https://stripe.com/">Stripe</a>. Stripe is, by far, the most developer-friendly billing service I&rsquo;ve implemented.</p>

<p>While Stripe does provide a number of features and plugins that make updating a credit card or signing up for a service simple, there are occasions when data needs to be fetched from Stripe in real-time. For these cases, it&rsquo;s great to be able to fetch and cache this data before-hand, and only expire if you know there&rsquo;s been a change.</p>

<!--more-->


<p>Combining <a href="https://github.com/brandonhilkert/sucker_punch">Sucker Punch</a> with Rails cache allows you to cache Stripe customer data so that billing pages are just as snappy as the rest of the application.</p>

<h2>The Pain</h2>

<p>Even though Stripe is generally pretty fast, retrieving customer data on the fly can be expensive. In order to optimize page load times, we can look to cache this data before it&rsquo;s actually used.</p>

<p>If you&rsquo;re familiary with the Stripe gem, you&rsquo;ve probably seen something like this:</p>

<figure class='code'><pre><code>customer = Stripe::Customer.retrieve(user.stripe_id)</code></pre></figure>


<p>With the response of <code>customer</code>, we can further query customer data with the following methods:</p>

<figure class='code'><pre><code>invoices = customer.invoices
upcoming_invoices = customer.upcoming_invoices</code></pre></figure>


<p>If we make all 3 of these method calls on page load, we&rsquo;d have 3 separate lookups from Stripe. This is pretty common for the typical billing page where you might want to show the customer&rsquo;s current credit card on file, their past invoices, and charges they can expect for the next invoice.</p>

<p>Three lookups like this could potentially add another second or so to page load, which is not ideal.</p>

<p>So how can we improve this?</p>

<h2>The Solution</h2>

<p>First, we can move the code to fetch the relevant stripe data in to a class of it&rsquo;s own, which wraps the notion of caching around the data retrieval.</p>

<figure class='code'><pre><code>class StripeCache
  def initialize(user)
    @user = user
  end

  def refresh
    purge_all
    cache_all
    self
  end

  def customer
    return @customer if @customer

    @customer = Rails.cache.fetch(cache_key("customer"), expires_in: 15.minutes) do
      Stripe::Customer.retrieve(user.stripe_id)
    end
  end

  def invoices
    Rails.cache.fetch(cache_key("invoices"), expires_in: 15.minutes) do
      customer.invoices
    end
  end

  def upcoming_invoice
    Rails.cache.fetch(cache_key("upcoming_invoice"), expires_in: 15.minutes) do
      customer.upcoming_invoice
    end
  end

  private

  attr_reader :user

  def cache_all
    customer
    invoices
    upcoming_invoice
  end

  def purge_all
    Rails.cache.delete_matched("#{user.id}/stripe")
  end


  def cache_key(item)
    "user/#{user.id}/stripe/#{item}"
  end
end</code></pre></figure>


<p>To use this on a billing page, we could do:</p>

<figure class='code'><pre><code>stripe = StripeCache.new(current_user).refresh</code></pre></figure>


<p>And from the response of that class, we could access the <code>customer</code>, <code>invoices</code>, and <code>upcoming_invoice</code> respectively:</p>

<figure class='code'><pre><code>@customer = stripe.customer
@invoices = stripe.invoices
@upcoming_invoice = stripe.invoices</code></pre></figure>


<p>This is great! All future calls to this customer&rsquo;s Stripe data will be fast &mdash; for 15 minutes, of course.</p>

<p>However, the first time the page is load, the user is still burdened with the initial fetch of the data. So the method above works for every request to the billing page after the first.</p>

<p>But let&rsquo;s be honest, what users are going to the billing page multiple times during a session? Probably not many. So we still need to fix the initial load somehow.</p>

<p>This is where <a href="https://github.com/brandonhilkert/sucker_punch">Sucker Punch</a> comes in. Like other Ruby background processing libraries, Sucker Punch allows you to move the processing of code to the background. However, unlike the others, Sucker Punch doesn&rsquo;t require additional infrastructure like Redis, and doesn&rsquo;t require a separate worker process to monitor and execute enqueued jobs. Because of this, the time it takes to extract code to a Sucker Punch job and have it incorporated with your application code is much lower.</p>

<p>In this case, rather than send a transactional email or perform some database calculation, we can write a job thats only responsibility is to run the Stripe caching code.</p>

<figure class='code'><pre><code>class StripeCacheJob
  include SuckerPunch::Job

  def perform(user)
    StripeCache.new(user).refresh
  end
end</code></pre></figure>


<p>The next question is, when do you run this?</p>

<p>Well, I chose to run it on user login, but you could run it anywhere you think would give you a head start if the user were about to go to the billing page. In my case, on login meant that if they didn&rsquo;t go to the billing page at all, after 15 minutes the data would be exhausted from the cache anyway, so no hard done.</p>

<p>But if the user did navigate to the billing page during that session, they would have up the latest Stripe customer and invoice data to see &mdash; all without a request to stripe on page load.</p>

<p>One other thing to keep in mind is there may be times when we&rsquo;d want invalidate the Rails cache data. One example would be when the user&rsquo;s card information is updated. In that case, we can slip in another call to the Stripe cache job, which would invalidate the previous cache and re-request the customer&rsquo;s billing information:</p>

<figure class='code'><pre><code>module Accounts
  class CardsController &lt; ApplicationController
    before_action :require_authentication

    def create
      cust = StripeCache.new(current_user).customer
      cust.save(card: params[:stripeToken])

      StripeCacheJob.new.async.perform(current_user)

      redirect_to account_path, notice: t("card.update.success")
    end
  end
end</code></pre></figure>


<h2>Summary</h2>

<p>Using Sucker Punch in combination with Rails cache feels like a great way make optimizations to third-party data requests. This article focused on using it to fetch Stripe data, but it could be used with another service just as easily.</p>

<p>The beauty of Sucker Punch is that it doesn&rsquo;t require a separate worker process to be running in the background. On a platform like Heroku, this saves the cost of an additional dyno.</p>

<p>Sucker Punch excels at background jobs that are relatively fast and if missed,
wouldn&rsquo;t be critical to the operation. In this case, if a cache job is lost,
it&rsquo;s not the end of the world. At worst, the user&rsquo;s Stripe data would be requested on the fly and the page would be slower than usual. But the majority of the time, the request is fast because the data&rsquo;s been cached beforehand.</p>

<p>What other jobs have you used Sucker Punch for?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Rails Fixtures To Seed a Database]]></title>
    <link href="http://brandonhilkert.com/blog/using-rails-fixtures-to-seed-a-database/"/>
    <updated>2015-02-04T06:13:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/using-rails-fixtures-to-seed-a-database</id>
    <content type="html"><![CDATA[<p>Its no mystery that <a href="http://brandonhilkert.com/blog/7-reasons-why-im-sticking-with-minitest-and-fixtures-in-rails/">Ive grown to love Rails fixtures</a>. And I tend to mostly use relational databases in my applications, <a href="http://brandonhilkert.com/blog/rails-gemfile-teardown-2014/">specifically PostgreSQL</a>.</p>

<p>Most applications have ancillary data thats required to support the main function of the application  think drop-downs with states for shipping or credit card type.</p>

<!--more-->


<p>This data is almost always never interesting, but completely necessary for the application to work as expected. So when it comes to time send your little baby to production, only to find your users cant pay because they cant pick their credit card type, your world comes crashing down.</p>

<p>If you have those credit card types in fixtures from the start, loading them in to your development of production database is just a <code>rake</code> task away.</p>

<h2>The Problem</h2>

<p>Lets assume our application requires us have a list of supported credit card types, and the user is required to pick from the list to pay for the awesome stuff we sell. A sample fixture might look like:</p>

<figure class='code'><pre><code>visa:
  name: Visa

mastercard:
  name: Mastercard

amex:
  name: American Express</code></pre></figure>


<p>This is a somewhat trivial example because the <code>name</code> matches what one might expect in a potential transaction record if we had a <code>credit_card_type</code> field or something similar if we denormalized.</p>

<p>Perhaps we have a field <code>credit_card_type_id</code> in a <code>transactions</code> table that references the foreign key of the related <code>CreditCardType</code> record.</p>

<p>So how do we get these records in to our development and production databases?</p>

<h2>The Solution</h2>

<p>Fortunately, Rails has our backs. The following rake test is available from a default Rails application:</p>

<figure class='code'><pre><code>$ bin/rake -T
...
rake db:fixtures:load # Load fixtures into the current environment's database</code></pre></figure>


<p>The <code>db:fixtures:load</code> task is an interesting start, but quickly we realize it might be a little heavy-handed. If this application has users, we probably wouldn&rsquo;t want to copy them to production. They might, however, be a great starting pointing for development.</p>

<p>So how do we handle getting trivial model data in to production for only specific models?</p>

<p>It turns out that we can specify <strong>ONLY</strong> the models we want to load by using the <code>FIXTURES</code> environment variable:</p>

<figure class='code'><pre><code>rake db:fixtures:load FIXTURES=credit_card_types</code></pre></figure>


<p><em>Note: The name of the fixture file (usually the database table name) should be used as the value for <code>FIXTURES</code>, not the model name.</em></p>

<p>With that single command, any environment we specify will immediately get the data for our 3 credit card types.</p>

<p>A word of warning, if we run this command multiple times, it will seed the table multiple times. It&rsquo;s not idempotent.</p>

<p>Additionally, if we wanted to load more than just a single fixture, we can specify the names of the files separated by commas:</p>

<figure class='code'><pre><code>rake db:fixtures:load FIXTURES=credit_card_types,states,cities</code></pre></figure>


<p>Let&rsquo;s take a quick look at how Rails implements this functionality, specifically the determination of single models:</p>

<figure class='code'><pre><code>fixtures_dir = if ENV['FIXTURES_DIR']
                 File.join base_dir, ENV['FIXTURES_DIR']
               else
                 base_dir
               end

fixture_files = if ENV['FIXTURES']
                  ENV['FIXTURES'].split(',')
                else
                  # The use of String#[] here is to support namespaced fixtures
                  Dir["#{fixtures_dir}/**/*.yml"].map {|f| f[(fixtures_dir.size + 1)..-5] }
                end

ActiveRecord::FixtureSet.create_fixtures(fixtures_dir, fixture_files)</code></pre></figure>


<p>If the <code>FIXTURES</code> variable is present, code teases appart the model names and looks in the fixtures directory and loads the YAML fixture file for that table name.</p>

<p>An interesting side note, it&rsquo;s possible to specify alternate directories for fixture using the <code>FIXTURES_DIR</code> variable. I personally haven taken advantage of this, but could be useful if you want to keep specific fixture files for production that might be different than those that reside in <code>test/fixtures/*</code>.</p>

<p>I wouldn&rsquo;t suggesting using this approach for anything that needs to reference other foreign keys. When you&rsquo;re transferring to a different database, foreign keys will not match and your application will likely not work as expected.</p>

<h2>Summary</h2>

<p>This approach has saved me quite a bit of time in my last few applications. Build it once, use it everywhere. As mentioned above, using this approach to seed database records  with a foreign key should be avoided.</p>

<p>Most applications have a number of tasks needed for a developer to get up and running. Combining fixture data with additional seed data placed in <code>db/seeds.rb</code> can give you the best of both worlds, while still ensuring you have robust data to test against.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2014 In Review]]></title>
    <link href="http://brandonhilkert.com/blog/2014-in-review/"/>
    <updated>2014-12-29T14:57:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/2014-in-review</id>
    <content type="html"><![CDATA[<p>For the past 2 years, Ive committed myself to <a href="http://brandonhilkert.com/blog/be-ambitious/">specific
goals</a> for the year to come. Most
people call them New Years Resolutions. Heck, I probably even referred to them
as resolutions too. But the more I thought about it, the more it dawned on me
that a resolution felt more like a fix for something  something that didn&rsquo;t
go well in the previous year. Think weight loss (everyone makes this resolution at least once in their life) or a dedication to be more focused.</p>

<!--more-->


<p>Mine have been more of the bucket list variety. The first was <a href="http://brandonhilkert.com/blog/loyalty/">completing an Ironman</a>. The second, <a href="http://brandonhilkert.com/blog/be-ambitious/">writing a book</a>.</p>

<p>Both felt almost too big initially, but ultimately led to opportunities and
lifestyle changes I wouldve never expected once finished. So naturally, with
2014 winding down, the question becomes <strong>&ldquo;whats the goal for 2015?&rdquo;</strong>.</p>

<p>And the answer is&hellip;<em>I dont know</em>.</p>

<p>It doesnt mean Im not going to do anything. In fact, it probably means the
opposite. Im just not going to set out with a specific goal in mind. If
halfway through something, I want to stop and do something else, so be it.</p>

<p>I remember during my training for the Ironman (9 months total), I constantly thought about what I would do with my free time when it was over. Every time my alarm went off at 5am, I thought about what it would feel like to get another 2 hours of sleep. It was endless. Nine months was a long time to have those thoughts and, perhaps, why I was so well positioned to write and launch the book (I had 9 months to think about what was next and how to accomplish it).</p>

<p>Always having your sights set on the future can wear on you though.</p>

<p>Without those feelings now, Im going to let 2015 take me wherever it does. I dont have any expectations financially or professionally. Im going to do my best to make the most out of every moment and appreciate more of the small things. Its so easy to skip over the small things and in many cases, the small things are actually the best things. And we dont realize it until theyre gone.</p>

<p>2014 was a great year in all. Here are a few of the events that stand out the most:</p>

<ul>
<li>my wife and I <a href="http://brandonhilkert.com/about/">welcomed our son, Cruz</a></li>
<li>my wife and I celebrated our 4 year anniversary</li>
<li>wrote a book, <a href="http://brandonhilkert.com/books/build-a-ruby-gem/">Build a Ruby Gem</a></li>
<li>provided a <a href="http://brandonhilkert.com/courses/build-a-ruby-gem/">free email course on building a Ruby gem</a> to 1,218 people</li>
<li>connected with 2,645 people through my <a href="http://brandonhilkert.com/newsletter/">newsletter</a></li>
<li>built a <a href="https://funneloptimizer.herokuapp.com/">funnel optimization service for bloggers selling
  products</a></li>
<li>published 24 <a href="http://brandonhilkert.com/blog/archives/">articles</a></li>
<li>saw <a href="https://github.com/brandonhilkert/sucker_punch">Sucker Punch</a> <a href="https://rubygems.org/gems/sucker_punch">downloaded over 225k times</a></li>
<li>celebrated <a href="https://github.com/brandonhilkert/sucker_punch">Sucker Punch</a> being <a href="http://guides.rubyonrails.org/active_job_basics.html">integrated in to Rails</a></li>
<li>made my <a href="https://github.com/rails/rails/pull/16898">first commit to Rails</a> (even if it was small!)</li>
<li>traveled to Jackson Hole, WY</li>
<li>built a <a href="https://vuier.com/">pay-to-view video platform</a> with a few friends</li>
<li>built a <a href="https://perform.io/">performance management system</a></li>
<li>renovated my
  <a href="http://brandonhilkert.com/images/2014/bathroom-before.jpg">kids&#8217;</a>
  <a href="http://brandonhilkert.com/images/2014/bathroom-after.jpg">bathroom</a></li>
<li>built a deployment system for <a href="https://www.pipelinedeals.com/">PipelineDeals</a> and supporting services that Im very proud of</li>
<li>built a staging server management application</li>
<li>built <a href="https://chrome.google.com/webstore/detail/how-to-win-friends-and-in/cbmeigkjdnilgodhnhagokhoehbpkdcc?hl=en-US">3</a> <a href="https://chrome.google.com/webstore/detail/pipelinedeals-crm-contact/ieaafnaonfabpgpkkeglkeodkpiijjdd?hl=en-US">chrome</a> <a href="https://chrome.google.com/webstore/detail/pipelinedeals-gmail/fdfifknmbmalmgdjmnhkcfholdgacikl?hl=en-US">extensions</a>, the latter being my first <a href="http://facebook.github.io/react/">React</a> app</li>
<li>started a <a href="http://walnutstlabs.com/event/walnut-st-labs-night-owls/">weekly tech gathering</a> at a <a href="http://walnutstlabs.com">local co-working space</a></li>
<li>stopped push email notifications on all my devices (strongly recommended)</li>
<li>saw <a href="http://defriendnotifierapp.com/">Defriend Notifier</a> be used by 30,128 people</li>
<li>started exploring other programming languages, specifically <a href="https://golang.org/">Go</a> and <a href="http://elixir-lang.org/">Elixir</a></li>
</ul>


<p>Im excited for 2015!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Ruby Refactor: Dependency Injection Options]]></title>
    <link href="http://brandonhilkert.com/blog/a-ruby-refactor-exploring-dependency-injection-options/"/>
    <updated>2014-12-17T07:07:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/a-ruby-refactor-exploring-dependency-injection-options</id>
    <content type="html"><![CDATA[<p>I recently wrote some code to interface with Stripes webhooks. After looking at the code and tests, I decided I needed to do something to make it easier to test <em>all</em> pricing tiers something I wasnt able to easily do from the start.</p>

<p><a href="http://en.m.wikipedia.org/wiki/Dependency_injection">Dependency injection</a> was a necessary piece of that puzzle. Ive always been curious about the various forms of dependency injection and the effects each would have on the code. Below I explore 2 options (constructor injection and setter injection).</p>

<!--more-->


<p>In the end, setter injection felt for more natural for this case and it didnt interfere with the classes argument list and felt ancillary to the responsibility of the code. While the change in code was small, it has a huge impact on my confidence in the code and associated tests.</p>

<h2>The Code</h2>

<p>The class below is responsible for handling Stripes <code>invoice.created</code> webhook. Prior to a customer being billed monthly subscription, Stripe will ping your application (if configured)  giving you the opportunity to add additional line items (think metered billing). It could be additional services, or perhaps the entire bill itself (this use case). Nevertheless, the responsibility of the class is to create an invoice item based on the customers usage during the previous period.</p>

<figure class='code'><pre><code>module StripeEvent
  class InvoiceCreated
    attr_reader :payload

    def initialize(payload)
      @payload = payload
    end

    def perform
      Stripe::InvoiceItem.create(
        customer: user.stripe_id,
        amount: additional_charges_in_cents,
        currency: "usd",
        description: "Usage charges"
      )
    end

    private

    def additional_charges_in_cents
      Billing::Tier.new(usage).additional_charges_in_cents
    end

    def usage
      Billing::Usage.new(user).last_30_days
    end

    def user
      @user ||= User.find_by(stripe_id: payload["data"]["object"]["customer"])
    end
  end
end</code></pre></figure>


<p>I wrote this code pretty quickly and felt pretty good about it. The responsibility of determining the pricing tier had been broken out in to a separate class, as well as determining the customers actual usage. At least I thought they were</p>

<p>So what about the tests?</p>

<figure class='code'><pre><code>require 'test_helper'

class InvoiceCreatedTest &lt; ActiveSupport::TestCase
  def setup
    @payload = {
      "data" =&gt; {
        "object" =&gt; {
          "customer" =&gt; "stripe_brandon"
        }
      }
    }
  end

  test 'adds invoice item based on usage' do
    Stripe::InvoiceItem.expects(:create).with(
      customer: "stripe_brandon",
      amount: 1900,
      currency: "usd",
      description: "Usage charges"
    ).returns(true)
    StripeEvent::InvoiceCreated.new(@payload).perform
  end

  test 'adds next level charge for usage' do
    Stat.create!(user: users(:brandon), step: steps(:nav_one), impressions: 3_000, date: 5.days.ago)

    Stripe::InvoiceItem.expects(:create).with(
      customer: "stripe_brandon",
      amount: 4900,
      currency: "usd",
      description: "Usage charges"
    ).returns(true)
    StripeEvent::InvoiceCreated.new(@payload).perform
  end
end</code></pre></figure>


<p>The first thing I noticed with this setup was the detailed usage of <code>Stripe::InvoiceItem.expects</code>. I wasnt sure if this was necessarily a bad thing because it was a third-party service and it seemed like reasonable boundary of the application.</p>

<p>Aside from the mock, another thing that bothered me was the difficulty simulating different pricing tiers and customer usage. You probably noticed the <code>Stat.create!</code> in the last test. I couldve duplicated <code>Stat</code> entries until I reached some arbitrary level of usage that bumped this user to the next pricing tier. But that felt risky and very dependent on knowing the actual value of the subsequent tier.</p>

<p>What if I wanted to change the ceiling of that tier next month? Id have to come in here and adjust the stats being created until it totaled something above the adjustment. It just felt weird</p>

<p>What if we had a way to easily swap in implementations of the <code>Billing::Usage</code>? It would then allow me to concoct any combination of usage and mock the expected values sent to Stripe.</p>

<h2>Setter Injection</h2>

<p>In a few other articles, Ive heard this termed accessors as collaborators. Whatever the name, it was surprising how such a little a change could produce so much flexibility in my tests. And with that additional flexibility came confidence because it allowed me to test the edge cases with minimal overhead.</p>

<figure class='code'><pre><code>module StripeEvent
  class InvoiceCreated
    attr_writer :usage_service
    attr_reader :payload

    def initialize(payload)
      @payload = payload
    end

    def perform
      if user.created_at &lt; 14.days.ago
        Stripe::InvoiceItem.create(
          customer: user.stripe_id,
          amount: additional_charges_in_cents,
          currency: "usd",
          description: "Usage charges"
        )
      end
    end

    private

    def additional_charges_in_cents
      Billing::Tier.new(usage).additional_charges_in_cents
    end

    def usage
      usage_service.last_30_days
    end

    def usage_service
      @usage_service ||= Billing::Usage.new(user)
    end

    def user
      @user ||= User.find_by(stripe_id: payload["data"]["object"]["customer"])
    end
  end
end</code></pre></figure>


<p>A couple things changed:</p>

<ol>
<li><p><code>usage_service</code> was created to extract the code to calculate customer usage</p></li>
<li><p>The <code>usage</code> method now calls the <code>last_30_days</code> method on <code>usage_service</code></p>

<p> This is interesting because youll notice now that the only important idea about <code>usage_service</code> is the   fact that is has a <code>last_30_days</code> method. We can now take comfort in the idea that <code>usage_service</code> could    be anything really, as long as it implements the <code>last_30_days</code> method.</p></li>
<li><p><code>attr_writer :usage_service</code> was added to allow for other implementations of the usage class</p></li>
</ol>


<p>This allows us to inject other forms of the <code>usage_service</code> to simulate more or less customer usage:</p>

<figure class='code'><pre><code>require 'test_helper'

class InvoiceCreatedTest &lt; ActiveSupport::TestCase
  def setup
    @payload = {
      "data" =&gt; {
        "object" =&gt; {
          "customer" =&gt; "stripe_brandon"
        }
      }
    }
  end

  test 'adds invoice item based on usage' do
    Stripe::InvoiceItem.expects(:create).with(
      customer: "stripe_brandon",
      amount: 1900,
      currency: "usd",
      description: "Usage charges"
    )
    StripeEvent::InvoiceCreated.new(@payload).perform
  end

  test 'adds next level charge for usage' do
    Stat.create!(user: users(:brandon), step: steps(:nav_one), impressions: 3_000, date: 5.days.ago)

    Stripe::InvoiceItem.expects(:create).with(
      customer: "stripe_brandon",
      amount: 4900,
      currency: "usd",
      description: "Usage charges"
    )
    StripeEvent::InvoiceCreated.new(@payload).perform
  end

  test 'adds highest tier' do
    Stripe::InvoiceItem.expects(:create).with(
      customer: "stripe_brandon",
      amount: 49900,
      currency: "usd",
      description: "Usage charges"
    )
    inv = StripeEvent::InvoiceCreated.new(@payload)
    inv.usage_service = Level5Usage.new
    inv.perform
  end

  test 'adds 2nd highest tier' do
    Stripe::InvoiceItem.expects(:create).with(
      customer: "stripe_brandon",
      amount: 24900,
      currency: "usd",
      description: "Usage charges"
    )
    inv = StripeEvent::InvoiceCreated.new(@payload)
    inv.usage_service = Level4Usage.new
    inv.perform
  end

  test 'adds middle tier' do
    Stripe::InvoiceItem.expects(:create).with(
      customer: "stripe_brandon",
      amount: 12900,
      currency: "usd",
      description: "Usage charges"
    )
    inv = StripeEvent::InvoiceCreated.new(@payload)
    inv.usage_service = Level3Usage.new
    inv.perform
  end

  test 'adds 2nd tier' do
    Stripe::InvoiceItem.expects(:create).with(
      customer: "stripe_brandon",
      amount: 4900,
      currency: "usd",
      description: "Usage charges"
    )
    inv = StripeEvent::InvoiceCreated.new(@payload)
    inv.usage_service = Level2Usage.new
    inv.perform
  end

  test 'adds 1st tier' do
    Stripe::InvoiceItem.expects(:create).with(
      customer: "stripe_brandon",
      amount: 1900,
      currency: "usd",
      description: "Usage charges"
    )
    inv = StripeEvent::InvoiceCreated.new(@payload)
    inv.usage_service = Level1Usage.new
    inv.perform
  end

  private

  Level5Usage = Class.new { def last_30_days; 2_000_000; end }
  Level4Usage = Class.new { def last_30_days; 900_000; end }
  Level3Usage = Class.new { def last_30_days; 190_000; end }
  Level2Usage = Class.new { def last_30_days; 19_000; end }
  Level1Usage = Class.new { def last_30_days; 1_900; end }</code></pre></figure>


<p>Ive created classes for each usage tier that implement the <code>last_30_days</code> method. In real life, this usage service is more complex, but we can test the complexity of it alone through unit tests. The responsibility of this class is to ensure invoice items are added to Stripe correctly, so removing the complexity of <code>Billing::Usage</code> form this test allows us to maximize this tests value and keep us isolated from the implementation of <code>Billing::Usage</code>  assuming it implements the <code>last_30_days</code> method.</p>

<h2>Constructor Injection</h2>

<p>Most dependency injection posts focus on constructor injection. The idea being that an implementation can be supplied. If not, a reasonable default will be provided. How might that change this scenario?</p>

<figure class='code'><pre><code>module StripeEvent
  class InvoiceCreated
    attr_reader :payload

    def initialize(payload, usage_service = Billing::Usage)
      @payload = payload
      @usage_service = usage_service
    end

    def perform
      if user.created_at &lt; 14.days.ago
        Stripe::InvoiceItem.create(
          customer: user.stripe_id,
          amount: additional_charges_in_cents,
          currency: "usd",
          description: "Usage charges"
        )
      end
    end

    private

    def additional_charges_in_cents
      Billing::Tier.new(usage).additional_charges_in_cents
    end

    def usage
      @usage_service.new(user).last_30_days
    end

    def user
      @user ||= User.find_by(stripe_id: payload["data"]["object"]["customer"])
    end
  end
end</code></pre></figure>


<p>Because the <code>usage</code> method requires instantiation from within the class, I had to update the fake test Usage classes to accept <code>user</code> as an argument during instantiation:</p>

<figure class='code'><pre><code>require 'test_helper'

class InvoiceCreatedTest &lt; ActiveSupport::TestCase
  def setup
    @payload = {
      "data" =&gt; {
        "object" =&gt; {
          "customer" =&gt; "stripe_brandon"
        }
      }
    }
  end

  test 'adds invoice item based on usage' do
    Stripe::InvoiceItem.expects(:create).with(
      customer: "stripe_brandon",
      amount: 1900,
      currency: "usd",
      description: "Usage charges"
    )
    StripeEvent::InvoiceCreated.new(@payload).perform
  end

  test 'adds next level charge for usage' do
    Stat.create!(user: users(:brandon), step: steps(:nav_one), impressions: 3_000, date: 5.days.ago)

    Stripe::InvoiceItem.expects(:create).with(
      customer: "stripe_brandon",
      amount: 4900,
      currency: "usd",
      description: "Usage charges"
    )
    StripeEvent::InvoiceCreated.new(@payload).perform
  end

  test 'adds highest tier' do
    Stripe::InvoiceItem.expects(:create).with(
      customer: "stripe_brandon",
      amount: 49900,
      currency: "usd",
      description: "Usage charges"
    )
    inv = StripeEvent::InvoiceCreated.new(@payload, Level5Usage)
    inv.perform
  end

  test 'adds 2nd highest tier' do
    Stripe::InvoiceItem.expects(:create).with(
      customer: "stripe_brandon",
      amount: 24900,
      currency: "usd",
      description: "Usage charges"
    )
    inv = StripeEvent::InvoiceCreated.new(@payload, Level4Usage)
    inv.perform
  end

  test 'adds middle tier' do
    Stripe::InvoiceItem.expects(:create).with(
      customer: "stripe_brandon",
      amount: 12900,
      currency: "usd",
      description: "Usage charges"
    )
    inv = StripeEvent::InvoiceCreated.new(@payload, Level3Usage)
    inv.perform
  end

  test 'adds 2nd tier' do
    Stripe::InvoiceItem.expects(:create).with(
      customer: "stripe_brandon",
      amount: 4900,
      currency: "usd",
      description: "Usage charges"
    )
    inv = StripeEvent::InvoiceCreated.new(@payload, Level2Usage)
    inv.perform
  end

  test 'adds 1st tier' do
    Stripe::InvoiceItem.expects(:create).with(
      customer: "stripe_brandon",
      amount: 1900,
      currency: "usd",
      description: "Usage charges"
    )
    inv = StripeEvent::InvoiceCreated.new(@payload, Level1Usage)
    inv.perform
  end

  private

  Level5Usage = Struct.new(:user) { def last_30_days; 2_000_000; end }
  Level4Usage = Struct.new(:user) { def last_30_days; 900_000; end }
  Level3Usage = Struct.new(:user) { def last_30_days; 190_000; end }
  Level2Usage = Struct.new(:user) { def last_30_days; 19_000; end }
  Level1Usage = Struct.new(:user) { def last_30_days; 1_900; end }</code></pre></figure>


<p>The resulting test classes seem overly complex and sprinkled with details that arent particularly relevant to its responsibility. If we were to pass in an already instantiated usage class as an argument, it means we would have to already know the user before-hand, which means wed have to parse <code>@user ||= User.find_by(stripe_id: payload["data"]["object"]["customer])</code> outside of this class. I dont love that solution  the parent that calls this <code>InvoiceCreated</code> class is pretty minimal and I wanted to keep it that way.</p>

<p>Another option would be to provide <code>user</code> as an argument to the to the <code>last_30_days</code> method:</p>

<figure class='code'><pre><code>def usage
  @usage_service.new.last_30_days(user)
end</code></pre></figure>


<p>We could then change our fake test usage classes back to:</p>

<figure class='code'><pre><code>Level1Usage = Class.new { def last_30_days; 1_900; end }</code></pre></figure>


<p>Notice the lack of <code>Struct</code> with an argument</p>

<h2>Summary</h2>

<p>Of the two options, I prefer the setter injector in this case. Theres something about changing the signature of a class just for tests that didnt feel natural.</p>

<p>An accessor (or writer), in this case, provided the same flexibility without changing the signature. I like being able to quickly look at the argument list of <code>initialize</code> and clearly understand its roles and responsibilities within the system.</p>

<p>Which do you prefer?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Gemfile Teardown - 2014]]></title>
    <link href="http://brandonhilkert.com/blog/rails-gemfile-teardown-2014/"/>
    <updated>2014-12-03T13:14:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/rails-gemfile-teardown-2014</id>
    <content type="html"><![CDATA[<p>Whats the first thing you look at when you see the source code of a Rails project?</p>

<p>For me, its the <code>Gemfile</code>. Think about it&hellip;there&rsquo;s very few other files that contain so much information. It describes the building blocks of the application. And at times, you can even see specific features of the application.</p>

<!--more-->


<p>A <code>Gemfile</code> also includes hints about preference and style. And style is something most Ruby developers are very passionate about. It doesnt take long to find the story of a Rubyist describing their love at first sight experience with the language. Its hard to find another file in a Rails project thats so telling.</p>

<p>A year ago, I wrote about the <a href="http://brandonhilkert.com/blog/patterns-in-a-rails-gemfile/">Ruby gems I regularly use in my Rails applications</a>. Because technology and the tools we use change so fast, I thought itd be interesting to take a look at one of my more recent Gemfiles to see whats changed.</p>

<h2>Rails Templates</h2>

<p>As I mentioned in the last <a href="http://brandonhilkert.com/blog/patterns-in-a-rails-gemfile/">Gemfile post</a>, I tend to write a bunch of small applications sprinkled around some larger ones. Despite the size of the project, I feel like Ive honed in a set of Ruby gems that feel comfortable and productive for me and my workflow.</p>

<p>Knowing the act of bootstrapping a Rails project is sometimes tedious, I took some time to build a <a href="https://github.com/brandonhilkert/rails_templates">Rails template</a> around the gems and patterns I commonly use. Ill definitely be writing about this experience in the future since there seems to be very little discussion about it.</p>

<p>In short, extracting my preferences to a template has been a HUGE time saver. It no longer feels like a burden to run <code>rails new</code>. I can jump right in and have a consistent set of tools that enable me to be productive within a few minutes.</p>

<h2>My 2014 Gemfile</h2>

<p>The <code>Gemfile</code> below is one of the larger projects I worked on this year. I thought itd give a good sense of some of my more practical everyday preferences, along with some feature-specific choices for this particular application.</p>

<figure class='code'><pre><code>source 'https://rubygems.org'

ruby '2.1.4'

gem 'rails', '4.1.8'
gem 'pg'
gem 'sass-rails', '~&gt; 4.0.3'
gem 'uglifier', '&gt;= 1.3.0'
gem 'coffee-rails', '~&gt; 4.0.0'
gem 'jquery-rails'
gem 'turbolinks'

gem 'bcrypt-ruby', '~&gt; 3.1.2'

group :development, :test do
  gem 'pry'
end

group :test do
  gem 'selenium-webdriver'
  gem 'capybara'
  gem 'timecop'
  gem 'mocha'
end

group :development do
  gem 'quiet_assets'
  gem 'spring'
  gem 'bullet'
  gem 'stripe_tester', '~&gt; 0.1.0'
end

group :production, :demo do
  gem 'rails_12factor'
  gem 'heroku-deflater'
end

gem 'font-awesome-rails'
gem 'unicorn'
gem 'bootstrap-sass'
gem 'sidekiq', require: 'sidekiq/web'
gem 'sinatra'
gem 'local_time'
gem 'gravatar_image_tag'
gem 'so_meta'
gem 'chronic'
gem 'recurrence'

gem 'premailer-rails'

gem 'momentjs-rails'
gem 'bootstrap3-datetimepicker-rails'
gem 'bootstrap-switch-rails'
gem 'bootstrap-wysihtml5-rails'
gem 'bootstrap-select-rails'
gem 'autosize-rails'

gem 'aws-sdk'

gem 'html-pipeline'
gem 'rinku'

gem 'newrelic_rpm'
gem 'doc_raptor'
gem 'stripe'
gem 'jquery-ui-rails'
gem 'active_model_serializers'
gem 'rubyzip'
gem 'render_anywhere', require: false
gem 'pusher'
gem 'filepicker-rails'
gem 'memcachier'
gem 'dalli'
gem 'intercom-rails'</code></pre></figure>


<p>A few comments:</p>

<ul>
<li><p>Ive standardized on <a href="http://www.postgresql.org/">Postgres</a> as the database for my apps, even in development. Its reliable and allows me to be sure that the code I write will work the same way in production, since I tend to deploy most of my apps to <a href="https://www.heroku.com/">Heroku</a>.</p></li>
<li><p>I leave <code>turbolinks</code> on. Judging from recent posts and comments within the community, this will probably one of the more controversial decisions.</p>

<p>  If Im being honest, my first experience with Turbolinks wasnt great. And by wasnt great, I mean  it broke <strong>EVERYTHING</strong>! But the good news was that it brought to light the fact that I sucked at javascript. At the time, I was capable of writing <em>just</em> enough to modify form behavior or fade in an DOM element.</p>

<p>  The time had come to level up on my javascript skills. I was able to improve my javascript and also do it in a way that can took full advantage of the benefits that Turbolinks offers. Since that time, Ive left Turbolinks on and no longer had to worry that my client-side code will stop working after clicking through a few application links.</p></li>
<li><p>Ive standardized on using <code>has_secure_password</code> for authentication. I previously used <a href="https://github.com/plataformatec/devise">devise</a>, but found the extra features are no longer worth the additional complexity. <code>has_secure_password</code> provides me reliable authentication patterns that are simple to understand and maintain. Hence the need for <code>bcrypt</code> in the <code>Gemfile</code> above.</p></li>
<li><p>As for my test environment, Ive written about <a href="http://brandonhilkert.com/blog/7-reasons-why-im-sticking-with-minitest-and-fixtures-in-rails/">my switch to Minitest and fixtures</a>. Im still just as happy with that decision as the time I wrote about it. Ive seen Rspec go through a variety of API changes since then, and thankful I no longer have to worry about updating my test suite every couple months. I continue to find value in <code>capybara</code> and include <code>mocha</code> for the times <code>Minitest</code>s stubbing and mocking isnt enough (Ive been meaning to dig in to the places I use <code>mocha</code>. Im guessing if the code was better, I probably wouldnt need it at all).</p></li>
<li><p><code>bullet</code> is a killer gem for tracking down performances issues. Its saved me countless hours of debugging.</p></li>
<li><p>The inclusion of <code>spring</code> in Rails 4.1 is great. I realize its a bandaid in some respects, but waiting for the environment to load on every test run is a drag. Ive found that because my tests are so responsive when <code>spring</code> is working properly, it encourages me to run my tests more often. Once setup, it works well and only in rare cases has not reloaded when it should have.</p></li>
<li><p>I generally always include <code>bootstrap</code> and <code>font-awesome</code> in my projects. Being a non-designer, it helps me get something on the screen faster, even if its not the final design.</p></li>
<li><p>I continue to use <code>unicorn</code>. Its been around for so long and continues to be competitive in benchmarks against other Ruby web servers. I tested Passenger in a few applications, but got scared off when it printed the entire environment to the screen in production on Heroku on an exception. Im told there are ways around this with some non-trivial configuration, but I think its a bizarre default and isnt conducive to my workflow.</p></li>
<li><p>For the apps that need background processing, <code>sidekiq</code> continues to be my goto when a separate worker is necessary. I generally mount Sidekiqs web UI to provide insight to the state of the jobs, which is why <code>sinatra</code> is included.</p></li>
<li><p>Ive written about putting together <a href="http://brandonhilkert.com/blog/relative-timestamps-in-rails/">a gem to render relative timestamps</a> on the client side. While Id love to sit here and tell you I use it, I dont. Basecamps <a href="https://github.com/basecamp/local_time">local_time</a> gem is exceptional for that need and Im pretty sure we can count on it being updated and maintained well going forward (one of the biggest changes in my mindset for including a new gem).</p></li>
<li><p>This particular app has some pretty hairy time calculations and scheduling. Its not something I was very experienced with prior, but found value in the combination of <code>chronic</code> and <code>recurrence</code>. Both make the process of targeting a specific <code>datetime</code> and scheduling something in the future relatively simple.</p></li>
<li><p>I included a number of bootstrap related javascript gems (<code>bootstrap3-datetimepicker-rails</code>, <code>bootstrap-switch-rails</code>, <code>bootstrap-switch-rails</code>, <code>bootstrap-select-rails</code>). All are little more than a <a href="http://brandonhilkert.com/blog/how-to-build-a-rails-engine/">Rails engine</a> that exposes the appropriate javascript and stylesheets to the asset pipeline. These are particularly dependent on the project. Id normally not start by including anything like this. Side note &ndash; I couldve copied the relevant assets to <code>vendor/assets</code> rather than requiring a gem that does the same. In a few cases, some added view helpers as well.</p></li>
<li><p>Ive standardized on using New Relic to collect application metrics and exceptions.</p></li>
<li><p>It shouldnt be a surprise that <code>stripe</code> is the payment processor I reach for when Im in control. Its super developer-friendly and, at this point, Ive done enough that integration is not much more than a copy/paste from other apps. I recently started using <code>stripe_tester</code> in the test environment. Its been great for stubbing out calls to Stripe so the test suite continues to be performant. It also allows me to setup some unique edge-case data coming from Stripe so I can protect users from ending up in a crappy state.</p></li>
<li><p>I generally reach for <code>active_model_serializers</code> anytime I need a <code>json</code> response that contains more than a simple hash (in which case Id continue to render it in the controller response). Ive used the view equivalent solutions a few times (<code>jbuilder</code>, etc.) and they worked ok too, but for whatever reason, <code>active_model_serializers</code> does it for me.</p></li>
</ul>


<p>The rest are very use case-specific. And in general, the defacto solution for each (<code>pusher</code> for real-time features, <code>dalli</code> for memcached, etc.).</p>

<h2>Summary</h2>

<p>Im happy with my current toolkit. This doesnt mean Im not on the lookout for shiny new things, but Im generally a little more cautious about replacing something reliable, even if it doesnt do everything under the sun.</p>

<p>Even though Ruby makes it easy to include third party libraries, it doesnt mean we always should. As developers, we inherit the stability of the dependencies we include. Even though a gems code might be locked away behind a separate git repository, it likely has the same holes and complexities that were worried about in our applications. And perhaps, even more</p>

<p><a href="https://www.ruby-toolbox.com/">Ruby toolbox</a> is a great resource when searching for a gem. I generally consider the number of downloads, age of the project and development activity when deciding which one to go with.</p>

<p>What have your favorite gems been this year?</p>

<h2>Build a Ruby Gem</h2>

<p>Ruby gems are the building blocks of Ruby/Rails applications. If you havent built one yourself, theres no better time to start. Github makes it extremely to contribute to existing gems and sometimes thats <a href="http://brandonhilkert.com/blog/3-ways-to-get-started-contributing-to-open-source/">the easiest way to get started contributing to open source</a>. My book, <em>Build a Ruby Gem</em>, includes <a href="http://brandonhilkert.com/books/build-a-ruby-gem/">everything you to need to get started building a Ruby gem</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Active Record Validation Contexts with Inheritance]]></title>
    <link href="http://brandonhilkert.com/blog/creating-rails-active-record-validation-contexts-with-inheritance/"/>
    <updated>2014-11-18T17:20:00-05:00</updated>
    <id>http://brandonhilkert.com/blog/creating-rails-active-record-validation-contexts-with-inheritance</id>
    <content type="html"><![CDATA[<p>If youve used <code>validates</code> in a Rails Active Record model, you know they work great &#8211; at least until the first bit of complexity arises. At that point, they can quickly morph in to a ball of conditional spaghetti convoluting the initial reason the validation was added in the first place.</p>




<p>I recently had an experience using <code>has_secure_password</code> where I wanted control the length of the user-supplied password. Adding a length validation to the password accessor invalidated existing records, so I was in a bit of a bind. In the end, I sub-classed the Active Record model to create a unique model made specifically for that context. This allowed me to inherit the core functionality from the model and sprinkle on existing validations for specific use cases. This was a new tactic for me and Im still not sure how I feel about it. I like the fact that it removed complexity from the <code>User</code> model. This, in hopes, will keep the minimize the likelihood of it becoming a God object.</p>




<!--more-->




<h2>The Problem</h2>




<p>Using <code>has_secure_password</code> is a relatively easy way to add authentication to a Rails app. In order to disguise the plain text passwords, an <a href="https://github.com/rails/rails/blob/3bdf7b80a11dcb67b18553ff1fe0da82b0cffc20/activemodel/lib/active_model/secure_password.rb#L106">accessor for the plain <code>password</code></a> is added that encrypts it before saving.</p>




<p>The only true Active Record validation <code>has_secure_password</code> adds is a <a href="https://github.com/rails/rails/blob/3bdf7b80a11dcb67b18553ff1fe0da82b0cffc20/activemodel/lib/active_model/secure_password.rb#L68">confirmation of the password</a>  and only when the password is present. This allows us to create a user object without supplying a password, or maybe saving straight to the <code>password_digest</code> field, which is used to store the encrypted password in the database.</p>




<p>I wanted to enforce a minimum password length, because what good is a 1 character password (or 0 for that matter) ?!?!</p>




<p>The first thing I did was add this to the <code>User</code> model:</p>




<pre><code>validates :password, length: { minimum: 8 }
</code></pre>




<p>This works for new users, but not for those with a <code>password_digest</code> already. Attempting to updated an existing user produces the following error:</p>




<pre><code>ActiveRecord::RecordInvalid: Validation failed: Password is too short (minimum is 8 characters)
</code></pre>




<p>The next step was to conditionalize only on create:</p>




<pre><code>validates :password, length: { minimum: 8 }, on: :create
</code></pre>




<p>Except, that wasnt right either because Id definitely want to allow users to update their password, in which case, the length validation wouldnt be enforced.</p>




<p>I found another <a href="http://quickleft.com/blog/rails-tip-validating-users-with-has_secure_password">post suggesting to allow <code>nil</code></a> using:</p>




<pre><code>validates :password, length: { minimum: 8 }, allow_nil: true
</code></pre>




<p>But, again, that felt weird and doesnt read particularly well when youre looking through the source trying to understand what condition would generate a <code>nil</code> password.</p>




<p>Other solutions included <a href="http://stackoverflow.com/a/6486345/2261909">mixing conditionals and checking model dirty state</a> and <a href="http://urgetopunt.com/rails/2012/11/12/validate-password-presence-has-secure-password.html">some combination of all of the above</a>.</p>




<p>Im guessing some combination of the above wouldve worked, but something didnt feel quite right. A quick glance over any of those solutions left me wanting something cleaner and more approachable. Because its a complex and tremendously important part of the app, I wanted to feel comfortable with the solution.</p>




<h2>The Solution</h2>




<p>I recently read <a href="https://leanpub.com/growing-rails"><em>Growing Rails Application in Practice</em></a>. The most interesting takeaway for me was the idea of sub-classing an Active Record object to exactly the problem described above.</p>




<p>Consider thiswe have our <code>User</code> model with <code>has_secure_password</code>:</p>




<pre><code>class User &lt; ActiveRecord::Base
  has_secure_password
end
</code></pre>




<p>As we saw above, the variety of validation contexts made the standard ActiveModel validation awkward. What if we sub-class <code>User</code> and add the validation contexts for a specific use case? In our case, minimum length:</p>




<pre><code>class User::AsSignUp &lt; User
  validates :password, length: { minimum: 8 }
end
</code></pre>




<p>In this case, were create a separate model, for the purpose of signing up, and perhaps other user-related attribute management (profile, password reset, etc.).</p>




<p>Now, instead of passing the <code>User</code> model to the view from the controller, we pass an instantiated version of the new context-specific model class:</p>




<pre><code>def create
  @user = User::AsSignUp.find(current_user.id)
  
end
</code></pre>




<p>Lastly, because the sub-class name is inferred within the form, we have to do one more thing to make the params are accessible on the <code>create</code> action using <code>params[:user]</code>. Well change the form from:</p>




<pre><code>&lt;%= form_for @user, url: user_confirm_path(@user.invitation_token) do |f| %&gt;
</code></pre>




<p>to:</p>




<pre><code>&lt;%= form_for @user, as: :user, url: user_confirm_path(@user.invitation_token) do |f| %&gt;
</code></pre>




<p>Because the remainder of the app operates fine without any need for the password validation, the <code>User</code> can be used where necessary and without worry of it becoming invalid because the password accessor isnt present.</p>




<h2>Summary</h2>




<p>While sub-classing models in Rails is generally frowned upon, this use case is one of the few that felt reasonable. It feels relatively low cost and stays in isolation. Id love to hear how you might have solved this problem. I looked and explored a handful of solutions. While others worked, none seems as expressive as the one above.</p>


<p>A form object using
<a href="http://api.rubyonrails.org/classes/ActiveModel/Model.html">ActiveModel</a> or
similar could&rsquo;ve been an alternative option. I didn&rsquo;t explore it for this
particular use case, mostly because I wanted to give this one a shot. However,
I have no doubt it would&rsquo;ve at least worked equally as well.</p>

<p>I should also point out that I&rsquo;m familiar with the built-in <a href="https://github.com/rails/rails/blob/master/activemodel/lib/active_model/validations.rb#L73">validation
contexts in ActiveModel</a>.
And for whatever reason, I&rsquo;ve not used them before. I&rsquo;ll probably give it a
shot on another occasion for comparison.</p>

<p>What are your thoughts on this technique?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing Funnel Tools]]></title>
    <link href="http://brandonhilkert.com/blog/introducing-funneloptimizer-dot-io/"/>
    <updated>2014-10-06T21:21:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/introducing-funneloptimizer-dot-io</id>
    <content type="html"><![CDATA[<p>Last month marks the 6 month anniversary of the release of <a href="http://brandonhilkert.com/books/build-a-ruby-gem/">Build a Ruby Gem</a>. Thinking back to this time last year, I wouldve never guessed that I would launch a product to the tune of $16k+ sales in 6 months. Thanks to the help of expert teachers, I was able to quickly get over my fear of marketing and put my technical knowledge to good use.</p>

<p>The weeks leading up to the launch seem like a blur now. At the time, I had a perfectly crafted schedule of marketing material and approaches that, as far as I can tell, were the difference between no sales and quite a few.</p>

<!--more-->


<p>One of the biggest lessons learned was capturing emails on my <a href="http://brandonhilkert.com">blog posts</a>. Newsletter opt-ins are fantastic way to gather interest and offer subscribers additional incentives like discounts or other non-public postings. I, like many, made use of related blog posts to capture emails with a form like this:</p>

<p><img class="center" src="http://brandonhilkert.com/images/funnel_optimizer/newsletter-form.png" title="&#34;BrandonHilkert.com newsletter form&#34;" alt="&#34;BrandonHilkert.com newsletter form&#34;"></p>

<p>One of the benefits of serving a niche like Ruby programmers is there are quite a few repeat visitors. Around the new year, I was posting twice a month, and then every week leading up to the launch. The posts were naturally related to the content of building a Ruby gem and gave some teasers to what readers could expect in the <a href="http://brandonhilkert.com/books/build-a-ruby-gem/">book</a>.</p>

<p>But one of the things that always bummed me out was how previously subscribed readers to my newsletter <strong>STILL saw the same newsletter opt-in form shown above</strong>. <em>Why on Earth would that be helpful to the them???</em></p>

<p>They cant sign up twice, so why would I show them the form again? It turns out theres no good answer for this. In general, the quickest way to solve this problem is to purchase a fancy marketing automation system and pay potentially 4 figures a month. There was no room for this with my little budget.</p>

<p>Ideally, what I wanted was to show my first visitor the opt-in form above, and then if they signed up, promote my book. Regardless of what I show, I could be using the real estate to show something that was more beneficial to the reader. And thats the thing, its all about them. Anything I showed them beyond the form they already subscribed with would be more beneficial.</p>

<h2>Im excited to tell you about the <a href="http://brandonhilkert.com/funnel-tools/funnel/">Funnel Tools Plugin</a>!</h2>

<p>I built the plugin for people like me, and you. I want to help you sell more products, and provide even more value than youre already providing. Funnel Optimizer offers you the opportunity to tailor your CTAs based on actions your audience have previously taken.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Absolutes as an AntiPattern]]></title>
    <link href="http://brandonhilkert.com/blog/absolutes-as-an-antipattern/"/>
    <updated>2014-09-28T22:35:00-04:00</updated>
    <id>http://brandonhilkert.com/blog/absolutes-as-an-antipattern</id>
    <content type="html"><![CDATA[<p>Its been awhile since my last post  almost 2 months to be specific. A trip to Portugal, getting sick and a minor run-in with a table saw made it challenging to post anything for the last couple weeks. But Id be lying if I said I was itching to write.</p>

<p>During that time, I didnt have anything screaming to be talked about. I have a long list of decent post topics, but none of them got me particularly excited. Until today</p>

<!--more-->


<p>I stumbled on a blog post related to Railss upcoming <a href="http://edgeguides.rubyonrails.org/active_job_basics.html">Active Job feature</a>. While demonstrating the syntax for specifying the adapter, there was comment in the code snippet that said <em>inline and other worse options</em>. This caught me by surprise and bummed me out at the same time. Not only because Im the author of <a href="https://github.com/brandonhilkert/sucker_punch">one of them</a>, but because there are a handful of background processing libraries in Ruby that are really good.</p>

<p>So, naturally, I pinged the author and mentioned the comment might be sending the wrong message. He responded with I consider sidekiq to be the best background processing tool available for Ruby. And then later, <em>sidekiq is significantly better that delayed_job and resque. Youre welcome to disagree</em>.</p>

<p><em>Note: The responses above illustrate a general sentiment. By no means is this post focused on the individual that said them.</em></p>

<p>The thing is, I dont completely disagree. As you probably already know, Im a huge fan of of <a href="http://sidekiq.org/">Sidekiq</a>. Ive contributed to the project and believe Sidekiqs author, <a href="https://www.mikeperham.com/">Mike Perham</a> is not only a great leader in the Ruby community, but a great example of how to manage and lead open source projects well.</p>

<p>However, those responses reminded me how damaging absolutes can be. Youve probably heard it before:</p>

<blockquote><p>we can <strong>ABSOLUTELY NOT</strong> do x, y and z</p></blockquote>

<p><em>Why not? Will the world end? How do I know?</em></p>

<p>or, what about:</p>

<blockquote><p>this feature needs to go out tomorrow, no excuses</p></blockquote>

<p><em>What if there is an excuse? What if its not ready? Will I be fired? Will our company go under?</em></p>

<p>There are trade-offs to every decision made. While some options may not be ideal, they may still work, perhaps just not as well.</p>

<p>Absolutes beg the toddler question, <em>why?</em>. <em>Why wont that language X work?</em> <em>Why cant we use Y?</em>. If you dont know the answer to those questions, youre doing yourself a disservice by not asking. Maybe the person has thoroughly researched the topic to come up with those conclusions. But, maybe, they havent.</p>

<p>Ive noticed those who do exhaustive research on a topic tend to present the information in a different manner. Theyre confident the facts they found will prove their case and seem to present their findings less defensively. No, <em>it has to be done like this</em>. More like, <em>I found a few ways to fix the problem and heres why I think option 1 might be the best solution. What do you think?</em>.</p>

<p>Whether you follow agile or any other methodology, predictions and absolutes have no place in conversations. There are plenty of examples of failed software projects. Im pretty sure all of them featured people promising the work would be done in time and under budget. Buuuuuuut, it wasnt.</p>

<h2>Background Jobs for the Big Boys</h2>

<p>Delayed Job was the first Ruby background processing library I used. I remember feeling badass that I was doing all this complicated stuff in the background. But at some point, there we so many jobs and so much activity that pushing and pulling jobs out of the primary data store wasnt efficient. Reads from the web UI would slow down (and ultimately stop) and users would bail. Unfortunately, I couldnt pop up a message and say, <em>hey, hope you dont mind, but Im doing some pretty crucial shit in the background here, so youre experience is gonna be sucky for a bit! sorry :(</em>.</p>

<p>So, at the time, Resque was the next logical transition. I migrated the previously written jobs from Delayed Job to Resque and experienced a new level of <em>bad ass</em>. Fast forward 4 years  I still work on projects using Resque. Needless to say, its a pretty awesome piece of open source software.</p>

<p>A few years ago, Sidekiq came along. While I didnt know much about multi-threading code in Ruby, I tried it on a side project and was floored at the results. Those 6 Heroku workers that Id been paying for could be compacted in to 1?!?! And on top of that, I only needed 1 worker that had 25 workers working against the queue?!?!</p>

<p>But then one day, I dropped it in to a project that was using MongoDB and MongoMapper as ORM and things didnt go so well. In the end, MongoMapper wasnt thread-safe, which is a requirement of Sidekiq worker code. So in that case, was Sidekiq the best tool for the job? While I wouldve loved to use Sidekiq on that project, it certainly (like the absolute there) wasnt the right tool for <em>that</em> job.</p>

<p>And what about when I first started with Delayed Jobwe were a small startup with limited cash. While it seems silly to balk over an extra $35 Heorku dyno, it was $35 that couldve gone towards something else. Not to mention the extra Redis instance, along with the expertise to make sure the thing didnt fall over and die. Was Sidekiq (or Resque for that matter) the best tool for that job? Nope!</p>

<p>Fast forward a few years, I had the need for an in-process background processing library, so <a href="http://brandonhilkert.com/blog/why-i-wrote-the-sucker-punch-gem/">I wrote one</a>. That need was driven off the motivation above  needing to minimize cost and complexity. Would Sidekiq have worked for that project? Of course! In fact, it was using Sidekiq for a year or so before I transitioned the jobs to use Sucker Punch.</p>

<h2>Use Cases</h2>

<p>At this point, you should be noticing a trend, right? The examples above were unique use cases with a unique set of requirements and limitations. Sure, if every project I worked on had unlimited resources (both time and money), Sidekiq would be probably be my go-to the majority of time (even when writing that sentence I hesitated and almost wrote all the time).</p>

<p>But I hesitate now. Because I remember learning about the new cool things and thinking, <em>This is the best! Theres no way Ill never not use it</em>. And when I would talk to other developers, I would rave about how <em>X</em> is the best for <em>Y</em>. And now I realize I was a dummy for doing that. Theres no way I couldve made that judgement for someone else and their work. What I really shouldve said was, <em>I tried [insert fancy new gem/technique] for the first time the other day. It worked really well for doing X in my project that does Y</em>. That definitely doesnt sound as exciting, but it was the truth.</p>

<p>I feel fortunate to get to write Ruby everyday. Its incredibly expressive, which is why the debate over the countless ways to do something is great. Does the code express the right intent? For your method, it might. But for mine, it might express the complete opposite. The good news is, thats OK. Both versions will work and the fact that we can have conversations like that is a praise for the language itself. I prefer to have the opportunity to have that conversation about style, rather than a language more black and white. Maybe its the creative in me, but it seems like no 2 Ruby solutions will be identical and thats one of the things I love most about writing Ruby.</p>

<p>We often joke about the stack overflow post that starts with <em>Im thinking about learning Railsis it better than PHP?</em>. Or even more relevant today, <em>Which javascript framework should I use?</em>.</p>

<p>And then theres the guy who comes along and is all like, <em>Lets back up, what are you doing and why do you absolutely need a FRAMEWORK????</em>. While I used to ignore those types of comments, theyre the kind that I think about now and find myself typing. And that has me wonderingwhy the change?</p>

<h2>Experience, Experience, Experience</h2>

<p>I got to thinking about how I felt when I was first learning to program. When I started to feel comfortable with Rails, my confidence was through the roof. But at the same time, my naivety was at an all time high. I had had minimal experiences with software systems that were either critical or heavily-loaded. But having found Resque, I felt like I could solve the worlds problems. This is somewhat of an exaggeration, but not too far off. I realized that, as it relates to my technical career, my naivety is doing this related to time:</p>

<p><img class="center" src="http://brandonhilkert.com/images/absolutes/naivety-graph.png" title="&#34;Graph of Naivety over Time&#34;" alt="&#34;Graph of Naivety over Time&#34;"></p>

<p>The less naivety, the more options and, naturally, certainty takes a nose dive:</p>

<p><img class="center" src="http://brandonhilkert.com/images/absolutes/certainty-graph.png" title="&#34;Graph of Certainty over Time&#34;" alt="&#34;Graph of Certainty over Time&#34;"></p>

<p>The more I learn about programming in general, the more questions I have. Fortunately, experiences have brought me to a point where I can fairly weigh the use of Sucker Punch or Delayed Job for a particular use case. Im not sure projecting absolutes from up high does anyone any good. Beginners will take it as the word and spread the message to others they come across.</p>

<p>Use cases are real. And the less we force our own biases on people, the faster theyll realize experience is key and the random guy behind the cat avatar on Stack Overflow might actually be asking the right questions  even if they are convoluted.</p>

<p>Next time you hear an absolute, ask <em>Why?</em>.</p>
]]></content>
  </entry>
  
</feed>
